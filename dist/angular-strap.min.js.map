{"version":3,"sources":["angular-strap.js","typeahead/typeahead.js","helpers/compiler.js","dropdown/dropdown.js","tooltip/tooltip.js","timepicker/timepicker.js","tab/tab.js","select/select.js","scrollspy/scrollspy.js","popover/popover.js","navbar/navbar.js","modal/modal.js","helpers/raf.js","helpers/parse-options.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","datepicker/datepicker.js","collapse/collapse.js","button/button.js","aside/aside.js","alert/alert.js","affix/affix.js","module.js"],"names":["placement","document","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","bsCompilerService","$inject","$http","get","angular","module","defaults","this","animation","data","compile","controller","console","controllerAs","resolve","copy","locals","bindToController","forEach","value","isString","$injector","key","invoke","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","trigger","provider","container","keyboard","delay","minLength","filter","limit","autoSelect","comparator","trimValue","$get","$typeahead","parentScope","$resetMatches","$window","$rootScope","$tooltip","$$rAF","$timeout","$matches","config","$$postDigest","$scope","activate","$activeIndex","select","index","$select","evt","matches","$isVisible","safeDigest","update","$render","$emit","prefixEvent","length","equals","$onMouseDown","preventDefault","stopPropagation","keyCode","$digest","show","isUndefined","$element","hide","$onKeyDown","$$phase","$root","TypeaheadFactory","array","isFunction","$filter","expression","directive","results","postLink","attr","restrict","require","falseValueRegExp","bsOptions","test","parsedOptions","$parseOptions","typeahead","watchOptions","watchedOptions","$watchCollection","values","$match","$watch","ngModel","newValue","oldValue","$modelValue","valuesFn","selectMode","$setViewValue","$viewValue","substring","displayValue","slice","$formatters","push","modelValue","selected","val","destroy","label","toString","$on","target","titleTemplate","title","type","autoClose","bsEnabled","viewport","selector","padding","isTouch","TooltipFactory","$new","split","enterAnimateCallback","leaveAnimateCallback","_tipToHide","destroyTipElement","triggers","nodeName","on","toggle","enter","unbindTriggerEvents","$onFocusElementMouseDown","off","i","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","elRect","getBoundingClientRect","rect","p","width","height","top","left","dimensions","offset","el","scroll","outerDims","isBody","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","clearTimeout","timeout","$isShown","tipScope","$destroy","$options","$promise","$bsCompiler","toLowerCase","$id","map","parseFloat","$sce","trustAsHtml","$setEnabled","id","$hide","setEnabled","isEnabled","hoverState","compileData","promise","tipContainer","init","bindTriggerEvents","isElement","focus","parent","after","lastChild","display","visibility","clonedElement","addClass","prefixClass","version","prepend","$applyPlacement","$animate","leave","_blur","blur","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","query","querySelectorAll","tooltip","transclusion","isDefined","dataTarget","hasOwnProperty","$observe","bsTooltip","bsShow","match","setViewport","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","maxTime","Infinity","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","isNative","$timepicker","timepickerFactory","formatDate","format","viewDate","hour","startDate","getHours","meridian","coeff","selRange","end","start","setSelectionRange","collapse","selectionStart","moveStart","selectionEnd","moveEnd","focusElement","_init","floorMinutes","time","floor","lang","selectedIndex","date","defaultDate","second","getSeconds","millisecond","getMilliseconds","$dateValue","hoursFormat","$dateFormatter","minute","timeSeparator","minutesFormat","secondsFormat","showAM","$iconUp","$moveIndex","$switchMeridian","switchMeridian","isDate","getMinutes","getTime","$build","keep","Date","setHours","setMinutes","setSeconds","midIndex","hours","disabled","minutes","$date","seconds","rows","showSeconds","$isDisabled","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","targetDate","targetEl","triggerHandler","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","setFullYear","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","timepicker","dateParser","$dateParser","validateAgainstMinMaxTime","timezoneOffsetAdjust","NaN","parse","self","navClass","activeClass","$activeClass","$panes","$activePaneChangeListeners","$push","pane","$active","$attrs","$navClass","$remove","active","activeIndex","indexOf","splice","$setActive","name","fn","$pane","$tab","transclude","ngModelCtrl","bsTabsCtrl","attrs","bsActivePane","parsedBsActivePane","assign","$parse","controllers","render","$isActive","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$activate","$selectNone","$updateActiveIndex","a","b","$apply","isArray","$selectScrollFix","$isIE","stopImmediatePropagation","ua","activeElement","tagName","e","dataMultiple","inputEl","addEventListener","join","$getIndex","$isEmpty","spies","$document","windowEl","debounce","bodyEl","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","sortedElements","activeTarget","debouncedCheckOffsets","viewportHeight","debouncedCheckPosition","throttledCheckPosition","checkPositionWithEventLoop","checkOffsets","checkPosition","docEl","$activateElement","offsetTop","setTimeout","source","$getTrackedElement","targetElement","querySelector","trackedElement","trackElement","toDelete","untrackElement","scrollspy","childEl","child","content","$popover","PopoverFactory","requestAnimationFrame","bsPopover","popover","routeAttr","$navbar","liElements","li","liElement","pattern","path","RegExp","regexp","backdrop","bodyElement","backdropCount","dialogBaseZindex","ModalFactory","$modal","unbindBackdropEvents","modalElement","hideOnBackdropClick","backdropElement","preventEventDefault","modalScope","$show","bottom","destroyModalElement","z-index","backdropBaseZindex","customClass","minor","backdropAnimation","bindBackdropEvents","defaultPrevented","which","modalClass","bsModal","modal","dot","cancelAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","raf","timer","cancel","supported","$values","valueName","keyName","displayFn","valueFn","ParseOptionsFactory","groupByFn","factory","offsetParent","docElement","ownerDocument","outer","window","getComputedStyle","extra","currentStyle","boxRect","style","curPosition","curLeft","curCSSTop","curTop","calculatePosition","curElem","curCSSLeft","curOffset","call","offsetParentRect","offsetParentEl","offsetParentElement","func","immediate","args","context","callNow","leading","wait","trailing","year","$localeProvider","milliseconds","ParseDate","prototype","noop","indexOfCaseInsensitive","len","str","strict","DateParserFactory","day","month","getFullYear","getMonth","proto","isNumeric","toDate","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","dateRegexParts","escapeReservedSymbols","text","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","setMap","m","HH","H","hh","h","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","s","setDate","setMonth","regex","$format","regExpForFormat","baseDate","formatRegex","formatSetMap","fromDate","getDate","today","getDateForAttribute","substr","getTimeForAttribute","daylightSavingAdjust","undo","getTimezoneOffset","getDefaultLocale","getDatetimeFormat","weekdaysShort","splitTimeFormat","service","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","parentEl","hasClass","tAttrs","nextSibling","nodeType","parentNode","removeChild","bsDropdown","dropdown","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","iconLeft","iconRight","DatepickerFactory","$datepicker","pickerViews","views","$iconLeft","$iconRight","$picker","$views","$mode","datepickerViews","$selectPane","$toggleMode","setMode","updateDisabledDates","disabledDateRanges","dateRanges","mode","pristine","$updateSelected","built","$setDisabledEl","isDisabled","steps","getUTCFullYear","getUTCMonth","UTC","getUTCDate","shiftKey","altKey","onKeyDown","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","size","arrays","mod","n","arr","weekDaysMin","weekDaysLabelsHtml","picker","weekDaysLabels","concat","firstDayOfMonth","firstDayOfMonthOffset","firstDate","firstDateOffset","build","days","isToday","toDateString","muted","showLabels","labels","isSelected","getDay","months","lastDate","actualMonth","firstYear","years","actualYear","Array","setYear","startCollapsed","allowMultiple","activeIndexes","$targets","activeItems","activateItem","$collapse","$viewChangeListeners","$registerToggle","$toggles","$unregisterToggle","$unregisterTarget","deactivateItem","fixActiveItemIndexes","disallowToggle","isActive","$activeIndexes","bsCollapseCtrl","bsCollapseToggle","$registerTarget","action","toggleEvent","$button","constantValueRegExp","isInput","trueValue","falseValue","hasExoticValues","checked","bind","toggleClass","AsideFactory","$aside","bsAside","aside","duration","dismissable","AlertFactory","$alert","bsAlert","alert","AffixFactory","$affix","inlineStyles","reset","initialOffsetTop","getRequiredAffixClass","_unpin","getScrollTop","scrollHeight","getScrollHeight","offsetBottom","elementHeight","initialAffixTop","pageYOffset","affixed","unpin","$parseOffsets","affix","setWidth","offsetUnpin","$onResize","$debouncedOnResize","initialPosition","affixTarget","option"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\n'use strict';\n\n// Source: typeahead/typeahead.js\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function () {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function (matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function (index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function (index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $typeahead.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function (evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function () {\n            if ($typeahead.$element) {\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n              if (options.keyboard) {\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\n              }\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function () {\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect) {\n            $typeahead.activate(-1);\n          }\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function ($filter) {\n    return function (array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function (results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      }\n      return $filter('filter')(array, expression, comparator);\n    };\n  })\n\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function (values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (modelValue && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          element.val(options.trimValue === false ? value : value.trim());\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tooltip/tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isTouch = 'createTouch' in $window.document;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: timepicker/timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n        var timezone = options.timezone;\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat, timezone),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat, timezone),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat, timezone),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat, timezone).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat, timezone).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat, timezone).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat, timezone).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat, timezone).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat, timezone).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat, options.timezone);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat, options.timezone);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tab/tab.js\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function (pane) {\n        if (angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function (pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if (angular.isString(active)) {\n          activeIndex = self.$panes.map(function (pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function (value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n    };\n\n    this.$get = function () {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function ($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function ($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function (newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if (bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function (newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function () {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: select/select.js\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: scrollspy/scrollspy.js\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function () {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if (!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if (spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded;\n        var unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        /* eslint-disable no-unused-vars */\n        var viewportHeight;\n        /* eslint-enable no-unused-vars */\n        var scrollTop;\n\n        $scrollspy.init = function () {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if (scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function () {\n\n          // Check internal ref counter\n          this.$$count--;\n          if (this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function () {\n\n          // Not ready yet\n          if (!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if (activeTarget === sortedElements[i].target) continue;\n            if (scrollTop < sortedElements[i].offsetTop) continue;\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function () {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function (element) {\n          if (activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if (activeElement) {\n              activeElement.source.removeClass('active');\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function (target) {\n          return trackedElements.filter(function (obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function () {\n\n          angular.forEach(trackedElements, function (trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function (el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function (a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function (target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function (target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function (i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function () {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n\n// Source: popover/popover.js\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: navbar/navbar.js\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function ($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function () {\n\n          return $location.path();\n\n        }, function (newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function (li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if (options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if (regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: modal/modal.js\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function (key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $modal.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px'});\n        promise.then(function (data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function () {\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function () {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function () {\n          if ($modal.$isShown) return;\n\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if (modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\n\n          if (options.backdrop) {\n            // set z-index\n            modalElement.css({'z-index': dialogBaseZindex + (backdropCount * 20)});\n            backdropElement.css({'z-index': backdropBaseZindex + (backdropCount * 20)});\n\n            // increment number of backdrops\n            backdropCount++;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: customClass\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n\n          // Options: animation\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function () {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function () {\n          if (!$modal.$isShown) return;\n\n          if (options.backdrop) {\n            // decrement number of modals\n            backdropCount--;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if (options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function () {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n\n        $modal.focus = function () {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function (evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick(evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement() {\n          if ($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function ($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Options: alias modalClass to customClass\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: helpers/raf.js\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n\n// Source: helpers/parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n\n// Source: helpers/dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n\n// Source: helpers/debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n// Source: helpers/date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat(format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex(format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral(text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars(text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat(format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n\n// Source: helpers/date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n\n// Source: helpers/compiler.js\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement(query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate(template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n\n// Source: dropdown/dropdown.js\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */$dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.classList.contains('dropdown-menu')) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink(scope, element, attr) {\n\n          // Directive options\n          var options = {scope: scope};\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n\n// Source: datepicker/datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n\n// Source: collapse/collapse.js\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function (element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function (element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function (element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function (element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function (value) {\n        if (angular.isArray(value)) {\n          self.$targets.$active = value;\n        } else if (!self.$options.disallowToggle && isActive(value)) {\n          deactivateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function () {\n        if (self.$options.allowMultiple) {\n          return self.$targets.$active;\n        }\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for (var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function () {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            } else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              } else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function () {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function () {\n          if (!attrs.disabled) {\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n            bsCollapseCtrl.$setActive(index * 1);\n            scope.$apply();\n          }\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function ($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if (bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          } else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: button/button.js\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      toggleEvent: 'click'\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if (constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if (constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if (hasExoticValues) {\n          controller.$parsers.push(function (viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function (modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function (newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if (!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if (!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function (child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function (v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: aside/aside.js\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function ($window, $sce, $aside) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAside) {\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: alert/alert.js\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: affix/affix.js\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function () {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function ($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom';\n        var setWidth = false;\n        var initialAffixTop = 0;\n        var initialOffsetTop = 0;\n        var offsetTop = 0;\n        var offsetBottom = 0;\n        var affixed = null;\n        var unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          } else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function () {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function () {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function () {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function () {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if (affixed === affix) return;\n          affixed = affix;\n\n          if (affix === 'top') {\n            unpin = null;\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if (affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            } else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if (setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function () {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function () {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles) {\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if (options.offsetTop) {\n            if (options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if (options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              } else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            } else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if (options.offsetBottom) {\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            } else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles) {\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(_unpin, position, elementHeight) {\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if (scrollTop <= offsetTop) {\n            return 'top';\n          } else if (_unpin !== null && (scrollTop + _unpin <= position.top)) {\n            return 'middle';\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          }\n          return 'middle';\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function ($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function (key) {\n          if (angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function () {\n          if (affix) affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function () {\n    return {\n      controller: function ($element) {\n        this.$element = $element;\n      }\n    };\n  });\n\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n\n})(window, document);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function () {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function (matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function (index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function (index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $typeahead.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function (evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function () {\n            if ($typeahead.$element) {\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n              if (options.keyboard) {\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\n              }\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function () {\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect) {\n            $typeahead.activate(-1);\n          }\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function ($filter) {\n    return function (array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function (results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      }\n      return $filter('filter')(array, expression, comparator);\n    };\n  })\n\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function (values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (modelValue && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          element.val(options.trimValue === false ? value : value.trim());\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement(query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate(template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */$dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.classList.contains('dropdown-menu')) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink(scope, element, attr) {\n\n          // Directive options\n          var options = {scope: scope};\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isTouch = 'createTouch' in $window.document;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n        var timezone = options.timezone;\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat, timezone),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat, timezone),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat, timezone),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat, timezone).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat, timezone).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat, timezone).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat, timezone).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat, timezone).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat, timezone).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat, options.timezone);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat, options.timezone);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function (pane) {\n        if (angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function (pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if (angular.isString(active)) {\n          activeIndex = self.$panes.map(function (pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function (value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n    };\n\n    this.$get = function () {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function ($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function ($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function (newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if (bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function (newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function () {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function () {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if (!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if (spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded;\n        var unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        /* eslint-disable no-unused-vars */\n        var viewportHeight;\n        /* eslint-enable no-unused-vars */\n        var scrollTop;\n\n        $scrollspy.init = function () {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if (scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function () {\n\n          // Check internal ref counter\n          this.$$count--;\n          if (this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function () {\n\n          // Not ready yet\n          if (!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if (activeTarget === sortedElements[i].target) continue;\n            if (scrollTop < sortedElements[i].offsetTop) continue;\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function () {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function (element) {\n          if (activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if (activeElement) {\n              activeElement.source.removeClass('active');\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function (target) {\n          return trackedElements.filter(function (obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function () {\n\n          angular.forEach(trackedElements, function (trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function (el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function (a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function (target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function (target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function (i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function () {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function ($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function () {\n\n          return $location.path();\n\n        }, function (newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function (li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if (options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if (regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function (key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $modal.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px'});\n        promise.then(function (data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function () {\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function () {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function () {\n          if ($modal.$isShown) return;\n\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if (modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\n\n          if (options.backdrop) {\n            // set z-index\n            modalElement.css({'z-index': dialogBaseZindex + (backdropCount * 20)});\n            backdropElement.css({'z-index': backdropBaseZindex + (backdropCount * 20)});\n\n            // increment number of backdrops\n            backdropCount++;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: customClass\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n\n          // Options: animation\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function () {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function () {\n          if (!$modal.$isShown) return;\n\n          if (options.backdrop) {\n            // decrement number of modals\n            backdropCount--;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if (options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function () {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n\n        $modal.focus = function () {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function (evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick(evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement() {\n          if ($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function ($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Options: alias modalClass to customClass\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat(format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex(format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral(text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars(text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat(format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function (element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function (element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function (element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function (element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function (value) {\n        if (angular.isArray(value)) {\n          self.$targets.$active = value;\n        } else if (!self.$options.disallowToggle && isActive(value)) {\n          deactivateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function () {\n        if (self.$options.allowMultiple) {\n          return self.$targets.$active;\n        }\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for (var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function () {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            } else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              } else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function () {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function () {\n          if (!attrs.disabled) {\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n            bsCollapseCtrl.$setActive(index * 1);\n            scope.$apply();\n          }\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function ($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if (bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          } else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      toggleEvent: 'click'\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if (constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if (constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if (hasExoticValues) {\n          controller.$parsers.push(function (viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function (modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function (newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if (!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if (!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function (child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function (v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function ($window, $sce, $aside) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAside) {\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function () {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function ($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom';\n        var setWidth = false;\n        var initialAffixTop = 0;\n        var initialOffsetTop = 0;\n        var offsetTop = 0;\n        var offsetBottom = 0;\n        var affixed = null;\n        var unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          } else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function () {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function () {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function () {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function () {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if (affixed === affix) return;\n          affixed = affix;\n\n          if (affix === 'top') {\n            unpin = null;\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if (affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            } else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if (setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function () {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function () {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles) {\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if (options.offsetTop) {\n            if (options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if (options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              } else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            } else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if (options.offsetBottom) {\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            } else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles) {\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(_unpin, position, elementHeight) {\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if (scrollTop <= offsetTop) {\n            return 'top';\n          } else if (_unpin !== null && (scrollTop + _unpin <= position.top)) {\n            return 'middle';\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          }\n          return 'middle';\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function ($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function (key) {\n          if (angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function () {\n          if (affix) affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function () {\n    return {\n      controller: function ($element) {\n        this.$element = $element;\n      }\n    };\n  });\n","\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n"],"sourceRoot":"/source/"}