{"version":3,"sources":["angular-strap.js","typeahead/typeahead.js","helpers/compiler.js","modal/modal.js","tooltip/tooltip.js","timepicker/timepicker.js","tab/tab.js","select/select.js","popover/popover.js","scrollspy/scrollspy.js","navbar/navbar.js","helpers/raf.js","helpers/parse-options.js","helpers/focus-out.js","helpers/focus-element.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","datepicker/datepicker.js","dropdown/dropdown.js","collapse/collapse.js","button/button.js","aside/aside.js","alert/alert.js","affix/affix.js","module.js"],"names":["prefixEvent","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","module","$http","get","defaults","animation","backdropAnimation","this","compile","controller","console","controllerAs","resolve","locals","bindToController","angular","forEach","value","isString","$injector","key","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","data","apply","bsCompilerService","$inject","trigger","provider","container","keyboard","delay","minLength","filter","limit","autoSelect","comparator","trimValue","translations","feedbackId","selectedProperty","KEY_CODES","downArrow","enter","escape","upArrow","tab","TypeaheadFactory","$typeahead","id","$resetMatches","config","setAriaActiveDescendant","index","resultId","$generateResultId","attr","$$phase","$root","$activeIndex","$tooltip","$activate","$scope","$$postDigest","activate","$matches","select","$select","evt","$isActive","matches","safeDigest","update","$$rAF","$setViewValue","parentScope","$digest","onSelect","$render","$emit","length","isDefined","isFunction","$viewValue","$getIndex","$onMouseDown","preventDefault","stopPropagation","equals","clientTop","active","offsetTop","clientBottom","highWatermark","scrollTop","Math","lowWatermark","clientHeight","keyCode","$isVisible","getElementById","ele","currentTarget","isUndefined","label","$$updateScrollTop","focus","show","$element","assertDiv","$timeout","on","append","$onKeyDown","ariaLabelledby","hide","off","onKeyUp","which","$isShown","onFocusKeyUp","$onFocusKeyUp","fromJson","text","selectResultText","array","$filter","expression","directive","results","postLink","restrict","require","setFeedbackMessage","message","document","falseValueRegExp","bsKey","charAt","toUpperCase","slice","test","bsOptions","parsedOptions","$parseOptions","typeahead","watchedOptions","$match","$watchCollection","values","watchOptions","$watch","ngModel","newValue","oldValue","$modelValue","valuesFn","selectMode","substring","displayValue","$formatters","push","modelValue","selected","toString","selectionStart","val","selectionEnd","setSelectionRange","ss","sd","$on","destroy","target","placement","titleTemplate","title","type","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","promise","$bsCompiler","split","clearTimeout","hoverState","onShow","leaveAnimateCallback","destroyTipElement","onHide","_tipToHide","triggers","isTouch","unbindTriggerEvents","i","leave","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","elRect","getBoundingClientRect","rect","p","width","height","top","left","dimensions","offset","el","scroll","outerDims","isBody","documentElement","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","timeout","tipScope","$destroy","$options","$promise","$new","$rootScope","$id","map","parseFloat","$sce","trustAsHtml","$setEnabled","$hide","setEnabled","isEnabled","toggle","compileData","tipContainer","init","bindTriggerEvents","isElement","onBeforeShow","after","parent","lastChild","display","visibility","clonedElement","addClass","prefixClass","version","prepend","$applyPlacement","$animate","enterAnimateCallback","_blur","onBeforeHide","blur","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","query","querySelectorAll","isNative","tooltip","transclusion","$eval","dataTarget","hasOwnProperty","$observe","bsTooltip","bsShow","match","setViewport","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","maxTime","Infinity","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","$timepicker","timepickerFactory","formatDate","format","viewDate","hour","startDate","getHours","meridian","coeff","selRange","end","start","collapse","moveStart","moveEnd","focusElement","_init","floorMinutes","time","floor","lang","selectedIndex","date","defaultDate","second","getSeconds","millisecond","getMilliseconds","$dateValue","hoursFormat","$dateFormatter","timeSeparator","minute","minutesFormat","secondsFormat","showSeconds","$iconUp","$moveIndex","$switchMeridian","switchMeridian","isDate","getMinutes","getTime","$build","$isBuilt","keep","Date","setHours","setMinutes","setSeconds","copy","midIndex","hours","disabled","minutes","$date","seconds","rows","$isDisabled","showAM","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","targetDate","nodeName","targetEl","triggerHandler","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","$window","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","setFullYear","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","timepicker","dateParser","$dateParser","validateAgainstMinMaxTime","timezoneOffsetAdjust","NaN","parse","_tabsHash","_addTabControl","navClass","activeClass","$attrs","control","self","newIndex","navigatePane","toLeft","$setActive","$panes","name","$activePaneChangeListeners","pane","$navClass","$activeClass","$onClick","tabPane","$labeledBy","$active","activeIndex","$remove","indexOf","splice","fn","$pane","$onKeyPress","e","charCode","$tab","transclude","ngModelCtrl","bsTabsCtrl","tabKey","addTabControl","controllers","liElements","find","iElement","parsedBsActivePane","attrs","bsActivePane","assign","$parse","render","$push","$describedBy","elem","focusOn","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$selectNone","$updateActiveIndex","a","b","$apply","isArray","anchor","anchorCandidate","$selectScrollFix","$isIE","stopImmediatePropagation","ua","activeElement","tagName","dataMultiple","inputEl","addEventListener","join","$isEmpty","content","$popover","PopoverFactory","requestAnimationFrame","bsPopover","popover","spies","$document","windowEl","debounce","bodyEl","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","sortedElements","activeTarget","debouncedCheckOffsets","viewportHeight","debouncedCheckPosition","throttledCheckPosition","checkPositionWithEventLoop","checkOffsets","checkPosition","docEl","$activateElement","setTimeout","source","$getTrackedElement","targetElement","querySelector","trackedElement","trackElement","toDelete","untrackElement","scrollspy","childEl","child","routeAttr","$navbar","li","liElement","pattern","path","RegExp","regexp","minor","dot","cancelAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","raf","timer","cancel","supported","$values","valueName","keyName","displayFn","valueFn","ParseOptionsFactory","groupByFn","callback","$event","ngFocusOut","ngEventHandler","$","animate","factory","offsetParent","docElement","ownerDocument","outer","window","getComputedStyle","extra","currentStyle","boxRect","style","curPosition","curLeft","curCSSTop","curTop","calculatePosition","curElem","curCSSLeft","curOffset","call","offsetParentRect","offsetParentEl","offsetParentElement","func","immediate","args","context","callNow","leading","wait","trailing","year","$localeProvider","milliseconds","ParseDate","prototype","noop","toLowerCase","indexOfCaseInsensitive","len","str","strict","day","month","getFullYear","getMonth","proto","isNumeric","toDate","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","dateRegexParts","escapeReservedSymbols","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","DateParserFactory","setMap","m","HH","H","hh","h","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","s","setDate","setMonth","regex","$format","regExpForFormat","baseDate","formatRegex","formatSetMap","fromDate","getDate","substr","today","getTimeForAttribute","daylightSavingAdjust","undo","getTimezoneOffset","getDefaultLocale","getDatetimeFormat","weekdaysShort","splitTimeFormat","weekdays","service","backdrop","size","zIndex","containerElement","bodyElement","layoutHideElement","backdropCount","backdropBaseZindex","ModalFactory","modalElement","hasClass","$modal","findFocusableElements","focusableElements","focusable","findNextFocusableElement","inReverse","reverse","unbindBackdropEvents","hideOnBackdropClick","backdropElement","preventEventDefault","modalScope","dialogBaseZindex","returnFocus","$show","bottom","destroyModalElement","z-index","defaultPrevented","customClass","validSizes","bindBackdropEvents","nextFocusable","shiftKey","lg","sm","modalClass","bsModal","modal","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","hasToday","hasClear","iconLeft","iconRight","screenReaderDateFormat","focusOnOpen","DatepickerFactory","$datepicker","pickerViews","datepickerViews","altKey","setMode","$mode","focused","$views","views","$iconLeft","$iconRight","$hasToday","dropdownId","$nextLabel","labelNext","$previousLabel","$picker","handleOnKeyDown","$toggleMode","$setToday","$clear","$focused","selectedDayId","dayInfo","isNext","continueHandling","onKeyDown","inTable","relatedTarget","$onFocusOut","updateDisabledDates","disabledDateRanges","dateRanges","$setDisabledEl","mode","pristine","built","$updateSelected","updateSelected","build","isSelected","steps","getUTCFullYear","getUTCMonth","$selectPane","UTC","getUTCDate","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","arrays","mod","n","arr","weekDaysMin","weekDaysShortLabels","weekDaysLongLabels","weekDaysLabelsHtml","weekDayLabel","concat","picker","firstDayOfMonth","firstDayOfMonthOffset","firstDate","firstDateOffset","days","selectedDay","todayDay","dayItem","isToday","screenReaderLabel","muted","defaultFirstDayTabIndex","showLabels","labels","isTodayDisabled","hasSelectedDate","$modeLabel","isDisabled","getDay","actualTime","months","selectedMonth","monthItem","thisMonthDate","thisMonth","lastDate","actualMonth","firstYear","years","selectedYear","yearItem","thisYear","startYear","endYear","$modelLabel","actualYear","setYear","Array","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","eq","click","inMenu","parentEl","webkitMatchesSelector","Element","mozMatchesSelector","msMatchesSelector","oMatchesSelector","tAttrs","nextSibling","nodeType","parentNode","removeChild","dropdown","startCollapsed","allowMultiple","activeIndexes","$targets","deactivateItem","activateItem","$toggles","$collapse","$viewChangeListeners","$registerToggle","$registerTarget","$unregisterToggle","fixActiveItemIndexes","disallowToggle","isActive","$activeIndexes","bsCollapseCtrl","ENTER","SPACE","actionEventHandler","bsCollapseToggle","log","action","$unregisterTarget","toggleEvent","$button","constantValueRegExp","isInput","trueValue","falseValue","hasExoticValues","checked","toggleClass","bind","v","AsideFactory","$aside","bsAside","aside","duration","dismissable","focusMeDisabled","$alert","containerEl","AlertFactory","toArray","bsAlert","alert","AffixFactory","inlineStyles","$affix","setWidth","reset","initialOffsetTop","getRequiredAffixClass","_unpin","getScrollTop","scrollHeight","getScrollHeight","pageYOffset","offsetBottom","elementHeight","initialAffixTop","affixed","unpin","$parseOffsets","affix","offsetUnpin","$onResize","initialTop","$debouncedOnResize","initialPosition","affixTarget","option"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\r\n'use strict';\r\n\r\n// Source: typeahead\\typeahead.js\r\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$typeahead', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'typeahead',\r\n      prefixEvent: '$typeahead',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'typeahead/typeahead.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      minLength: 1,\r\n      filter: 'bsAsyncFilter',\r\n      limit: 6,\r\n      autoSelect: false,\r\n      comparator: '',\r\n      trimValue: true,\r\n      translations: null,\r\n      feedbackId: '',\r\n      selectedProperty: ''\r\n    };\r\n\r\n    var KEY_CODES = {\r\n      downArrow: 40,\r\n      enter: 13,\r\n      escape: 27,\r\n      upArrow: 38,\r\n      tab: 9\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\r\n\r\n      function TypeaheadFactory (element, controller, config) {\r\n\r\n        var $typeahead = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $typeahead = $tooltip(element, options);\r\n\r\n        var parentScope = config.scope;\r\n        var scope = $typeahead.$scope;\r\n        scope.id = options.id;\r\n\r\n        scope.$resetMatches = function () {\r\n          scope.$matches = [];\r\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\r\n        };\r\n        scope.$resetMatches();\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $typeahead.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function isActive (index) {\r\n          return scope.$activeIndex === index ? true : undefined;\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $typeahead.update = function (matches) {\r\n          scope.$matches = matches;\r\n          if (scope.$activeIndex >= matches.length) {\r\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\r\n          }\r\n\r\n          // wrap in a $timeout so the results are updated\r\n          // before repositioning\r\n          safeDigest(scope);\r\n          $$rAF($typeahead.$applyPlacement);\r\n        };\r\n\r\n        $typeahead.activate = function (index) {\r\n          scope.$activeIndex = index;\r\n        };\r\n\r\n        $typeahead.select = function (index) {\r\n          if (index === -1) return;\r\n          var value = scope.$matches[index].value;\r\n          if (typeof value === 'object' && options.selectedProperty !== void 0 && options.selectedProperty.length > 0) {\r\n            controller.$setViewValue(value[options.selectedProperty]);\r\n          } else {\r\n            controller.$setViewValue(value);\r\n          }\r\n          // console.log('$setViewValue', value);\r\n          controller.$render();\r\n          scope.$resetMatches();\r\n          if (parentScope) parentScope.$digest();\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $typeahead);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $typeahead.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return !!scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        scope.$generateResultId = function (index) {\r\n          return scope.id ? scope.id + '_typeahead_result_' + index : undefined;\r\n        };\r\n\r\n        $typeahead.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $typeahead.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        };\r\n\r\n        $typeahead.$$updateScrollTop = function (container, index) {\r\n          if (index > -1 && index < container.children.length) {\r\n            var active = container.children[index];\r\n            var clientTop = active.offsetTop;\r\n            var clientBottom = active.offsetTop + active.clientHeight;\r\n            var highWatermark = container.scrollTop;\r\n            var lowWatermark = container.scrollTop + container.clientHeight;\r\n\r\n            // active entry overlaps top border\r\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\r\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\r\n            } else if (clientBottom > lowWatermark) {\r\n              // top of active element is invisible because it's below the bottom of the visible container window\r\n              container.scrollTop = clientTop;\r\n            }\r\n          }\r\n        };\r\n\r\n        $typeahead.$onKeyDown = function (evt) {\r\n          // If the key code isn't up arrow, down arrow, or enter return.\r\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\r\n\r\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\r\n          if ($typeahead.$isVisible() && !(evt.keyCode === KEY_CODES.enter && scope.$activeIndex === -1)) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // Select with enter\r\n          if (evt.keyCode === KEY_CODES.enter && scope.$matches.length) {\r\n            $typeahead.select(scope.$activeIndex);\r\n            // Navigate with keyboard\r\n          } else if (evt.keyCode === KEY_CODES.upArrow && scope.$activeIndex > 0) {\r\n            scope.$activeIndex--;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if (evt.keyCode === KEY_CODES.downArrow && scope.$activeIndex < scope.$matches.length - 1) {\r\n            scope.$activeIndex++;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if ((evt.keyCode === KEY_CODES.upArrow && scope.$activeIndex === 0) || (evt.keyCode === KEY_CODES.downArrow && scope.$activeIndex === scope.$matches.length - 1)) {\r\n            scope.$activeIndex = -1;\r\n            var ele = '#' + evt.currentTarget.id;\r\n            // position the cursor after the last letter of the selected item inside the control to allow the user to easily delete the selection if desired\r\n            angular.element(ele).val('').val(controller.$viewValue);\r\n            angular.element(ele).focus();\r\n          } else if (angular.isUndefined(scope.$activeIndex)) {\r\n            scope.$activeIndex = 0;\r\n            setAriaActiveDescendant();\r\n          }\r\n\r\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\r\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\r\n          scope.$digest();\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $typeahead.show;\r\n        $typeahead.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed immediately.\r\n          $timeout(function () {\r\n            if ($typeahead.$element) {\r\n              if (options.id) {\r\n                // Set the id on the \"dropdown\" component of the typeahead. The input should \"control\" this element.\r\n                $typeahead.$element.attr('id', options.id + '_listbox');\r\n                element.attr('aria-controls', options.id + '_listbox');\r\n\r\n                var assertDiv = document.getElementById(options.id + '_sr_text');\r\n                if (!assertDiv) {\r\n                  $typeahead.$element.parent().append('<div id=\"' + options.id + '_sr_text\" aria-live=\"assertive\" style=\"position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0;\"></div>');\r\n                }\r\n              }\r\n\r\n              // If the input was given an aria-labelledby attribute apply it to the \"dropdown\" component.\r\n              $typeahead.$element.attr('aria-labelledby', options.ariaLabelledby);\r\n\r\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\r\n              if (options.keyboard) {\r\n                // event for the element that we attach is added to event queue\r\n                // before pushing the same event more that once for the same element, event need to detach\r\n                // list item jumps happening in search list for this setted keydown off\r\n                if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var hide = $typeahead.hide;\r\n        $typeahead.hide = function () {\r\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n          }\r\n          if (!options.autoSelect) {\r\n            $typeahead.activate(-1);\r\n          }\r\n\r\n          var assertDiv = document.getElementById(options.id + '_sr_text');\r\n          angular.element(assertDiv).remove();\r\n\r\n          setAriaActiveDescendant();\r\n\r\n          hide();\r\n        };\r\n\r\n        var onKeyUp = $typeahead.$onKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape && $typeahead.$isShown) {\r\n            $typeahead.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        var onFocusKeyUp = $typeahead.$onFocusKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape) {\r\n            // Feedback message handling as per SS-25684 and SS-11481\r\n            if (options.feedbackId !== void 0 && options.translations !== void 0) {\r\n              var translations = angular.fromJson(options.translations);\r\n              var element = document.getElementById(options.feedbackId);\r\n              if ($typeahead.$scope.$matches !== void 0 && $typeahead.$scope.$matches.length > 0) {\r\n                angular.element(element).text(translations.selectResultText);\r\n              }\r\n              // $typeahead.hide();\r\n              // evt.stopPropagation();\r\n            }\r\n          }\r\n        };\r\n\r\n        // Helper functions within this closure\r\n\r\n        function setAriaActiveDescendant (index) {\r\n          if (index === undefined || !scope.id) {\r\n            element.removeAttr('aria-activedescendant');\r\n          } else {\r\n            var resultId = scope.$generateResultId(index);\r\n            if (resultId) {\r\n              element.attr('aria-activedescendant', resultId);\r\n            } else {\r\n              element.removeAttr('aria-activedescendant');\r\n            }\r\n          }\r\n        }\r\n\r\n        return $typeahead;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      TypeaheadFactory.defaults = defaults;\r\n      return TypeaheadFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .filter('bsAsyncFilter', function ($filter) {\r\n    return function (array, expression, comparator) {\r\n      if (array && angular.isFunction(array.then)) {\r\n        return array.then(function (results) {\r\n          return $filter('filter')(results, expression, comparator);\r\n        });\r\n      }\r\n      return $filter('filter')(array, expression, comparator);\r\n    };\r\n  })\r\n\r\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\r\n\r\n    var defaults = $typeahead.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Fixes firefox bug when using objects in model with typeahead\r\n        // Yes this breaks any other directive using a 'change' event on this input,\r\n        // but if it is using the 'change' event why is it used with typeahead?\r\n        element.off('change');\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass', 'ariaLabelledby', 'translations', 'feedbackId', 'selectedProperty'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Disable browser autocompletion\r\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\r\n\r\n        // Build proper bsOptions\r\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\r\n        var limit = options.limit || defaults.limit;\r\n        var comparator = options.comparator || defaults.comparator;\r\n\r\n        var bsOptions = attr.bsOptions;\r\n        if (filter) {\r\n          bsOptions += ' | ' + filter + ':$viewValue';\r\n          if (comparator) bsOptions += ':' + comparator;\r\n        }\r\n        if (limit) bsOptions += ' | limitTo:' + limit;\r\n        var parsedOptions = $parseOptions(bsOptions);\r\n\r\n        // Initialize typeahead\r\n        var typeahead = $typeahead(element, controller, options);\r\n\r\n        if (!element.attr('aria-autocomplete') && !bsOptions.templateUrl) {\r\n          // Per draft spec for a combobox element the aria-auto complete should be set to a list.\r\n          element.attr('aria-autocomplete', 'list');\r\n        }\r\n\r\n        // Watch options on demand\r\n        if (options.watchOptions) {\r\n          // Watch bsOptions values before filtering for changes, drop function calls\r\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\r\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\r\n              typeahead.update(values);\r\n              controller.$render();\r\n            });\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('$watch', element.attr('ng-model'), newValue);\r\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\r\n          parsedOptions.valuesFn(scope, controller)\r\n            .then(function (values) {\r\n              // Prevent input with no future prospect if selectMode is truthy\r\n              // @TODO test selectMode\r\n              if (options.selectMode && !values.length && newValue.length > 0) {\r\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\r\n                return;\r\n              }\r\n              if (values.length > limit) values = values.slice(0, limit);\r\n              typeahead.update(values);\r\n              // Queue a new rendering that will leverage collection loading\r\n              controller.$render();\r\n            });\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var displayValue = parsedOptions.displayValue(modelValue);\r\n\r\n          // If we can determine the displayValue, use that\r\n          if (displayValue) {\r\n            return displayValue;\r\n          }\r\n\r\n          // If there's no display value, attempt to use the modelValue.\r\n          // If the model is an object not much we can do\r\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\r\n            return modelValue;\r\n          }\r\n          return '';\r\n        });\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          if (controller.$isEmpty(controller.$viewValue)) {\r\n            // Feedback message handling as per SS-25684 and SS-11481\r\n            setFeedbackMessage('');\r\n            return element.val('');\r\n          }\r\n          var index = typeahead.$getIndex(controller.$modelValue);\r\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\r\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\r\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\r\n          var ss = element[0].selectionStart;\r\n          var sd = element[0].selectionEnd;\r\n          element.val(options.trimValue === false ? value : value.trim());\r\n          element[0].setSelectionRange(ss, sd);\r\n\r\n          // Feedback message handling as per SS-25684 and SS-11481\r\n          if (options.translations !== void 0) {\r\n            // Clear feedback element contents\r\n            setFeedbackMessage('');\r\n\r\n            if (typeahead.$scope.$matches !== void 0) {\r\n              var translations = angular.fromJson(options.translations);\r\n              if (typeahead.$scope.$matches.length > 0) {\r\n                setFeedbackMessage(typeahead.$scope.$matches.length + ' ' + translations.resultsText);\r\n              } else {\r\n                setFeedbackMessage(translations.noResultsText);\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        // Feedback message handling as per SS-25684 and SS-11481\r\n        element.on('keydown', function (evt) {\r\n          if (evt.which === 9) {\r\n            evt.preventDefault();\r\n            if (options.translations !== void 0) {\r\n              var translations = angular.fromJson(options.translations);\r\n              if (typeahead.$scope.$matches.length > 0) {\r\n                setFeedbackMessage(translations.selectResultText);\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          element.off('keydown');\r\n          if (typeahead) typeahead.destroy();\r\n          options = null;\r\n          typeahead = null;\r\n        });\r\n\r\n        function setFeedbackMessage (message) {\r\n          if (options.feedbackId !== void 0) {\r\n            var element = document.getElementById(options.feedbackId);\r\n            angular.element(element).text(message);\r\n          }\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: tooltip\\tooltip.js\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      titleTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      mouseDownPreventDefault: true,\r\n      mouseDownStopPropagation: true,\r\n      viewport: {\r\n        selector: 'body',\r\n        padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory (element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        // var nodeName = element[0].nodeName.toLowerCase();\r\n        if (options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if (options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function (isEnabled) {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout;\r\n        var hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData;\r\n        var tipElement;\r\n        var tipContainer;\r\n        var tipScope;\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function () {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if (options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if (angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if (options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if (options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              if (options.trigger === 'focus') {\r\n                element[0].focus();\r\n              } else {\r\n                $tooltip.show();\r\n              }\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function () {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function () {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($tooltip);\r\n          }\r\n          var parent;\r\n          var after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if (tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if (options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if (options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          if (after) {\r\n            after.after(tipElement);\r\n          } else {\r\n            parent.prepend(tipElement);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if (tipElement) tipElement.css({visibility: 'visible'});\r\n\r\n            // Bind events\r\n            if (options.keyboard) {\r\n              if (options.trigger !== 'focus') {\r\n                $tooltip.focus();\r\n              }\r\n              bindKeyboardEvents();\r\n            }\r\n          });\r\n\r\n          if (options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($tooltip);\r\n          }\r\n        }\r\n\r\n        $tooltip.leave = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function (blur) {\r\n\r\n          if (!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($tooltip);\r\n          }\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          if (tipElement !== null) {\r\n            // Support v1.2+ $animate\r\n            // https://github.com/angular/angular.js/issues/11713\r\n            if (angular.version.minor <= 2) {\r\n              $animate.leave(tipElement, leaveAnimateCallback);\r\n            } else {\r\n              $animate.leave(tipElement).then(leaveAnimateCallback);\r\n            }\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if (options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($tooltip);\r\n          }\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if (_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function (evt) {\r\n          if (evt) { evt.preventDefault(); }\r\n          if ($tooltip.$isShown) {\r\n            $tooltip.leave();\r\n          } else {\r\n            $tooltip.enter();\r\n          }\r\n        };\r\n\r\n        $tooltip.focus = function () {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function (isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function (viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function () {\r\n          if (!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement;\r\n          var autoToken = /\\s?auto?\\s?/i;\r\n          var autoPlace = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition();\r\n          var tipWidth = tipElement.prop('offsetWidth');\r\n          var tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\r\n              placement = placement.replace('left', 'right');\r\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\r\n              placement = placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function (evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function (evt) {\r\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\r\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          if ($tooltip.$isShown) {\r\n            element[0].blur();\r\n          } else {\r\n            element[0].focus();\r\n          }\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents () {\r\n\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function (trigger) {\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.on(trigger, $tooltip.toggle);\r\n              // element.on('blur', $tooltip.leave);\r\n            } else if (trigger !== 'manual') {\r\n              // Only bind up hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              } else if (trigger === 'focus') { // but do bind focus events for touch\r\n                element.on('focus', $tooltip.enter);\r\n                element.on('blur', $tooltip.leave);\r\n              }\r\n\r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.off(trigger, $tooltip.toggle);\r\n            } else if (trigger !== 'manual') {\r\n              // Remove previously defined hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              } else if (trigger === 'focus') { // Remove previously defined focus events\r\n                element.off('focus', $tooltip.enter);\r\n                element.off('blur', $tooltip.leave);\r\n              }\r\n\r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents () {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents () {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation (event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition ($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n          var isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          /* eslint-disable guard-for-in */\r\n          for (var p in elRect) { // eslint-disable-line\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n          /* eslint-enable guard-for-in */\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\r\n          }\r\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\r\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\r\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n            case 'right':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left + position.width\r\n              };\r\n              break;\r\n            case 'bottom':\r\n              offset = {\r\n                top: position.top + position.height,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n            case 'left':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left - actualWidth\r\n              };\r\n              break;\r\n            default:\r\n              offset = {\r\n                top: position.top - actualHeight,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n          }\r\n\r\n          if (!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if (split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n              case 'left':\r\n                offset.left = position.left;\r\n                break;\r\n              case 'right':\r\n                offset.left = position.left + position.width - actualWidth;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          } else if (split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n              case 'top':\r\n                offset.top = position.top - actualHeight + position.height;\r\n                break;\r\n              case 'bottom':\r\n                offset.top = position.top;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement (offset, placement) {\r\n          var tip = tipElement[0];\r\n          var width = tip.offsetWidth;\r\n          var height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\r\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth;\r\n          var actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement);\r\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\r\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow (delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement () {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if ($tooltip.$isShown && tipElement !== null) {\r\n            if (options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if (options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if (tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if (tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        var tooltip;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function (newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        attr.$observe('disabled', function (newValue) {\r\n          if (newValue && tooltip.$isShown) {\r\n            tooltip.hide();\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsTooltip) {\r\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.title = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n            if (newValue === true) {\r\n              tooltip.show();\r\n            } else {\r\n              tooltip.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n            if (newValue === false) {\r\n              tooltip.setEnabled(false);\r\n            } else {\r\n              tooltip.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            tooltip.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: timepicker\\timepicker.js\r\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$timepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      defaultDate: 'auto',\r\n      // uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'timepicker',\r\n      prefixClass: 'timepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'timepicker/timepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: true,\r\n      timeType: 'date',\r\n      timeFormat: 'shortTime',\r\n      timezone: null,\r\n      modelTimeFormat: null,\r\n      autoclose: false,\r\n      minTime: -Infinity,\r\n      maxTime: +Infinity,\r\n      length: 5,\r\n      hourStep: 1,\r\n      minuteStep: 5,\r\n      secondStep: 5,\r\n      roundDisplay: false,\r\n      iconUp: 'glyphicon glyphicon-chevron-up',\r\n      iconDown: 'glyphicon glyphicon-chevron-down',\r\n      arrowBehavior: 'pager'\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) {\r\n        defaults.lang = $dateFormatter.getDefaultLocale();\r\n      }\r\n\r\n      function timepickerFactory (element, controller, config) {\r\n\r\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $timepicker.$options;\r\n        var scope = $timepicker.$scope;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        function floorMinutes (time) {\r\n          // coeff used to floor current time to nearest minuteStep interval\r\n          var coeff = 1000 * 60 * options.minuteStep;\r\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\r\n        }\r\n\r\n        // View vars\r\n\r\n        var selectedIndex = 0;\r\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\r\n        var startDate = controller.$dateValue || defaultDate;\r\n        var viewDate = {\r\n          hour: startDate.getHours(),\r\n          meridian: startDate.getHours() < 12,\r\n          minute: startDate.getMinutes(),\r\n          second: startDate.getSeconds(),\r\n          millisecond: startDate.getMilliseconds()\r\n        };\r\n\r\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\r\n\r\n        var hoursFormat = $dateFormatter.hoursFormat(format);\r\n        var timeSeparator = $dateFormatter.timeSeparator(format);\r\n        var minutesFormat = $dateFormatter.minutesFormat(format);\r\n        var secondsFormat = $dateFormatter.secondsFormat(format);\r\n        var showSeconds = $dateFormatter.showSeconds(format);\r\n        var showAM = $dateFormatter.showAM(format);\r\n\r\n        scope.$iconUp = options.iconUp;\r\n        scope.$iconDown = options.iconDown;\r\n\r\n        // Scope methods\r\n\r\n        scope.$select = function (date, index) {\r\n          $timepicker.select(date, index);\r\n        };\r\n        scope.$moveIndex = function (value, index) {\r\n          $timepicker.$moveIndex(value, index);\r\n        };\r\n        scope.$switchMeridian = function (date) {\r\n          $timepicker.switchMeridian(date);\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $timepicker.update = function (date) {\r\n          // console.warn('$timepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $timepicker.$date = date;\r\n            angular.extend(viewDate, {\r\n              hour: date.getHours(),\r\n              minute: date.getMinutes(),\r\n              second: date.getSeconds(),\r\n              millisecond: date.getMilliseconds()\r\n            });\r\n            $timepicker.$build();\r\n          } else if (!$timepicker.$isBuilt) {\r\n            $timepicker.$build();\r\n          }\r\n        };\r\n\r\n        $timepicker.select = function (date, index, keep) {\r\n          // console.warn('$timepicker.select', date, scope.$mode);\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\r\n          }\r\n\r\n          if (!angular.isDate(date)) date = new Date(date);\r\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\r\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\r\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n          if (options.autoclose && !keep) {\r\n            $timeout(function () {\r\n              $timepicker.hide(true);\r\n            });\r\n          }\r\n        };\r\n\r\n        $timepicker.switchMeridian = function (date) {\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            return;\r\n          }\r\n          var hours = (date || controller.$dateValue).getHours();\r\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $timepicker.$build = function () {\r\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\r\n          var i;\r\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\r\n          var hours = [];\r\n          var hour;\r\n          for (i = 0; i < options.length; i++) {\r\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\r\n            hours.push({\r\n              date: hour,\r\n              label: formatDate(hour, hoursFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\r\n              disabled: $timepicker.$isDisabled(hour, 0)\r\n            });\r\n          }\r\n          var minutes = [];\r\n          var minute;\r\n          for (i = 0; i < options.length; i++) {\r\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\r\n            minutes.push({\r\n              date: minute,\r\n              label: formatDate(minute, minutesFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\r\n              disabled: $timepicker.$isDisabled(minute, 1)\r\n            });\r\n          }\r\n          var seconds = [];\r\n          var second;\r\n          for (i = 0; i < options.length; i++) {\r\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\r\n            seconds.push({\r\n              date: second,\r\n              label: formatDate(second, secondsFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\r\n              disabled: $timepicker.$isDisabled(second, 2)\r\n            });\r\n          }\r\n\r\n          var rows = [];\r\n          for (i = 0; i < options.length; i++) {\r\n            if (showSeconds) {\r\n              rows.push([hours[i], minutes[i], seconds[i]]);\r\n            } else {\r\n              rows.push([hours[i], minutes[i]]);\r\n            }\r\n          }\r\n          scope.rows = rows;\r\n          scope.showSeconds = showSeconds;\r\n          scope.showAM = showAM;\r\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\r\n          scope.timeSeparator = timeSeparator;\r\n          $timepicker.$isBuilt = true;\r\n        };\r\n\r\n        $timepicker.$isSelected = function (date, index) {\r\n          if (!$timepicker.$date) return false;\r\n          else if (index === 0) {\r\n            return date.getHours() === $timepicker.$date.getHours();\r\n          } else if (index === 1) {\r\n            return date.getMinutes() === $timepicker.$date.getMinutes();\r\n          } else if (index === 2) {\r\n            return date.getSeconds() === $timepicker.$date.getSeconds();\r\n          }\r\n        };\r\n\r\n        $timepicker.$isDisabled = function (date, index) {\r\n          var selectedTime;\r\n          if (index === 0) {\r\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\r\n          } else if (index === 1) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\r\n          } else if (index === 2) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\r\n          }\r\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\r\n        };\r\n\r\n        scope.$arrowAction = function (value, index) {\r\n          if (options.arrowBehavior === 'picker') {\r\n            $timepicker.$setTimeByStep(value, index);\r\n          } else {\r\n            $timepicker.$moveIndex(value, index);\r\n          }\r\n        };\r\n\r\n        $timepicker.$setTimeByStep = function (value, index) {\r\n          var newDate = new Date($timepicker.$date || startDate);\r\n          var hours = newDate.getHours();\r\n          var minutes = newDate.getMinutes();\r\n          var seconds = newDate.getSeconds();\r\n          if (index === 0) {\r\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\r\n          } else if (index === 1) {\r\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\r\n          } else if (index === 2) {\r\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\r\n          }\r\n          $timepicker.select(newDate, index, true);\r\n        };\r\n\r\n        $timepicker.$moveIndex = function (value, index) {\r\n          var targetDate;\r\n          if (index === 0) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\r\n            angular.extend(viewDate, {\r\n              hour: targetDate.getHours()\r\n            });\r\n          } else if (index === 1) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\r\n            angular.extend(viewDate, {\r\n              minute: targetDate.getMinutes()\r\n            });\r\n          } else if (index === 2) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\r\n            angular.extend(viewDate, {\r\n              second: targetDate.getSeconds()\r\n            });\r\n          }\r\n          $timepicker.$build();\r\n        };\r\n\r\n        $timepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        $timepicker.$onKeyDown = function (evt) {\r\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Close on enter\r\n          if (evt.keyCode === 13) {\r\n            $timepicker.hide(true);\r\n            return;\r\n          }\r\n\r\n          // Navigate with keyboard\r\n          var newDate = new Date($timepicker.$date);\r\n          var hours = newDate.getHours();\r\n          var hoursLength = formatDate(newDate, hoursFormat).length;\r\n          var minutes = newDate.getMinutes();\r\n          var minutesLength = formatDate(newDate, minutesFormat).length;\r\n          var seconds = newDate.getSeconds();\r\n          var secondsLength = formatDate(newDate, secondsFormat).length;\r\n          var sepLength = 1;\r\n          var lateralMove = /(37|39)/.test(evt.keyCode);\r\n          var count = 2 + showSeconds * 1 + showAM * 1;\r\n\r\n          // Navigate indexes (left, right)\r\n          if (lateralMove) {\r\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\r\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\r\n          }\r\n\r\n          // Update values (up, down)\r\n          var selectRange = [0, hoursLength];\r\n          var incr = 0;\r\n          if (evt.keyCode === 38) incr = -1;\r\n          if (evt.keyCode === 40) incr = +1;\r\n          var isSeconds = selectedIndex === 2 && showSeconds;\r\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\r\n          if (selectedIndex === 0) {\r\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\r\n            // re-calculate hours length because we have changed hours value\r\n            hoursLength = formatDate(newDate, hoursFormat).length;\r\n            selectRange = [0, hoursLength];\r\n          } else if (selectedIndex === 1) {\r\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\r\n            // re-calculate minutes length because we have changes minutes value\r\n            minutesLength = formatDate(newDate, minutesFormat).length;\r\n            selectRange = [hoursLength + sepLength, minutesLength];\r\n          } else if (isSeconds) {\r\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\r\n            // re-calculate seconds length because we have changes seconds value\r\n            secondsLength = formatDate(newDate, secondsFormat).length;\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\r\n          } else if (isMeridian) {\r\n            if (!lateralMove) $timepicker.switchMeridian();\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\r\n          }\r\n          $timepicker.select(newDate, selectedIndex, true);\r\n          createSelection(selectRange[0], selectRange[1]);\r\n          parentScope.$digest();\r\n        };\r\n\r\n        // Private\r\n\r\n        function createSelection (start, length) {\r\n          var end = start + length;\r\n          if (element[0].createTextRange) {\r\n            var selRange = element[0].createTextRange();\r\n            selRange.collapse(true);\r\n            selRange.moveStart('character', start);\r\n            selRange.moveEnd('character', end);\r\n            selRange.select();\r\n          } else if (element[0].setSelectionRange) {\r\n            element[0].setSelectionRange(start, end);\r\n          } else if (angular.isUndefined(element[0].selectionStart)) {\r\n            element[0].selectionStart = start;\r\n            element[0].selectionEnd = end;\r\n          }\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        var _init = $timepicker.init;\r\n        $timepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'time');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        var _destroy = $timepicker.destroy;\r\n        $timepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        var _show = $timepicker.show;\r\n        $timepicker.show = function () {\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n          _show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n            if (options.keyboard) {\r\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $timepicker.hide;\r\n        $timepicker.hide = function (blur) {\r\n          if (!$timepicker.$isShown) return;\r\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\r\n          }\r\n          _hide(blur);\r\n        };\r\n\r\n        return $timepicker;\r\n\r\n      }\r\n\r\n      timepickerFactory.defaults = defaults;\r\n      return timepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\r\n\r\n    var defaults = $timepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize timepicker\r\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\r\n        var timepicker = $timepicker(element, controller, options);\r\n        options = timepicker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!timepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\r\n            if (newValue === true) {\r\n              timepicker.show();\r\n            } else {\r\n              timepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Initialize parser\r\n        var dateParser = $dateParser({\r\n          format: options.timeFormat,\r\n          lang: lang\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minTime', 'maxTime'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\r\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\r\n              validateAgainstMinMaxTime(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\r\n          timepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        function validateAgainstMinMaxTime (parsedTime) {\r\n          if (!angular.isDate(parsedTime)) return;\r\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\r\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (!isValid) {\r\n            return;\r\n          }\r\n          controller.$dateValue = parsedTime;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            controller.$setValidity('date', true);\r\n            return null;\r\n          }\r\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // Return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return undefined;\r\n          }\r\n          validateAgainstMinMaxTime(parsedTime);\r\n\r\n          if (options.timeType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\r\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.timeType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.timeType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.timeType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.timeType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\r\n          } else if (options.timeType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getTimeFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getTimeFormattedString());\r\n        };\r\n\r\n        function getTimeFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (timepicker) timepicker.destroy();\r\n          options = null;\r\n          timepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: tab\\tab.js\r\nangular.module('mgcrea.ngStrap.tab', [])\r\n\r\n  .provider('$tab', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      template: 'tab/tab.tpl.html',\r\n      navClass: 'nav-tabs',\r\n      activeClass: 'active',\r\n      isVertical: false\r\n    };\r\n    var _tabsHash = {};\r\n\r\n    var _addTabControl = function (key, control) {\r\n      if (!_tabsHash[key]) _tabsHash[key] = control;\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs, $timeout) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'navClass', 'activeClass', 'id', 'isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) self.$options[key] = false;\r\n      });\r\n\r\n      // Publish options on scope\r\n      $scope.$navClass = self.$options.navClass;\r\n      $scope.$activeClass = self.$options.activeClass;\r\n\r\n      $scope.$onClick = function $onClick (evt, pane, index) {\r\n        if (!pane.disabled) {\r\n          self.$setActive(pane.name || index);\r\n        }\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      };\r\n\r\n      function navigatePane (index, toLeft) {\r\n        var newIndex = 0;\r\n\r\n        if (toLeft) {\r\n          // Moving to the left\r\n          newIndex = index - 1 < 0 ? (self.$panes.length - 1) : (index - 1);\r\n        } else {\r\n          // Moving to the right\r\n          newIndex = (index + 1) >= self.$panes.length ? 0 : (index + 1);\r\n        }\r\n\r\n        if (self.$panes[newIndex].disabled) {\r\n          navigatePane(newIndex, toLeft);\r\n        } else {\r\n          self.$setActive(self.$panes[newIndex].name || newIndex);\r\n        }\r\n      }\r\n\r\n      self.$panes = $scope.$panes = [];\r\n\r\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\r\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\r\n      // activePaneChangeListeners to make more sense.\r\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\r\n\r\n      self.$push = function (pane) {\r\n        if (angular.isUndefined(self.$panes.$active)) {\r\n          $scope.$setActive(pane.name || 0);\r\n        }\r\n\r\n        self.$panes.push(pane);\r\n\r\n        self.$panes.forEach(function (tabPane, index) {\r\n          // Set an id value for the pane so that it can be used in the template\r\n          tabPane.$describedBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index;\r\n          tabPane.$labeledBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index + '_a';\r\n        });\r\n      };\r\n\r\n      self.$remove = function (pane) {\r\n        var index = self.$panes.indexOf(pane);\r\n        var active = self.$panes.$active;\r\n        var activeIndex;\r\n        if (angular.isString(active)) {\r\n          activeIndex = self.$panes.map(function (pane) {\r\n            return pane.name;\r\n          }).indexOf(active);\r\n        } else {\r\n          activeIndex = self.$panes.$active;\r\n        }\r\n\r\n        // remove pane from $panes array\r\n        self.$panes.splice(index, 1);\r\n\r\n        if (index < activeIndex) {\r\n          // we removed a pane before the active pane, so we need to\r\n          // decrement the active pane index\r\n          activeIndex--;\r\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\r\n          // we remove the active pane and it was the one at the end,\r\n          // so select the previous one\r\n          activeIndex--;\r\n        }\r\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\r\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\r\n        } else {\r\n          self.$setActive();\r\n        }\r\n      };\r\n\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        self.$panes.$active = value;\r\n        self.$activePaneChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\r\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\r\n      };\r\n\r\n      self.$onKeyPress = $scope.$onKeyPress = function (e, name, index) {\r\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\r\n          // If space or enter was pressed\r\n          self.$setActive(name);\r\n\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n\r\n        } else if (!self.$options.isVertical && (e.keyCode === 37 || e.charCode === 37 || e.keyCode === 39 || e.charCode === 39)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 37 || e.charCode === 37));\r\n        } else if (self.$options.isVertical && (e.keyCode === 38 || e.charCode === 38 || e.keyCode === 40 || e.charCode === 40)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 38 || e.charCode === 38));\r\n        }\r\n      };\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $tab = {};\r\n      $tab.defaults = defaults;\r\n      $tab.controller = controller;\r\n      $tab.addTabControl = _addTabControl;\r\n      $tab.tabsHash = _tabsHash;\r\n      return $tab;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTabs', function ($window, $animate, $tab, $parse, $timeout) {\r\n\r\n    var defaults = $tab.defaults;\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsTabs'],\r\n      transclude: true,\r\n      scope: true,\r\n      controller: ['$scope', '$element', '$attrs', '$timeout', $tab.controller],\r\n      templateUrl: function (element, attr) {\r\n        return attr.template || defaults.template;\r\n      },\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\r\n        // tabs are available in the tab component\r\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\r\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\r\n        }\r\n\r\n        // 'ngModel' does interfere with form validation\r\n        // and status, use `bsActivePane` instead to avoid it\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            bsTabsCtrl.$setActive(modelValue);\r\n            return modelValue;\r\n          });\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          $timeout(function () {\r\n            // get li elements\r\n            var liElements = element.find('li');\r\n            for (var i = 0; i < liElements.length; i++) {\r\n              var iElement = angular.element(liElements[i]);\r\n              iElement.removeAttr('tabindex');\r\n\r\n              // As per SS-44480\r\n              // if (iElement.hasClass(bsTabsCtrl.$options.activeClass)) {\r\n                // if li is active, set focus to it.\r\n                // iElement.find('a')[0].focus();\r\n              // }\r\n            }\r\n            // delay, for the class (.active) change to reflect in DOM.\r\n          }, 100);\r\n        });\r\n\r\n        if (attrs.bsActivePane) {\r\n          // adapted from angularjs ngModelController bindings\r\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\r\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\r\n\r\n          // Update bsActivePane value with change\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // watch bsActivePane for value changes\r\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\r\n            bsTabsCtrl.$setActive(newValue);\r\n          }, true);\r\n        }\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPane', function ($window, $animate, $sce) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsTabs'],\r\n      scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('tab-pane');\r\n\r\n        // Set up the assistive attributes\r\n        element.attr('role', 'tabpanel');\r\n\r\n        // Observe title attribute for change\r\n        attrs.$observe('title', function (newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n        });\r\n\r\n        // Save tab name into scope\r\n        scope.name = attrs.name;\r\n        // Save tab id into scope\r\n        scope.id = attrs.id;\r\n\r\n        scope.name = scope.name || scope.id;\r\n\r\n        // Add animation class\r\n        if (bsTabsCtrl.$options.animation) {\r\n          element.addClass(bsTabsCtrl.$options.animation);\r\n        }\r\n\r\n        attrs.$observe('disabled', function (newValue, oldValue) {\r\n          scope.disabled = scope.$eval(newValue);\r\n        });\r\n\r\n        // Push pane to parent bsTabs controller\r\n        bsTabsCtrl.$push(scope);\r\n\r\n        // Once the push has occured when can then update the element with some properties.\r\n        // Update the aria-labelledby attribute\r\n\t\t// SS-11127 - removed aria-describedby from tab and tab-panel and utilized aria-labeledby on the tab-panel using the ID of the tab and not the ID of the tab link\r\n        if (scope.$describedBy !== undefined) {\r\n          element.attr('aria-labelledby', scope.$describedBy);\r\n        }\r\n\r\n        // remove pane from tab controller when pane is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsTabsCtrl.$remove(scope);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsTabsCtrl.$panes.indexOf(scope);\r\n\r\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('focusOn', function () {\r\n    return {\r\n      restrict: 'A',\r\n      link: function (scope, elem, attr) {\r\n        scope.$watch(attr.focusOn, function (newValue, oldValue) {\r\n          if (newValue !== oldValue && newValue) {\r\n            elem[0].children[0].focus();\r\n          }\r\n        });\r\n      }\r\n    };\r\n  });\r\n\r\n// Source: select\\select.js\r\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$select', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'select',\r\n      prefixEvent: '$select',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'select/select.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      multiple: false,\r\n      allNoneButtons: false,\r\n      sort: true,\r\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\r\n      placeholder: 'Choose among the following...',\r\n      allText: 'All',\r\n      noneText: 'None',\r\n      maxLength: 3,\r\n      maxLengthHtml: 'selected',\r\n      iconCheckmark: 'glyphicon glyphicon-ok',\r\n      toggle: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\r\n\r\n      // var bodyEl = angular.element($window.document.body);\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n\r\n      function SelectFactory (element, controller, config) {\r\n\r\n        var $select = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $select = $tooltip(element, options);\r\n        var scope = $select.$scope;\r\n\r\n        scope.$matches = [];\r\n        if (options.multiple) {\r\n          scope.$activeIndex = [];\r\n        } else {\r\n          scope.$activeIndex = -1;\r\n        }\r\n        scope.$isMultiple = options.multiple;\r\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\r\n        scope.$iconCheckmark = options.iconCheckmark;\r\n        scope.$allText = options.allText;\r\n        scope.$noneText = options.noneText;\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $select.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $select.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $select.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function (index) {\r\n          return $select.$isActive(index);\r\n        };\r\n\r\n        scope.$selectAll = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (!scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        scope.$selectNone = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $select.update = function (matches) {\r\n          scope.$matches = matches;\r\n          $select.$updateActiveIndex();\r\n        };\r\n\r\n        $select.activate = function (index) {\r\n          if (options.multiple) {\r\n            if ($select.$isActive(index)) {\r\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\r\n            } else {\r\n              scope.$activeIndex.push(index);\r\n            }\r\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\r\n          } else {\r\n            scope.$activeIndex = index;\r\n          }\r\n          return scope.$activeIndex;\r\n        };\r\n\r\n        $select.select = function (index) {\r\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\r\n          var value = scope.$matches[index].value;\r\n          scope.$apply(function () {\r\n            $select.activate(index);\r\n            if (options.multiple) {\r\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\r\n                if (angular.isUndefined(scope.$matches[index])) {\r\n                  return null;\r\n                }\r\n                return scope.$matches[index].value;\r\n              }));\r\n            } else {\r\n              if (options.toggle) {\r\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\r\n              } else {\r\n                controller.$setViewValue(value);\r\n              }\r\n              // Hide if single select\r\n              $select.hide();\r\n            }\r\n          });\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $select);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $select.$updateActiveIndex = function () {\r\n          if (options.multiple) {\r\n            if (angular.isArray(controller.$modelValue)) {\r\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\r\n                return $select.$getIndex(value);\r\n              });\r\n            } else {\r\n              scope.$activeIndex = [];\r\n            }\r\n          } else {\r\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\r\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\r\n            } else {\r\n              scope.$activeIndex = -1;\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $select.$isActive = function (index) {\r\n          if (options.multiple) {\r\n            return scope.$activeIndex.indexOf(index) !== -1;\r\n          }\r\n          return scope.$activeIndex === index;\r\n        };\r\n\r\n        $select.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $select.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            var anchor;\r\n\r\n            if (evt.target.nodeName !== 'A') {\r\n              var anchorCandidate = targetEl.parent();\r\n              while (!anchor && anchorCandidate.length > 0) {\r\n                if (anchorCandidate[0].nodeName === 'A') {\r\n                  anchor = anchorCandidate;\r\n                }\r\n                anchorCandidate = anchorCandidate.parent();\r\n              }\r\n            }\r\n\r\n            if (anchor) {\r\n              angular.element(anchor).triggerHandler('click');\r\n            } else {\r\n              targetEl.triggerHandler('click');\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$onKeyDown = function (evt) {\r\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\r\n          // Let tab propagate\r\n          if (evt.keyCode !== 9) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // release focus on tab\r\n          if (options.multiple && evt.keyCode === 9) {\r\n            return $select.hide();\r\n          }\r\n\r\n          // Select with enter\r\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\r\n            return $select.select(scope.$activeIndex);\r\n          }\r\n\r\n          if (!options.multiple) {\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\r\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\r\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\r\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\r\n            scope.$digest();\r\n          }\r\n        };\r\n\r\n        $select.$isIE = function () {\r\n          var ua = $window.navigator.userAgent;\r\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\r\n        };\r\n\r\n        $select.$selectScrollFix = function (e) {\r\n          if ($document[0].activeElement.tagName === 'UL') {\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n            e.target.focus();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var _show = $select.show;\r\n        $select.show = function () {\r\n          _show();\r\n          if (options.multiple) {\r\n            $select.$element.addClass('select-multiple');\r\n          }\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n            if (options.keyboard) {\r\n              element.on('keydown', $select.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $select.hide;\r\n        $select.hide = function () {\r\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\r\n            scope.$activeIndex = -1;\r\n          }\r\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n          if (options.keyboard) {\r\n            element.off('keydown', $select.$onKeyDown);\r\n          }\r\n          _hide(true);\r\n        };\r\n\r\n        return $select;\r\n\r\n      }\r\n\r\n      SelectFactory.defaults = defaults;\r\n      return SelectFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\r\n\r\n    var defaults = $select.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, placeholder: defaults.placeholder};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\r\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\r\n        var dataMultiple = element.attr('data-multiple');\r\n        if (angular.isDefined(dataMultiple)) {\r\n          if (falseValueRegExp.test(dataMultiple)) {\r\n            options.multiple = false;\r\n          } else {\r\n            options.multiple = dataMultiple;\r\n          }\r\n        }\r\n\r\n        // Add support for select markup\r\n        if (element[0].nodeName.toLowerCase() === 'select') {\r\n          var inputEl = element;\r\n          inputEl.css('display', 'none');\r\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\r\n          inputEl.after(element);\r\n        }\r\n\r\n        // Build proper bsOptions\r\n        var parsedOptions = $parseOptions(attr.bsOptions);\r\n\r\n        // Initialize select\r\n        var select = $select(element, controller, options);\r\n\r\n        if (select.$isIE()) {\r\n          element[0].addEventListener('blur', select.$selectScrollFix);\r\n        }\r\n\r\n        // Watch bsOptions values before filtering for changes\r\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\r\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n          parsedOptions.valuesFn(scope, controller)\r\n          .then(function (values) {\r\n            select.update(values);\r\n            controller.$render();\r\n          });\r\n        }, true);\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\r\n          select.$updateActiveIndex();\r\n          controller.$render();\r\n        }, true);\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var selected;\r\n          var index;\r\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\r\n            selected = controller.$modelValue.map(function (value) {\r\n              index = select.$getIndex(value);\r\n              return index !== -1 ? select.$scope.$matches[index].label : false;\r\n            }).filter(angular.isDefined);\r\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\r\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\r\n            } else {\r\n              selected = selected.join(', ');\r\n            }\r\n          } else {\r\n            index = select.$getIndex(controller.$modelValue);\r\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\r\n          }\r\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\r\n        };\r\n\r\n        if (options.multiple) {\r\n          controller.$isEmpty = function (value) {\r\n            return !value || value.length === 0;\r\n          };\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (select) select.destroy();\r\n          options = null;\r\n          select = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: popover\\popover.js\r\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$popover', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      // uncommenting the next two lines will break backwards compatability\r\n      // prefixClass: 'popover',\r\n      // prefixEvent: 'popover',\r\n      container: false,\r\n      target: false,\r\n      placement: 'right',\r\n      templateUrl: 'popover/popover.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'click',\r\n      keyboard: true,\r\n      html: false,\r\n      title: '',\r\n      content: '',\r\n      delay: 0,\r\n      autoClose: false\r\n    };\r\n\r\n    this.$get = function ($tooltip) {\r\n\r\n      function PopoverFactory (element, config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        var $popover = $tooltip(element, options);\r\n\r\n        // Support scope as string options [/*title, */content]\r\n        if (options.content) {\r\n          $popover.$scope.content = options.content;\r\n        }\r\n\r\n        return $popover;\r\n\r\n      }\r\n\r\n      return PopoverFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPopover', function ($window, $sce, $popover) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var popover;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n              if (angular.isDefined(oldValue)) {\r\n                requestAnimationFrame(function () {\r\n                  if (popover) popover.$applyPlacement();\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsPopover) {\r\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              requestAnimationFrame(function () {\r\n                if (popover) popover.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\r\n            if (newValue === true) {\r\n              popover.show();\r\n            } else {\r\n              popover.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\r\n            if (newValue === false) {\r\n              popover.setEnabled(false);\r\n            } else {\r\n              popover.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            popover.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        popover = $popover(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (popover) popover.destroy();\r\n          options = null;\r\n          popover = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: scrollspy\\scrollspy.js\r\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$scrollspy', function () {\r\n\r\n    // Pool of registered spies\r\n    var spies = this.$$spies = {};\r\n\r\n    var defaults = this.defaults = {\r\n      debounce: 150,\r\n      throttle: 100,\r\n      offset: 100\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\r\n\r\n      var windowEl = angular.element($window);\r\n      var docEl = angular.element($document.prop('documentElement'));\r\n      var bodyEl = angular.element($window.document.body);\r\n\r\n      // Helper functions\r\n\r\n      function nodeName (element, name) {\r\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\r\n      }\r\n\r\n      function ScrollSpyFactory (config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        if (!options.element) options.element = bodyEl;\r\n        var isWindowSpy = nodeName(options.element, 'body');\r\n        var scrollEl = isWindowSpy ? windowEl : options.element;\r\n        var scrollId = isWindowSpy ? 'window' : options.id;\r\n\r\n        // Use existing spy\r\n        if (spies[scrollId]) {\r\n          spies[scrollId].$$count++;\r\n          return spies[scrollId];\r\n        }\r\n\r\n        var $scrollspy = {};\r\n\r\n        // Private vars\r\n        var unbindViewContentLoaded;\r\n        var unbindIncludeContentLoaded;\r\n        var trackedElements = $scrollspy.$trackedElements = [];\r\n        var sortedElements = [];\r\n        var activeTarget;\r\n        var debouncedCheckPosition;\r\n        var throttledCheckPosition;\r\n        var debouncedCheckOffsets;\r\n        /* eslint-disable no-unused-vars */\r\n        var viewportHeight;\r\n        /* eslint-enable no-unused-vars */\r\n        var scrollTop;\r\n\r\n        $scrollspy.init = function () {\r\n\r\n          // Setup internal ref counter\r\n          this.$$count = 1;\r\n\r\n          // Bind events\r\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\r\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\r\n          scrollEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', debouncedCheckPosition);\r\n          scrollEl.on('scroll', throttledCheckPosition);\r\n\r\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\r\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\r\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\r\n          debouncedCheckOffsets();\r\n\r\n          // Register spy for reuse\r\n          if (scrollId) {\r\n            spies[scrollId] = $scrollspy;\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.destroy = function () {\r\n\r\n          // Check internal ref counter\r\n          this.$$count--;\r\n          if (this.$$count > 0) {\r\n            return;\r\n          }\r\n\r\n          // Unbind events\r\n          scrollEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', debouncedCheckPosition);\r\n          scrollEl.off('scroll', throttledCheckPosition);\r\n          unbindViewContentLoaded();\r\n          unbindIncludeContentLoaded();\r\n          if (scrollId) {\r\n            delete spies[scrollId];\r\n          }\r\n        };\r\n\r\n        $scrollspy.checkPosition = function () {\r\n\r\n          // Not ready yet\r\n          if (!sortedElements.length) return;\r\n\r\n          // Calculate the scroll position\r\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\r\n\r\n          // Calculate the viewport height for use by the components\r\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\r\n\r\n          // Activate first element if scroll is smaller\r\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\r\n            return $scrollspy.$activateElement(sortedElements[0]);\r\n          }\r\n\r\n          // Activate proper element\r\n          for (var i = sortedElements.length; i--;) {\r\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\r\n            if (activeTarget === sortedElements[i].target) continue;\r\n            if (scrollTop < sortedElements[i].offsetTop) continue;\r\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\r\n            return $scrollspy.$activateElement(sortedElements[i]);\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.checkPositionWithEventLoop = function () {\r\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\r\n          // in this setTimeout call\r\n          setTimeout($scrollspy.checkPosition, 1);\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $scrollspy.$activateElement = function (element) {\r\n          if (activeTarget) {\r\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\r\n            if (activeElement) {\r\n              activeElement.source.removeClass('active');\r\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\r\n                activeElement.source.parent().parent().removeClass('active');\r\n              }\r\n            }\r\n          }\r\n          activeTarget = element.target;\r\n          element.source.addClass('active');\r\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\r\n            element.source.parent().parent().addClass('active');\r\n          }\r\n        };\r\n\r\n        $scrollspy.$getTrackedElement = function (target) {\r\n          return trackedElements.filter(function (obj) {\r\n            return obj.target === target;\r\n          })[0];\r\n        };\r\n\r\n        // Track offsets behavior\r\n\r\n        $scrollspy.checkOffsets = function () {\r\n\r\n          angular.forEach(trackedElements, function (trackedElement) {\r\n            var targetElement = document.querySelector(trackedElement.target);\r\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\r\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\r\n          });\r\n\r\n          sortedElements = trackedElements\r\n          .filter(function (el) {\r\n            return el.offsetTop !== null;\r\n          })\r\n          .sort(function (a, b) {\r\n            return a.offsetTop - b.offsetTop;\r\n          });\r\n\r\n          debouncedCheckPosition();\r\n\r\n        };\r\n\r\n        $scrollspy.trackElement = function (target, source) {\r\n          trackedElements.push({target: target, source: source});\r\n        };\r\n\r\n        $scrollspy.untrackElement = function (target, source) {\r\n          var toDelete;\r\n          for (var i = trackedElements.length; i--;) {\r\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\r\n              toDelete = i;\r\n              break;\r\n            }\r\n          }\r\n          trackedElements.splice(toDelete, 1);\r\n        };\r\n\r\n        $scrollspy.activate = function (i) {\r\n          trackedElements[i].addClass('active');\r\n        };\r\n\r\n        // Initialize plugin\r\n\r\n        $scrollspy.init();\r\n        return $scrollspy;\r\n\r\n      }\r\n\r\n      return ScrollSpyFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var options = {scope: scope};\r\n        angular.forEach(['offset', 'target'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        var scrollspy = $scrollspy(options);\r\n        scrollspy.trackElement(options.target, element);\r\n\r\n        scope.$on('$destroy', function () {\r\n          if (scrollspy) {\r\n            scrollspy.untrackElement(options.target, element);\r\n            scrollspy.destroy();\r\n          }\r\n          options = null;\r\n          scrollspy = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      compile: function postLink (element, attr) {\r\n        var children = element[0].querySelectorAll('li > a[href]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: navbar\\navbar.js\r\nangular.module('mgcrea.ngStrap.navbar', [])\r\n\r\n  .provider('$navbar', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      routeAttr: 'data-match-route',\r\n      strict: false\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsNavbar', function ($window, $location, $navbar) {\r\n\r\n    var defaults = $navbar.defaults;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = angular.copy(defaults);\r\n        angular.forEach(Object.keys(defaults), function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Watch for the $location\r\n        scope.$watch(function () {\r\n\r\n          return $location.path();\r\n\r\n        }, function (newValue, oldValue) {\r\n\r\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\r\n\r\n          angular.forEach(liElements, function (li) {\r\n\r\n            var liElement = angular.element(li);\r\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\r\n            if (options.strict) {\r\n              pattern = '^' + pattern + '$';\r\n            }\r\n            var regexp = new RegExp(pattern, 'i');\r\n\r\n            if (regexp.test(newValue)) {\r\n              liElement.addClass(options.activeClass);\r\n            } else {\r\n              liElement.removeClass(options.activeClass);\r\n            }\r\n\r\n          });\r\n\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\raf.js\r\nif (angular.version.minor < 3 && angular.version.dot < 14) {\r\n  angular.module('ng')\r\n\r\n  .factory('$$rAF', function ($window, $timeout) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame ||\r\n                                $window.webkitRequestAnimationFrame ||\r\n                                $window.mozRequestAnimationFrame;\r\n\r\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\r\n                               $window.webkitCancelAnimationFrame ||\r\n                               $window.mozCancelAnimationFrame ||\r\n                               $window.webkitCancelRequestAnimationFrame;\r\n\r\n    var rafSupported = !!requestAnimationFrame;\r\n    var raf = rafSupported ?\r\n      function (fn) {\r\n        var id = requestAnimationFrame(fn);\r\n        return function () {\r\n          cancelAnimationFrame(id);\r\n        };\r\n      } :\r\n      function (fn) {\r\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\r\n        return function () {\r\n          $timeout.cancel(timer);\r\n        };\r\n      };\r\n\r\n    raf.supported = rafSupported;\r\n\r\n    return raf;\r\n\r\n  });\r\n}\r\n\r\n// Source: helpers\\parse-options.js\r\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\r\n\r\n  .provider('$parseOptions', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\r\n    };\r\n\r\n    this.$get = function ($parse, $q) {\r\n\r\n      function ParseOptionsFactory (attr, config) {\r\n\r\n        var $parseOptions = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        $parseOptions.$values = [];\r\n\r\n        // Private vars\r\n        var match;\r\n        var displayFn;\r\n        var valueName;\r\n        /* eslint-disable no-unused-vars */\r\n        var keyName;\r\n        var groupByFn;\r\n        /* eslint-enable no-unused-vars */\r\n        var valueFn;\r\n        var valuesFn;\r\n\r\n        $parseOptions.init = function () {\r\n          $parseOptions.$match = match = attr.match(options.regexp);\r\n          displayFn = $parse(match[2] || match[1]);\r\n          valueName = match[4] || match[6];\r\n          keyName = match[5];\r\n          groupByFn = $parse(match[3] || '');\r\n          valueFn = $parse(match[2] ? match[1] : valueName);\r\n          valuesFn = $parse(match[7]);\r\n        };\r\n\r\n        $parseOptions.valuesFn = function (scope, controller) {\r\n          return $q.when(valuesFn(scope, controller))\r\n          .then(function (values) {\r\n            if (!angular.isArray(values)) {\r\n              values = [];\r\n            }\r\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\r\n            return $parseOptions.$values;\r\n          });\r\n        };\r\n\r\n        $parseOptions.displayValue = function (modelValue) {\r\n          var scope = {};\r\n          scope[valueName] = modelValue;\r\n          return displayFn(scope);\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function parseValues (values, scope) {\r\n          return values.map(function (match, index) {\r\n            var locals = {};\r\n            var label;\r\n            var value;\r\n            locals[valueName] = match;\r\n            label = displayFn(scope, locals);\r\n            value = valueFn(scope, locals);\r\n            return {label: label, value: value, index: index};\r\n          });\r\n        }\r\n\r\n        $parseOptions.init();\r\n        return $parseOptions;\r\n\r\n      }\r\n\r\n      return ParseOptionsFactory;\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\focus-out.js\r\nangular.module('mgcrea.ngStrap.helpers.ngFocusOut', [])\r\n  .directive('ngFocusOut', ['$parse', '$rootScope', function ($parse, $rootScope) {\r\n    return {\r\n      restrict: 'A',\r\n      compile: function ($element, attr) {\r\n        // NOTE:\r\n        // We expose the powerful `$event` object on the scope that provides access to the Window,\r\n        // etc. This is OK, because expressions are not sandboxed any more (and the expression\r\n        // sandbox was never meant to be a security feature anyway).\r\n        var fn = $parse(attr.ngFocusOut);\r\n\r\n        return function link (scope, element) {\r\n          function ngEventHandler (event) {\r\n            var callback = function () {\r\n              fn(scope, {\r\n                $event: event\r\n              });\r\n            };\r\n            if ($rootScope.$$phase) {\r\n              scope.$evalAsync(callback);\r\n            } else {\r\n              scope.$apply(callback);\r\n            }\r\n          }\r\n\r\n          // setup the handler\r\n          element.on('focusout', ngEventHandler);\r\n\r\n          scope.$on('$destroy', function () {\r\n            // tear down the handler\r\n            element.off('focusout', ngEventHandler);\r\n          });\r\n        };\r\n      }\r\n    };\r\n  }]);\r\n\r\n// Source: helpers\\focus-element.js\r\nangular.module('mgcrea.ngStrap.helpers.focusElement', [])\r\n  .directive('focusElement', ['$timeout', '$parse', function ($timeout, $parse) {\r\n    return {\r\n      link: function (scope, element, attrs) {\r\n        scope.$watch(attrs.focusElement, function (value) {\r\n          if (value === true) {\r\n            $timeout(function(){\r\n              $(element[0]).animate(\r\n                {left:0}, \r\n                100, \r\n                function(){\r\n                  element[0].focus();\r\n                }\r\n              );\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n\r\n// Source: helpers\\dimensions.js\r\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\r\n\r\n  .factory('dimensions', function () {\r\n\r\n    var fn = {};\r\n\r\n    /**\r\n     * Test the element nodeName\r\n     * @param element\r\n     * @param name\r\n     */\r\n    var nodeName = fn.nodeName = function (element, name) {\r\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\r\n    };\r\n\r\n    /**\r\n     * Returns the element computed style\r\n     * @param element\r\n     * @param prop\r\n     * @param extra\r\n     */\r\n    fn.css = function (element, prop, extra) {\r\n      var value;\r\n      if (element.currentStyle) { // IE\r\n        value = element.currentStyle[prop];\r\n      } else if (window.getComputedStyle) {\r\n        value = window.getComputedStyle(element)[prop];\r\n      } else {\r\n        value = element.style[prop];\r\n      }\r\n      return extra === true ? parseFloat(value) || 0 : value;\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.offset = function (element) {\r\n      var boxRect = element.getBoundingClientRect();\r\n      var docElement = element.ownerDocument;\r\n      return {\r\n        width: boxRect.width || element.offsetWidth,\r\n        height: boxRect.height || element.offsetHeight,\r\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\r\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Provides set equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     * @param options\r\n     * @param i\r\n     */\r\n    fn.setOffset = function (element, options, i) {\r\n      var curPosition;\r\n      var curLeft;\r\n      var curCSSTop;\r\n      var curTop;\r\n      var curOffset;\r\n      var curCSSLeft;\r\n      var calculatePosition;\r\n      var position = fn.css(element, 'position');\r\n      var curElem = angular.element(element);\r\n      var props = {};\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        element.style.position = 'relative';\r\n      }\r\n\r\n      curOffset = fn.offset(element);\r\n      curCSSTop = fn.css(element, 'top');\r\n      curCSSLeft = fn.css(element, 'left');\r\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\r\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = fn.position(element);\r\n        curTop = curPosition.top;\r\n        curLeft = curPosition.left;\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0;\r\n        curLeft = parseFloat(curCSSLeft) || 0;\r\n      }\r\n\r\n      if (angular.isFunction(options)) {\r\n        options = options.call(element, i, curOffset);\r\n      }\r\n\r\n      if (options.top !== null) {\r\n        props.top = (options.top - curOffset.top) + curTop;\r\n      }\r\n      if (options.left !== null) {\r\n        props.left = (options.left - curOffset.left) + curLeft;\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(curElem, props);\r\n      } else {\r\n        curElem.css({\r\n          top: props.top + 'px',\r\n          left: props.left + 'px'\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's position function\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.position = function (element) {\r\n\r\n      var offsetParentRect = {top: 0, left: 0};\r\n      var offsetParentEl;\r\n      var offset;\r\n\r\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n      if (fn.css(element, 'position') === 'fixed') {\r\n\r\n        // We assume that getBoundingClientRect is available when computed position is fixed\r\n        offset = element.getBoundingClientRect();\r\n\r\n      } else {\r\n\r\n        // Get *real* offsetParentEl\r\n        offsetParentEl = offsetParentElement(element);\r\n\r\n        // Get correct offsets\r\n        offset = fn.offset(element);\r\n        if (!nodeName(offsetParentEl, 'html')) {\r\n          offsetParentRect = fn.offset(offsetParentEl);\r\n        }\r\n\r\n        // Add offsetParent borders\r\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\r\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        width: element.offsetWidth,\r\n        height: element.offsetHeight,\r\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\r\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\r\n      };\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns the closest, non-statically positioned offsetParent of a given element\r\n     * @required-by fn.position\r\n     * @param element\r\n     */\r\n    function offsetParentElement (element) {\r\n      var docElement = element.ownerDocument;\r\n      var offsetParent = element.offsetParent || docElement;\r\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\r\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\r\n        offsetParent = offsetParent.offsetParent;\r\n      }\r\n      return offsetParent || docElement.documentElement;\r\n    }\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's height function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/height/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.height = function (element, outer) {\r\n      var value = element.offsetHeight;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's width function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/width/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.width = function (element, outer) {\r\n      var value = element.offsetWidth;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    return fn;\r\n\r\n  });\r\n\r\n// Source: helpers\\debounce.js\r\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\r\n.factory('debounce', function ($timeout) {\r\n  return function (func, wait, immediate) {\r\n    var timeout = null;\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      var callNow = immediate && !timeout;\r\n      if (timeout) {\r\n        $timeout.cancel(timeout);\r\n      }\r\n      timeout = $timeout(function later () {\r\n        timeout = null;\r\n        if (!immediate) {\r\n          func.apply(context, args);\r\n        }\r\n      }, wait, false);\r\n      if (callNow) {\r\n        func.apply(context, args);\r\n      }\r\n      return timeout;\r\n    };\r\n  };\r\n})\r\n\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\r\n.factory('throttle', function ($timeout) {\r\n  return function (func, wait, options) {\r\n    var timeout = null;\r\n    if (!options) options = {};\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      if (!timeout) {\r\n        if (options.leading !== false) {\r\n          func.apply(context, args);\r\n        }\r\n        timeout = $timeout(function later () {\r\n          timeout = null;\r\n          if (options.trailing !== false) {\r\n            func.apply(context, args);\r\n          }\r\n        }, wait, false);\r\n      }\r\n    };\r\n  };\r\n});\r\n\r\n// Source: helpers\\date-parser.js\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function ($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate () {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function () { return this.hours; };\r\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function (value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function () {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop () {\r\n  }\r\n\r\n  function isNumeric (n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive (array, value) {\r\n    var len = array.length;\r\n    var str = value.toString().toLowerCase();\r\n    for (var i = 0; i < len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function ($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function (config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      /* eslint-disable key-spacing, quote-props */\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\r\n      };\r\n      /* eslint-enable key-spacing, quote-props */\r\n\r\n      var regex;\r\n      var setMap;\r\n\r\n      $dateParser.init = function () {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function (date) {\r\n        if (angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function (value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if (!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for (var i = 0; i < matches.length - 1; i++) {\r\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function (key, value) {\r\n        var date;\r\n\r\n        if (value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          if (value.match(/Z/)) {\r\n            date = new Date(value.substr(1, value.length - 3));\r\n          } else {\r\n            date = new Date(value.substr(1, value.length - 2));\r\n          }\r\n        } else if (isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function (key, value) {\r\n        var time;\r\n\r\n        if (value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if (isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function (date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function regExpForFormat (format) {\r\n        // `format` string can contain literal values.\r\n        // These need to be escaped by surrounding with\r\n        // single quotes (e.g. `\"h 'in the morning'\"`).\r\n        // In order to output a single quote, escape it - i.e.,\r\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\r\n\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseRegex(re);\r\n      }\r\n\r\n      function buildDateAbstractRegex (format) {\r\n        var escapedFormat = escapeReservedSymbols(format);\r\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\r\n        var literalRegex = /('(?:\\\\'|.)*?')/;\r\n        var formatParts = escapedLiteralFormat.split(literalRegex);\r\n        var dateElements = Object.keys(regExpMap);\r\n        var dateRegexParts = [];\r\n\r\n        angular.forEach(formatParts, function (part) {\r\n          if (isFormatStringLiteral(part)) {\r\n            part = trimLiteralEscapeChars(part);\r\n          } else {\r\n            // Abstract replaces to avoid collisions\r\n            for (var i = 0; i < dateElements.length; i++) {\r\n              part = part.split(dateElements[i]).join('${' + i + '}');\r\n            }\r\n          }\r\n          dateRegexParts.push(part);\r\n        });\r\n\r\n        return dateRegexParts.join('');\r\n      }\r\n\r\n      function escapeReservedSymbols (text) {\r\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\r\n                   .replace(/-/g, '[-]')\r\n                   .replace(/\\./g, '[.]')\r\n                   .replace(/\\*/g, '[*]')\r\n                   .replace(/\\+/g, '[+]')\r\n                   .replace(/\\?/g, '[?]')\r\n                   .replace(/\\$/g, '[$]')\r\n                   .replace(/\\^/g, '[^]')\r\n                   .replace(/\\//g, '[/]')\r\n                   .replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function isFormatStringLiteral (text) {\r\n        return /^'.*'$/.test(text);\r\n      }\r\n\r\n      function trimLiteralEscapeChars (text) {\r\n        return text.replace(/^'(.*)'$/, '$1');\r\n      }\r\n\r\n      function buildDateParseRegex (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var re = abstractRegex;\r\n\r\n        // Replace abstracted values\r\n        for (var i = 0; i < dateElements.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\r\n        }\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      function setMapForFormat (format) {\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseValuesMap(re);\r\n      }\r\n\r\n      function buildDateParseValuesMap (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\r\n        var valuesMatch;\r\n        var keyIndex;\r\n        var valueKey;\r\n        var valueFunction;\r\n        var valuesFunctionMap = [];\r\n\r\n        /* eslint-disable no-cond-assign */\r\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\r\n          keyIndex = valuesMatch[1];\r\n          valueKey = dateElements[keyIndex];\r\n          valueFunction = setFnMap[valueKey];\r\n\r\n          valuesFunctionMap.push(valueFunction);\r\n        }\r\n\r\n        return valuesFunctionMap;\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n\r\n// Source: helpers\\date-formatter.js\r\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\r\n\r\n  .service('$dateFormatter', function ($locale, dateFilter) {\r\n\r\n    // The unused `lang` arguments are on purpose. The default implementation does not\r\n    // use them and it always uses the locale loaded into the `$locale` service.\r\n    // Custom implementations might use it, thus allowing different directives to\r\n    // have different languages.\r\n\r\n    this.getDefaultLocale = function () {\r\n      return $locale.id;\r\n    };\r\n\r\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\r\n    // Return either the corresponding date format or the given date format.\r\n    this.getDatetimeFormat = function (format, lang) {\r\n      return $locale.DATETIME_FORMATS[format] || format;\r\n    };\r\n\r\n    this.weekdaysShort = function (lang) {\r\n      return $locale.DATETIME_FORMATS.SHORTDAY;\r\n    };\r\n\r\n    this.weekdays = function (lang) {\r\n      return $locale.DATETIME_FORMATS.DAY;\r\n    };\r\n\r\n    function splitTimeFormat (format) {\r\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\r\n    }\r\n\r\n    // h:mm a => h\r\n    this.hoursFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[0];\r\n    };\r\n\r\n    // h:mm a => mm\r\n    this.minutesFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[2];\r\n    };\r\n\r\n    // h:mm:ss a => ss\r\n    this.secondsFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => :\r\n    this.timeSeparator = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[1];\r\n    };\r\n\r\n    // h:mm:ss a => true, h:mm a => false\r\n    this.showSeconds = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => true, H.mm => false\r\n    this.showAM = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[5];\r\n    };\r\n\r\n    this.formatDate = function (date, format, lang, timezone) {\r\n      return dateFilter(date, format, timezone);\r\n    };\r\n\r\n  });\r\n\r\n// Source: helpers\\compiler.js\r\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\r\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\r\n\r\nangular.module('mgcrea.ngStrap.core', [])\r\n  .service('$bsCompiler', bsCompilerService);\r\n\r\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\r\n\r\n  /*\r\n   * @ngdoc service\r\n   * @name $bsCompiler\r\n   * @module material.core\r\n   * @description\r\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\r\n   * to easily compile an element with a templateUrl, controller, and locals.\r\n   *\r\n   * @usage\r\n   * <hljs lang=\"js\">\r\n   * $bsCompiler.compile({\r\n   *   templateUrl: 'modal.html',\r\n   *   controller: 'ModalCtrl',\r\n   *   locals: {\r\n   *     modal: myModalInstance;\r\n   *   }\r\n   * }).then(function(compileData) {\r\n   *   compileData.element; // modal.html's template in an element\r\n   *   compileData.link(myScope); //attach controller & scope to element\r\n   * });\r\n   * </hljs>\r\n   */\r\n\r\n   /*\r\n    * @ngdoc method\r\n    * @name $bsCompiler#compile\r\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\r\n    * locals, and scope.\r\n    * @param {object} options An options object, with the following properties:\r\n    *\r\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\r\n    *      newly created scope or the name of a registered controller if passed as a string.\r\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\r\n    *      published to scope under the `controllerAs` name.\r\n    *    - `template` - `{string=}` An html template as a string.\r\n    *    - `templateUrl` - `{string=}` A path to an html template.\r\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\r\n    *      it is loaded. It will be given the template string as a parameter, and should\r\n    *      return a a new string representing the transformed template.\r\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\r\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\r\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\r\n    *      instantiated `compile()` will fail..\r\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\r\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\r\n    *        Otherwise if function, then it is injected and the return value is treated as the\r\n    *        dependency. If the result is a promise, it is resolved before its value is\r\n    *        injected into the controller.\r\n    *\r\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\r\n    * `compileData` has the following properties:\r\n    *\r\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\r\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\r\n    *     the element and instantiate the provided controller (if given).\r\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\r\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\r\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\r\n    */\r\n  this.compile = function (options) {\r\n\r\n    if (options.template && /\\.html$/.test(options.template)) {\r\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\r\n      options.templateUrl = options.template;\r\n      options.template = '';\r\n    }\r\n\r\n    var templateUrl = options.templateUrl;\r\n    var template = options.template || '';\r\n    var controller = options.controller;\r\n    var controllerAs = options.controllerAs;\r\n    var resolve = options.resolve || {};\r\n    var locals = options.locals || {};\r\n    var transformTemplate = options.transformTemplate || angular.identity;\r\n    var bindToController = options.bindToController;\r\n\r\n    // Take resolve values and invoke them.\r\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\r\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\r\n    angular.forEach(resolve, function (value, key) {\r\n      if (angular.isString(value)) {\r\n        resolve[key] = $injector.get(value);\r\n      } else {\r\n        resolve[key] = $injector.invoke(value);\r\n      }\r\n    });\r\n    // Add the locals, which are just straight values to inject\r\n    // eg locals: { three: 3 }, will inject three into the controller\r\n    angular.extend(resolve, locals);\r\n\r\n    if (template) {\r\n      resolve.$template = $q.when(template);\r\n    } else if (templateUrl) {\r\n      resolve.$template = fetchTemplate(templateUrl);\r\n    } else {\r\n      throw new Error('Missing `template` / `templateUrl` option.');\r\n    }\r\n\r\n    if (options.titleTemplate) {\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          findElement('[ng-bind=\"title\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    if (options.contentTemplate) {\r\n      // TODO(mgcrea): deprecate?\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\r\n          if (!options.templateUrl) contentEl.next().remove();\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    // Wait for all the resolves to finish if they are promises\r\n    return $q.all(resolve).then(function (locals) {\r\n\r\n      var template = transformTemplate(locals.$template);\r\n      if (options.html) {\r\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\r\n      }\r\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\r\n      var element = angular.element('<div>').html(template.trim()).contents();\r\n      var linkFn = $compile(element);\r\n\r\n      // Return a linking function that can be used later when the element is ready\r\n      return {\r\n        locals: locals,\r\n        element: element,\r\n        link: function link (scope) {\r\n          locals.$scope = scope;\r\n\r\n          // Instantiate controller if it exists, because we have scope\r\n          if (controller) {\r\n            var invokeCtrl = $controller(controller, locals, true);\r\n            if (bindToController) {\r\n              angular.extend(invokeCtrl.instance, locals);\r\n            }\r\n            // Support angular@~1.2 invokeCtrl\r\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\r\n            // See angular-route source for this logic\r\n            element.data('$ngControllerController', ctrl);\r\n            element.children().data('$ngControllerController', ctrl);\r\n\r\n            if (controllerAs) {\r\n              scope[controllerAs] = ctrl;\r\n            }\r\n          }\r\n\r\n          return linkFn.apply(null, arguments);\r\n        }\r\n      };\r\n    });\r\n\r\n  };\r\n\r\n  function findElement (query, element) {\r\n    return angular.element((element || document).querySelectorAll(query));\r\n  }\r\n\r\n  var fetchPromises = {};\r\n  function fetchTemplate (template) {\r\n    if (fetchPromises[template]) return fetchPromises[template];\r\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\r\n      .then(function (res) {\r\n        return res.data;\r\n      }));\r\n  }\r\n\r\n}\r\n\r\n// Source: modal\\modal.js\r\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$modal', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      backdropAnimation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'modal',\r\n      prefixEvent: 'modal',\r\n      placement: 'top',\r\n      templateUrl: 'modal/modal.tpl.html',\r\n      template: '',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true,\r\n      size: null,\r\n      zIndex: null,\r\n      containerElement: null\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\r\n\r\n      var forEach = angular.forEach;\r\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n      var bodyElement = angular.element($window.document.body);\r\n\r\n      var layoutHideElement = angular.element('#layoutContainer');\r\n\r\n      var backdropCount = 0;\r\n      var dialogBaseZindex = 1050;\r\n      var backdropBaseZindex = 1040;\r\n\r\n      var validSizes = {\r\n        lg: 'modal-lg',\r\n        sm: 'modal-sm'\r\n      };\r\n\r\n      function ModalFactory (config) {\r\n\r\n        var $modal = {};\r\n\r\n        // Common vars\r\n        var options = $modal.$options = angular.extend({}, defaults, config);\r\n\r\n        var promise = $modal.$promise = $bsCompiler.compile(options);\r\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        if (options.containerElement) {\r\n          layoutHideElement = angular.element(options.containerElement);\r\n        }\r\n        if (!options.element && !options.container) {\r\n          options.container = 'body';\r\n        }\r\n\r\n        if (options.zIndex) {\r\n          dialogBaseZindex = parseInt(options.zIndex, 10);\r\n          backdropBaseZindex = dialogBaseZindex - 10;\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\r\n\r\n        $modal.returnFocus = function () {\r\n\r\n        };\r\n\r\n        // Support scope as string options\r\n        forEach(['title', 'content'], function (key) {\r\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\r\n        });\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $modal.$isShown = scope.$isShown = false;\r\n\r\n        // Fetch, compile then initialize modal\r\n        var compileData;\r\n        var modalElement;\r\n        var modalScope;\r\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\r\n        backdropElement.css({\r\n          position: 'fixed',\r\n          top: '0px',\r\n          left: '0px',\r\n          bottom: '0px',\r\n          right: '0px'\r\n        });\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $modal.init();\r\n        });\r\n\r\n        $modal.init = function () {\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              $modal.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $modal.destroy = function () {\r\n\r\n          // Remove element\r\n          destroyModalElement();\r\n\r\n          // remove backdrop element\r\n          if (backdropElement) {\r\n            backdropElement.remove();\r\n            backdropElement = null;\r\n          }\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n        };\r\n\r\n        $modal.show = function () {\r\n          if ($modal.$isShown) return;\r\n\r\n          var parent;\r\n          var after;\r\n          if (angular.isElement(options.container)) {\r\n            parent = options.container;\r\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\r\n          } else {\r\n            if (options.container) {\r\n              parent = findElement(options.container);\r\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\r\n            } else {\r\n              parent = null;\r\n              after = options.element;\r\n            }\r\n          }\r\n\r\n          // destroy any existing modal elements\r\n          if (modalElement) destroyModalElement();\r\n\r\n          // create a new scope, so we can destroy it and all child scopes\r\n          // when destroying the modal element\r\n          modalScope = $modal.$scope.$new();\r\n          // Fetch a cloned element linked from template (noop callback is required)\r\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\r\n\r\n          if (options.backdrop) {\r\n            // set z-index\r\n            modalElement.css({\r\n              'z-index': dialogBaseZindex + (backdropCount * 20)\r\n            });\r\n            backdropElement.css({\r\n              'z-index': backdropBaseZindex + (backdropCount * 20)\r\n            });\r\n\r\n            // increment number of backdrops\r\n            backdropCount++;\r\n          }\r\n\r\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($modal);\r\n          }\r\n\r\n          // Set the initial positioning.\r\n          modalElement.css({\r\n            display: 'block'\r\n          }).addClass(options.placement);\r\n\r\n          // Options: customClass\r\n          if (options.customClass) {\r\n            modalElement.addClass(options.customClass);\r\n          }\r\n\r\n          // Options: size\r\n          if (options.size && validSizes[options.size]) {\r\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\r\n          }\r\n\r\n          // Options: animation\r\n          if (options.animation) {\r\n            if (options.backdrop) {\r\n              backdropElement.addClass(options.backdropAnimation);\r\n            }\r\n            modalElement.addClass(options.animation);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            $animate.enter(backdropElement, bodyElement, null);\r\n          }\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n\r\n          $modal.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          // Focus once the enter-animation has started\r\n          // Weird PhantomJS bug hack\r\n          var el = modalElement[0];\r\n          requestAnimationFrame(function () {\r\n            el.focus();\r\n          });\r\n\r\n          bodyElement.addClass(options.prefixClass + '-open');\r\n\r\n          layoutHideElement.attr('aria-hidden', 'true');\r\n\r\n          if (options.animation) {\r\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n\r\n          // Bind events\r\n          bindBackdropEvents();\r\n          bindKeyboardEvents();\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $modal);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'false');\r\n          modalElement.attr('tabindex', '0');\r\n          modalElement.trigger('focus');\r\n          if (!modalElement.length || !angular.element(modalElement[0]).hasClass('modal')) {\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n            unbindKeyboardEvents();\r\n          }\r\n\t\t  if(angular.element(modalElement[0]).hasClass('alert')) {\r\n\t\t\t  modalElement.removeAttr('tabindex');\r\n\t\t  }\r\n        }\r\n\r\n        $modal.hide = function () {\r\n          if (!$modal.$isShown) return;\r\n\r\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'true');\r\n\r\n          if ($modal.returnFocus && typeof $modal.returnFocus === 'function') $modal.returnFocus();\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.leave(modalElement, leaveAnimateCallback);\r\n          } else {\r\n            $animate.leave(modalElement).then(leaveAnimateCallback);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            // decrement number of backdrops\r\n            backdropCount--;\r\n            $animate.leave(backdropElement);\r\n          }\r\n          $modal.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          unbindBackdropEvents();\r\n          unbindKeyboardEvents();\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $modal);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($modal);\r\n          }\r\n          if (findElement('.modal').length <= 0) {\r\n            bodyElement.removeClass(options.prefixClass + '-open');\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n          }\r\n          if (options.animation) {\r\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n        }\r\n\r\n        function findFocusableElements () {\r\n          // Add all elements we want to include in our selection\r\n          var focusableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), [tabindex]:not([disabled]):not([tabindex=\"-1\"])';\r\n          if (document.activeElement) {\r\n            var focusable = Array.prototype.filter.call(modalElement[0].querySelectorAll(focusableElements),\r\n              function (element) {\r\n                // Check for visibility while always include the current activeElement\r\n                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement;\r\n              });\r\n\r\n            return focusable;\r\n          }\r\n        }\r\n\r\n        function findNextFocusableElement (inReverse) {\r\n          if (document.activeElement) {\r\n            var focusable = findFocusableElements();\r\n            if (focusable === undefined) return;\r\n            if (inReverse) {\r\n              focusable = Array.prototype.reverse.call(focusable);\r\n            }\r\n\r\n            var index = focusable.indexOf(document.activeElement);\r\n            return focusable[index + 1];\r\n          }\r\n        }\r\n\r\n        $modal.toggle = function () {\r\n          if ($modal.$isShown) {\r\n            $modal.hide();\r\n          } else {\r\n            $modal.show();\r\n          }\r\n        };\r\n\r\n        $modal.focus = function () {\r\n          modalElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $modal.$onKeyUp = function (evt) {\r\n\r\n          // Escape was pressed on an open modal. Hide it.  Backspace key, nothing happen.\r\n          if ((evt.which === 8 || evt.which === 27) && $modal.$isShown) {\r\n            if (evt.which === 27) {\r\n              $modal.hide();\r\n            }\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $modal.$onKeyDown = function (evt) {\r\n          if (options.keyboard) {\r\n            if (evt.keyCode === 8 && evt.target.tagName !== 'TEXTAREA' && evt.target.tagName !== 'INPUT') {\r\n              evt.preventDefault();\r\n            }\r\n\r\n            if (evt.keyCode === 9) {\r\n\r\n              var nextFocusable = findNextFocusableElement(evt.shiftKey);\r\n              if (nextFocusable === undefined) {\r\n                if (evt.preventDefault) evt.preventDefault();\r\n                if (evt.stopPropagation) evt.stopPropagation();\r\n\r\n                var focusable = findFocusableElements();\r\n                if (evt.shiftKey) {\r\n                  focusable[focusable.length - 1].focus();\r\n                } else {\r\n                  focusable[0].focus();\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        function bindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function unbindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.on('keyup', $modal.$onKeyUp);\r\n            modalElement.on('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.off('keyup', $modal.$onKeyUp);\r\n            modalElement.off('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        // Private helpers\r\n\r\n        function hideOnBackdropClick (evt) {\r\n          if (evt.target !== evt.currentTarget) return;\r\n          if (options.backdrop === 'static') {\r\n            $modal.focus();\r\n          } else {\r\n            $modal.hide();\r\n          }\r\n        }\r\n\r\n        function preventEventDefault (evt) {\r\n          evt.preventDefault();\r\n        }\r\n\r\n        function destroyModalElement () {\r\n          if ($modal.$isShown && modalElement !== null) {\r\n            // un-bind events\r\n            unbindBackdropEvents();\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (modalScope) {\r\n            modalScope.$destroy();\r\n            modalScope = null;\r\n          }\r\n\r\n          if (modalElement) {\r\n            modalElement.remove();\r\n            modalElement = $modal.$element = null;\r\n          }\r\n        }\r\n\r\n        return $modal;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return ModalFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope,\r\n          element: element,\r\n          show: false\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Options: alias modalClass to customClass\r\n        if (options.modalClass) {\r\n          options.customClass = options.modalClass;\r\n        }\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsModal) {\r\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize modal\r\n        var modal = $modal(options);\r\n\r\n        if (options.keyboard) {\r\n          modal.returnFocus = function () {\r\n            element[0].focus();\r\n          };\r\n        }\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', modal.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (modal) modal.destroy();\r\n          options = null;\r\n          modal = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: datepicker\\datepicker.js\r\nangular.module('mgcrea.ngStrap.datepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.helpers.focusElement', 'mgcrea.ngStrap.helpers.ngFocusOut', 'mgcrea.ngStrap.tooltip'])\r\n  .provider('$datepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      // Uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'datepicker',\r\n      prefixClass: 'datepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'datepicker/datepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: false,\r\n      dateType: 'date',\r\n      dateFormat: 'shortDate',\r\n      timezone: null,\r\n      modelDateFormat: null,\r\n      dayFormat: 'dd',\r\n      monthFormat: 'MMM',\r\n      yearFormat: 'yyyy',\r\n      monthTitleFormat: 'MMMM yyyy',\r\n      yearTitleFormat: 'yyyy',\r\n      strictFormat: false,\r\n      autoclose: false,\r\n      minDate: -Infinity,\r\n      maxDate: +Infinity,\r\n      startView: 0,\r\n      minView: 0,\r\n      startWeek: 0,\r\n      daysOfWeekDisabled: '',\r\n      hasToday: false,\r\n      hasClear: false,\r\n      iconLeft: 'glyphicon glyphicon-chevron-left',\r\n      iconRight: 'glyphicon glyphicon-chevron-right',\r\n      // The format that will be given to the screen reader values placed in the DOM.\r\n      screenReaderDateFormat: 'fullDate',\r\n      // Focuses the table element in the dropdown upon display of the picker.\r\n      // Used mainly in 508 situations when a button is pressed via a keyboard to show the calendar.\r\n      focusOnOpen: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\r\n\r\n      function DatepickerFactory (element, controller, config) {\r\n\r\n        // The datepicker is based on the tooltip control. Build a basic tooltip from the\r\n        // defaults and the configuration passed.\r\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $datepicker.$options;\r\n        var scope = $datepicker.$scope;\r\n        if (options.startView) options.startView -= options.minView;\r\n\r\n        // Add assistive technology helper attributes.\r\n        element.attr('aria-expanded', 'false').attr('aria-haspopup', 'true');\r\n\r\n        // View vars\r\n\r\n        // Initialize the datepicker view collection by passing a reference to the base object.\r\n        var pickerViews = datepickerViews($datepicker);\r\n        $datepicker.$views = pickerViews.views;\r\n        var viewDate = pickerViews.viewDate;\r\n        /*\r\n         * View mode for the date picker.\r\n         * 0: days\r\n         * 1: months\r\n         * 2: years\r\n         */\r\n        scope.$mode = options.startView;\r\n        // icon class override\r\n        scope.$iconLeft = options.iconLeft;\r\n        scope.$iconRight = options.iconRight;\r\n        // Show buttons at the bottom of the picker.\r\n        scope.$hasToday = options.hasToday;\r\n        scope.$hasClear = options.hasClear;\r\n        /*\r\n         * An id on the element is necessary when working with assistive technologies. The view will use the id to build out the\r\n         * aria attributes which are linked via ids.\r\n         */\r\n        scope.id = options.id !== null && options.id !== undefined ? options.id : undefined;\r\n        scope.dropdownId = options.id !== null && options.id !== undefined ? (options.id + '_dropdown') : undefined;\r\n        scope.keyboard = options.keyboard;\r\n        scope.focusOnOpen = options.focusOnOpen;\r\n\r\n        // labels\r\n        scope.$nextLabel = options.labelNext;\r\n        scope.$previousLabel = options.labelPrevious;\r\n\r\n        // This is the actual current picker view.\r\n        var $picker = $datepicker.$views[scope.$mode];\r\n\r\n        // Internal handlers\r\n\r\n        function handleOnKeyDown (evt, apply) {\r\n          if (!/(33|34|38|37|39|40|13)/.test(evt.keyCode) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.shiftKey) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.altKey)) {\r\n            return false;\r\n          }\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          if (evt.keyCode === 13) {\r\n            if (!scope.$mode) {\r\n              $datepicker.hide(true);\r\n              if (options.focusOnOpen) return true;\r\n            } else {\r\n              if (apply === undefined || apply) {\r\n                scope.$apply(function () {\r\n                  $datepicker.setMode(scope.$mode - 1);\r\n                });\r\n              } else {\r\n                $datepicker.setMode(scope.$mode - 1);\r\n              }\r\n            }\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        // Scope methods\r\n\r\n        /**\r\n         * Pass through from the scope to the provider for the selection of a date.\r\n         */\r\n        scope.$select = function (date, disabled) {\r\n          if (disabled) return;\r\n          $datepicker.select(date);\r\n        };\r\n        scope.$selectPane = function (value) {\r\n          $datepicker.$selectPane(value);\r\n        };\r\n        scope.$toggleMode = function () {\r\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\r\n        };\r\n        scope.$setToday = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(new Date());\r\n          } else {\r\n            $datepicker.select(new Date(), true);\r\n          }\r\n        };\r\n        scope.$clear = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(null);\r\n          } else {\r\n            $datepicker.select(null, true);\r\n          }\r\n        };\r\n        scope.$focused = function (dayInfo) {\r\n          scope.selectedDayId = dayInfo.id;\r\n          if (dayInfo.isNext && !scope.selected) {\r\n            if (scope.$mode) {\r\n              $datepicker.update(dayInfo.date);\r\n            } else {\r\n              scope.$select(dayInfo.date);\r\n            }\r\n          }\r\n        };\r\n        scope.$onKeyDown = function (evt, day) {\r\n          var continueHandling = handleOnKeyDown(evt, false);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n          }\r\n        };\r\n        scope.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inTable = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n              inTable = true;\r\n              break;\r\n            } else {\r\n              inTable = false;\r\n            }\r\n          }\r\n\r\n          // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n          //\r\n\r\n          if (!inTable && !evt.relatedTarget) {\r\n            // hmm\r\n          } else if (!inTable) {\r\n            $datepicker.hide();\r\n          } else {\r\n            evt.stopPropagation();\r\n            evt.preventDefault();\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $datepicker.update = function (date) {\r\n          // console.warn('$datepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $datepicker.$date = date;\r\n            $picker.update.call($picker, date);\r\n          }\r\n          // Build only if pristine\r\n          $datepicker.$build(true);\r\n        };\r\n\r\n        $datepicker.updateDisabledDates = function (dateRanges) {\r\n          options.disabledDateRanges = dateRanges;\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\r\n          }\r\n        };\r\n\r\n        $datepicker.select = function (date, keep) {\r\n          // console.warn('$datepicker.select', date, scope.$mode);\r\n          if (angular.isDate(date)) {\r\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\r\n              controller.$dateValue = new Date(date);\r\n            }\r\n          } else {\r\n            controller.$dateValue = null;\r\n          }\r\n          if (!scope.$mode || keep) {\r\n            controller.$setViewValue(angular.copy(date));\r\n            controller.$render();\r\n            if (options.autoclose && !keep) {\r\n              $timeout(function () {\r\n                $datepicker.hide(true);\r\n              });\r\n            }\r\n          } else {\r\n            angular.extend(viewDate, {\r\n              year: date.getFullYear(),\r\n              month: date.getMonth(),\r\n              date: date.getDate()\r\n            });\r\n            $datepicker.setMode(scope.$mode - 1);\r\n            $datepicker.$build();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * This changes the mode of the picker. By setting the mode the view for the picker will be\r\n         * rebuilt. The views are days, months, and years.\r\n         * @param {int} mode View mode for the datepicker. 0: day view, 1: month view, 2: year view.\r\n         */\r\n        $datepicker.setMode = function setMode (mode) {\r\n          scope.$mode = mode;\r\n          $picker = $datepicker.$views[scope.$mode];\r\n          // The picker has been changed so the view needs to be built.\r\n          $datepicker.$build();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        /**\r\n         * Builds the datepicker's view based on the picker that is currently set.\r\n         */\r\n        $datepicker.$build = function $build (pristine) {\r\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\r\n          if (pristine === true && $picker.built) return;\r\n          if (pristine === false && !$picker.built) return;\r\n          $picker.build.call($picker);\r\n        };\r\n\r\n        $datepicker.$updateSelected = function () {\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], function (day) {\r\n              updateSelected(day);\r\n              if (day.selected) scope.selected = day;\r\n            });\r\n          }\r\n        };\r\n\r\n        $datepicker.$isSelected = function (date) {\r\n          return $picker.isSelected(date);\r\n        };\r\n\r\n        $datepicker.$setDisabledEl = function (el) {\r\n          el.disabled = $picker.isDisabled(el.date);\r\n        };\r\n\r\n        $datepicker.$selectPane = function (value) {\r\n          var steps = $picker.steps;\r\n          // set targetDate to first day of month to avoid problems with\r\n          // date values rollover. This assumes the viewDate does not\r\n          // depend on the day of the month\r\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\r\n          angular.extend(viewDate, {\r\n            year: targetDate.getUTCFullYear(),\r\n            month: targetDate.getUTCMonth(),\r\n            date: targetDate.getUTCDate()\r\n          });\r\n          $datepicker.$build();\r\n        };\r\n\r\n        $datepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Handles the onKeyDown event from the element that this datepicker is bound.\r\n         * In the standard case this will be an input element. If the trigger is set\r\n         * to click and is bound to a button then it is likely we're servicing a 508\r\n         * type situation where the implementation will no longer uses. Focus will be\r\n         * given to the table.\r\n         */\r\n        $datepicker.$onKeyDown = function (evt) {\r\n          var continueHandling = handleOnKeyDown(evt);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n            parentScope.$digest();\r\n          }\r\n        };\r\n\r\n        // $datepicker.$onFocusOut = function (evt) {\r\n        //   // find out if the related target's parents contain the datepicker's $element\r\n        //   var inTable = false;\r\n        //   var parent = angular.element(evt.relatedTarget);\r\n        //   while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n        //     parent = parent.parent();\r\n        //     if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n        //       inTable = true;\r\n        //       break;\r\n        //     } else {\r\n        //       inTable = false;\r\n        //     }\r\n        //   }\r\n\r\n        //   // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n        //   //\r\n\r\n        //   if (!inTable && !evt.relatedTarget) {\r\n        //     // hmm\r\n        //   } else if (!inTable) {\r\n        //     $datepicker.hide();\r\n        //   } else {\r\n        //     evt.stopPropagation();\r\n        //     evt.preventDefault();\r\n        //   }\r\n        // };\r\n\r\n        // Private\r\n\r\n        function updateSelected (el) {\r\n          el.selected = $datepicker.$isSelected(el.date);\r\n          el.focused = el.selected;\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        // The datepicker will override the init functionality of the tool\r\n        var _init = $datepicker.init;\r\n        /**\r\n         * Initialize the datepicker.\r\n         */\r\n        $datepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'date');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        // The datepicker will override the destroy functionalty of the tooltip. Storing a ref to the\r\n        // tooltip's destroy function so that it can be invoked when the datepicker needs to be destroyed.\r\n        var _destroy = $datepicker.destroy;\r\n\r\n        /**\r\n         * Destroys the datepicker by removing bound events. Calls the destroy function on the tooltip.\r\n         */\r\n        $datepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        // The datepicker will override the show functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be shown.\r\n        var _show = $datepicker.show;\r\n\r\n        /**\r\n         * Override for the tooltip's show function.\r\n         *\r\n         * Checks the element for readonly or disabled before showing the \"tooltip\".\r\n         * Once shown it sets up the appropriate events.\r\n         */\r\n        $datepicker.show = function show () {\r\n          // If the input the directive is bound to is readonly or disabled then do not show a picker.\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n\r\n          // Call the \"overriden base\" function on the tooltip.\r\n          _show();\r\n\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // if $datepicker is no longer showing, don't setup events\r\n            if (!$datepicker.$isShown) return;\r\n\r\n            // Update assistive technologies for view changes:\r\n            $datepicker.$element.attr('aria-hidden', 'false');\r\n            element.attr('aria-expanded', 'true');\r\n\r\n            // Setup the event mouse click event. TODO: Can this be wired up in the view?\r\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n            // If keyboard navigation is enabled (true by default).\r\n            if (options.keyboard) {\r\n              // $datepicker.$element.on('keydown', $datepicker.$onKeyDown);\r\n              // Check to see if the table element should receive the focus when the picker is shown.\r\n              if (options.focusOnOpen) {\r\n                // Focus the table element.\r\n                // $datepicker.$element.find('table')[0].focus();\r\n                // $datepicker.$element.on('focusout', $datepicker.$onFocusOut);\r\n              } else {\r\n                element.on('keydown', $datepicker.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        // The datepicker will override the hide functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be hidden.\r\n        var _hide = $datepicker.hide;\r\n\r\n        /**\r\n         * Overrid efor the tooltip's hide function.\r\n         *\r\n         * Updates attributes for assistive technologies and unbinds events.\r\n         */\r\n        $datepicker.hide = function (blur) {\r\n          // If the picker is already hidden don't do anything.\r\n          if (!$datepicker.$isShown) return;\r\n\r\n          // Update the attributes used by assisteive technologies\r\n          $datepicker.$element.attr('aria-hidden', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          // Unbind the mouse and touch events\r\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n          // If keyboard events were bound then unbind them.\r\n          if (options.keyboard) {\r\n            element.off('keydown', $datepicker.$onKeyDown);\r\n            $datepicker.$element.off('keydown', $datepicker.$onKeyDown);\r\n          }\r\n          if (options.focusOnOpen) {\r\n            // $datepicker.$element.off('focusout', $datepicker.$onFocusOut);\r\n            element[0].focus();\r\n          }\r\n          // Call the tooltip's hide function.\r\n          _hide(blur);\r\n        };\r\n\r\n        return $datepicker;\r\n      }\r\n\r\n      DatepickerFactory.defaults = defaults;\r\n      return DatepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\r\n\r\n    // var defaults = $datepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear', 'focusOnOpen', 'labelNext', 'labelPrevious', 'labelMonth', 'labelYear', 'labelDays'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear', 'focusOnOpen'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize datepicker\r\n        var datepicker = $datepicker(element, controller, options);\r\n        options = datepicker.$options;\r\n        // Set expected iOS format\r\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!datepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\r\n            if (newValue === true) {\r\n              datepicker.show();\r\n            } else {\r\n              datepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\r\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              // Build only if dirty\r\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            datepicker.$options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          datepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        // Normalize undefined/null/empty array,\r\n        // so that we don't treat changing from undefined->null as a change.\r\n        function normalizeDateRanges (ranges) {\r\n          if (!ranges || !ranges.length) return null;\r\n          return ranges;\r\n        }\r\n\r\n        if (angular.isDefined(attr.disabledDates)) {\r\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\r\n            disabledRanges = normalizeDateRanges(disabledRanges);\r\n            previousValue = normalizeDateRanges(previousValue);\r\n\r\n            if (disabledRanges) {\r\n              datepicker.updateDisabledDates(disabledRanges);\r\n            }\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\r\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getDateFormattedString());\r\n        };\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (datepicker) datepicker.destroy();\r\n          options = null;\r\n          datepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepickerDisplay', function ($datepicker, $dateParser, $dateFormatter) {\r\n    return {\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'lang'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        options = angular.extend({}, $datepicker.defaults, options);\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(options.minDate) || parsedDate.getTime() >= options.minDate;\r\n          var isMaxValid = isNaN(options.maxDate) || parsedDate.getTime() <= options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n\r\n          return date === null ? null : new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n      }\r\n    };\r\n  })\r\n\r\n  .provider('datepickerViews', function () {\r\n\r\n    // var defaults = this.defaults = {\r\n    //   dayFormat: 'dd',\r\n    //   daySplit: 7\r\n    // };\r\n\r\n    // Split array into smaller arrays\r\n    function split (arr, size) {\r\n      var arrays = [];\r\n      while (arr.length > 0) {\r\n        arrays.push(arr.splice(0, size));\r\n      }\r\n      return arrays;\r\n    }\r\n\r\n    // Modulus operator\r\n    function mod (n, m) {\r\n      return ((n % m) + m) % m;\r\n    }\r\n\r\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\r\n\r\n      return function (picker) {\r\n\r\n        var scope = picker.$scope;\r\n        var options = picker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\r\n        var weekDaysLong = $dateFormatter.weekdays(lang);\r\n        var weekDaysShortLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n        var weekDaysLongLabels = weekDaysLong.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n\r\n        var weekDaysLabelsHtml = '';\r\n        for (var i = 0; i < weekDaysShortLabels.length; i++) {\r\n          var weekDayShortLabel = weekDaysShortLabels[i];\r\n          var weekDayLabel = weekDaysLongLabels[i];\r\n          weekDaysLabelsHtml += '<th scope=\"col\" role=\"columnheader\" class=\"dow text-center\" aria-label=\"' + weekDayLabel + '\"><abbr title=\"' + weekDayLabel + '\">' + weekDayShortLabel + '</abbr></th>';\r\n        }\r\n        weekDaysLabelsHtml = $sce.trustAsHtml(weekDaysLabelsHtml);\r\n\r\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\r\n        var viewDate = {\r\n          year: startDate.getFullYear(),\r\n          month: startDate.getMonth(),\r\n          date: startDate.getDate()\r\n        };\r\n\r\n        var views = [{\r\n          format: options.dayFormat,\r\n          split: 7,\r\n          steps: {\r\n            month: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\r\n              // chaging picker current month will cause viewDate.date to be set to first day of the month,\r\n              // in $datepicker.$selectPane, so picker would not update selected day display if\r\n              // user picks first day of the new month.\r\n              // As a workaround, we are always forcing update when picked date is first day of month.\r\n              viewDate.date = picker.$date.getDate();\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\r\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\r\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\r\n            var firstDateOffset = firstDate.getTimezoneOffset();\r\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\r\n            // Handle daylight time switch\r\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\r\n            var days = [];\r\n            var day;\r\n            var selectedDay;\r\n            var todayDay;\r\n            for (var i = 0; i < 42; i++) { // < 7 * 6\r\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\r\n              // push the day information onto the collection\r\n              var dayItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: day,\r\n                value: day.getDate(),\r\n                isToday: day.toDateString() === today,\r\n                label: formatDate(day, this.format),\r\n                screenReaderLabel: formatDate(day, $dateFormatter.getDatetimeFormat(options.screenReaderDateFormat)),\r\n                selected: picker.$date && this.isSelected(day),\r\n                muted: day.getMonth() !== viewDate.month,\r\n                disabled: this.isDisabled(day)\r\n              };\r\n\r\n              if (dayItem.selected) selectedDay = dayItem;\r\n              if (dayItem.isToday) todayDay = dayItem;\r\n\r\n              days.push(dayItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedDay) {\r\n                scope.selectedDayId = selectedDay.id;\r\n                if (todayDay) todayDay.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedDay.focused = true;\r\n                scope.selected = selectedDay;\r\n              } else if (todayDay) {\r\n                todayDay.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\r\n            scope.showLabels = true;\r\n            scope.labels = weekDaysLabelsHtml;\r\n            scope.rows = split(days, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.isTodayDisabled = this.isDisabled(new Date());\r\n            scope.hasSelectedDate = picker.$date != null;\r\n            scope.$modeLabel = options.labelMonth;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() &&\r\n              date.getMonth() === picker.$date.getMonth() &&\r\n              date.getDate() === picker.$date.getDate();\r\n          },\r\n          isDisabled: function (date) {\r\n            var time = date.getTime();\r\n\r\n            // Disabled because of min/max date.\r\n            if (time < options.minDate || time > options.maxDate) return true;\r\n\r\n            // Disabled due to being a disabled day of the week\r\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\r\n\r\n            // Disabled because of disabled date range.\r\n            if (options.disabledDateRanges) {\r\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\r\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n\r\n            return false;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            var actualTime;\r\n\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date) {\r\n              if (angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n                picker.$date = new Date();\r\n              } else {\r\n                picker.$date = dateParser.parse(angular.element(evt.target).attr('aria-label'), null, options.screenReaderDateFormat);\r\n              }\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return false;\r\n            }\r\n\r\n            actualTime = picker.$date.getTime();\r\n\r\n            var newDate;\r\n\r\n            switch (evt.keyCode) {\r\n              // enter\r\n              case 13:\r\n                if (options.focusOnOpen) {\r\n                  picker.select(new Date(actualTime), true);\r\n                  return false;\r\n                }\r\n                break;\r\n                // pageup\r\n              case 33:\r\n                if (evt.altKey) { // move back a year\r\n                  newDate = new Date(picker.$date.getFullYear() - 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move back a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() - 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() - 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth(), 0);\r\n                  }\r\n                }\r\n                break;\r\n\r\n                // pagedown\r\n              case 34:\r\n                if (evt.altKey) { // move forward a year\r\n                  newDate = new Date(picker.$date.getFullYear() + 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move forward a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() + 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, 1);\r\n                  }\r\n                }\r\n\r\n                break;\r\n\r\n                // left arrow\r\n              case 37:\r\n                newDate = new Date(actualTime - 1 * 864e5);\r\n                break;\r\n\r\n                // up arrow\r\n              case 38:\r\n                newDate = new Date(actualTime - 7 * 864e5);\r\n                break;\r\n\r\n                // right arrow\r\n              case 39:\r\n                newDate = new Date(actualTime + 1 * 864e5);\r\n                break;\r\n\r\n                // down arrow\r\n              case 40:\r\n                newDate = new Date(actualTime + 7 * 864e5);\r\n                break;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n\r\n            if (evt && evt.stopPropagation) evt.stopPropagation();\r\n\r\n            return false;\r\n          }\r\n        }, {\r\n          name: 'month',\r\n          format: options.monthFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            // var firstMonth = new Date(viewDate.year, 0, 1);\r\n            var months = [];\r\n            var month;\r\n            var thisMonthDate = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            var selectedMonth;\r\n            var thisMonth;\r\n            for (var i = 0; i < 12; i++) {\r\n              month = new Date(viewDate.year, i, 1);\r\n\r\n              var monthItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: month,\r\n                label: formatDate(month, this.format),\r\n                selected: picker.$isSelected(month),\r\n                isToday: month.getFullYear() === thisMonthDate.getFullYear() && month.getMonth() === thisMonthDate.getMonth(),\r\n                disabled: this.isDisabled(month)\r\n              };\r\n\r\n              if (monthItem.selected) selectedMonth = monthItem;\r\n              if (monthItem.isToday) thisMonth = monthItem;\r\n\r\n              months.push(monthItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedMonth) {\r\n                scope.selectedDayId = selectedMonth.id;\r\n                if (thisMonth) thisMonth.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedMonth.focused = true;\r\n                scope.selected = selectedMonth;\r\n              } else if (thisMonth) {\r\n                thisMonth.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(month, options.yearTitleFormat);\r\n            scope.showLabels = false;\r\n            scope.rows = split(months, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modeLabel = options.labelYear;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualMonth = picker.$date.getMonth();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\r\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\r\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\r\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\r\n\r\n            if (options.focusOnOpen && evt.keyCode === 13) picker.select(new Date(picker.$date));\r\n            else if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }, {\r\n          name: 'year',\r\n          format: options.yearFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 12\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\r\n            var years = [];\r\n            var year;\r\n            var selectedYear;\r\n            var thisYear;\r\n            for (var i = 0; i < 12; i++) {\r\n              year = new Date(firstYear + i, 0, 1);\r\n\r\n              var yearItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: year,\r\n                label: formatDate(year, this.format),\r\n                selected: picker.$isSelected(year),\r\n                isToday: year.getFullYear() === (new Date()).getFullYear(),\r\n                disabled: this.isDisabled(year)\r\n              };\r\n\r\n              if (yearItem.selected) selectedYear = yearItem;\r\n              if (yearItem.isToday) thisYear = yearItem;\r\n\r\n              years.push(yearItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedYear) {\r\n                scope.selectedDayId = selectedYear.id;\r\n                if (thisYear) thisYear.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedYear.focused = true;\r\n                scope.selected = selectedYear;\r\n              } else if (thisYear) {\r\n                thisYear.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\r\n            scope.startYear = years[0].label;\r\n            scope.endYear = years[years.length - 1].label;\r\n            scope.showLabels = false;\r\n            scope.rows = split(years, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modelLabel = options.labelDays;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), 0, 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualYear = picker.$date.getFullYear();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\r\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\r\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\r\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }];\r\n\r\n        return {\r\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\r\n          viewDate: viewDate\r\n        };\r\n\r\n      };\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: dropdown\\dropdown.js\r\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$dropdown', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'dropdown',\r\n      prefixEvent: 'dropdown',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'dropdown/dropdown.tpl.html',\r\n      trigger: 'click',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\r\n\r\n      function DropdownFactory (element, config) {\r\n\r\n        var $dropdown = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        /* var scope = */\r\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        $dropdown = $tooltip(element, options);\r\n        var parentEl = element.parent();\r\n\r\n        if (element && element[0] && element[0].tagName.toUpperCase() === 'BUTTON') {\r\n          element.attr('aria-haspopup', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n        }\r\n\r\n        // Protected methods\r\n\r\n        $dropdown.$onKeyDown = function (evt) {\r\n          if (evt.keyCode === 9 || evt.keyCode === 27) {\r\n            $dropdown.hide(/27/.test(evt.keyCode));\r\n            return;\r\n          } else if ($dropdown.$element && (evt.keyCode === 38 || evt.keyCode === 40 || evt.keyCode === 32 || evt.keyCode === 13)) {\r\n            //$dropdown.$element.focus();\r\n\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n\r\n            // Retrieve active index\r\n            var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n            if (!items.length) return;\r\n            var index;\r\n            angular.forEach(items, function (el, i) {\r\n              if (matchesSelector && matchesSelector.call(el, '.active')) {\r\n                index = i;\r\n                angular.element(el).removeClass('active');\r\n              }\r\n            });\r\n\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 32 || evt.keyCode === 13) {\r\n              items.eq(index).click();\r\n            } else if (evt.keyCode === 38 && index > 0) index--;\r\n            else if (evt.keyCode === 38 && (angular.isUndefined(index) || index === 0)) index = items.length - 1;\r\n            else if (evt.keyCode === 40 && index < items.length - 1) index++;\r\n            else if (evt.keyCode === 40 && index === items.length - 1) index = 0;\r\n            else if (angular.isUndefined(index)) index = 0;\r\n            items.eq(index).addClass('active');\r\n            $dropdown.$element.attr('aria-activedescendant', items.eq(index).attr('id'));\r\n\t\t\titems.eq(index)[0].focus();\r\n          }\r\n        };\r\n\r\n        $dropdown.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inMenu = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $dropdown.$element[0]) {\r\n              inMenu = true;\r\n              break;\r\n            } else {\r\n              inMenu = false;\r\n            }\r\n          }\r\n\r\n          if (!inMenu) {\r\n            $dropdown.hide();\r\n          } else {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $dropdown.show;\r\n        $dropdown.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Set assistive technology properties\r\n            element.attr('aria-expanded', 'true');\r\n            if ($dropdown.$element) {\r\n              $dropdown.$element.attr('aria-activedescendant', '');\r\n              $dropdown.$element.attr('role', 'menu');\r\n              $dropdown.$element.attr('tabindex', '-1');\r\n            }\r\n            if (options.keyboard && $dropdown.$element) {\r\n              $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\r\n              $dropdown.$element.on('focusout', $dropdown.$onFocusOut);\r\n            }\r\n\r\n            bodyEl.on('click', onBodyClick);\r\n\r\n            if ($dropdown.$element) {\r\n              var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider)'));\r\n              // <li> should have role=\"none\" as per SS-9603\r\n              items.attr('role', 'none');\r\n\r\n              angular.element($dropdown.$element[0].querySelectorAll('li.divider')).attr('role', 'seperator');\r\n\r\n              items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n              items.attr('role', 'menuitem');\r\n              if (items.length && options.keyboard) {\r\n                // Dropdown menu items that are natively focusable need to have a tabindex of -1 per SS-9603\r\n                // Menu item ID's should be unique for aria-activedescendant\r\n                angular.forEach(items, function (value, key) {\r\n                  angular.element(value).attr('id', $dropdown.$scope.$id + '_menuitem_' + key);\r\n                  angular.element(value).attr('tabindex', '-1');\r\n                });\r\n              }\r\n            }\r\n          }, 0, false);\r\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\r\n        };\r\n\r\n        var hide = $dropdown.hide;\r\n        $dropdown.hide = function (returnFocus) {\r\n          if (!$dropdown.$isShown) return;\r\n\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          if (options.keyboard && $dropdown.$element) {\r\n            $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\r\n            $dropdown.$element.off('focusout', $dropdown.$onFocusOut);\r\n          }\r\n\r\n          bodyEl.off('click', onBodyClick);\r\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\r\n          $timeout(function () {\r\n            hide();\r\n            if (returnFocus) {\r\n              $timeout(function () {\r\n                if (element && element[0]) {\r\n                  element[0].focus();\r\n                }\r\n              }, 0, false);\r\n            }\r\n          }, 200);\r\n        };\r\n\r\n        var destroy = $dropdown.destroy;\r\n        $dropdown.destroy = function () {\r\n          bodyEl.off('click', onBodyClick);\r\n          destroy();\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function onBodyClick (evt) {\r\n          if (evt.target === element[0]) return undefined;\r\n          return evt.target !== element[0] && $dropdown.hide();\r\n        }\r\n\r\n        return $dropdown;\r\n\r\n      }\r\n\r\n      return DropdownFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      compile: function (tElement, tAttrs) {\r\n\r\n        // Support for inlined template (next sibling)\r\n        // It must be fetched before compilation\r\n        if (!tAttrs.bsDropdown) {\r\n          var nextSibling = tElement[0].nextSibling;\r\n          while (nextSibling && nextSibling.nodeType !== 1) {\r\n            nextSibling = nextSibling.nextSibling;\r\n          }\r\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\r\n            tAttrs.template = nextSibling.outerHTML;\r\n            tAttrs.templateUrl = undefined;\r\n            nextSibling.parentNode.removeChild(nextSibling);\r\n          }\r\n        }\r\n\r\n        return function postLink (scope, element, attr) {\r\n\r\n          // Directive options\r\n          var options = {\r\n            scope: scope\r\n          };\r\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\r\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\r\n          });\r\n\r\n          // use string regex match boolean attr falsy values, leave truthy values be\r\n          var falseValueRegExp = /^(false|0|)$/i;\r\n          angular.forEach(['html', 'container'], function (key) {\r\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n          });\r\n\r\n          // bind functions from the attrs to the show and hide events\r\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n            if (angular.isDefined(attr[bsKey])) {\r\n              options[key] = scope.$eval(attr[bsKey]);\r\n            }\r\n          });\r\n\r\n          // Support scope as an object\r\n          if (attr.bsDropdown) {\r\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\r\n              scope.content = newValue;\r\n            }, true);\r\n          }\r\n\r\n          // Initialize dropdown\r\n          var dropdown = $dropdown(element, options);\r\n\r\n          // Pickup key press on the dropdown button\r\n          element.on('keydown',function (evt) {\r\n            if (evt.keyCode === 38 || evt.keyCode === 40 || evt.keyCode === 27 || evt.keyCode === 9) {\r\n              dropdown.$onKeyDown(evt);\r\n            }\r\n          });\r\n\r\n          // Visibility binding support\r\n          if (attr.bsShow) {\r\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n              if (!dropdown || !angular.isDefined(newValue)) return;\r\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\r\n              if (newValue === true) {\r\n                dropdown.show();\r\n              } else {\r\n                dropdown.hide();\r\n              }\r\n            });\r\n          }\r\n\r\n          // Garbage collection\r\n          scope.$on('$destroy', function () {\r\n            if (dropdown) dropdown.destroy();\r\n            options = null;\r\n            dropdown = null;\r\n          });\r\n\r\n        };\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: collapse\\collapse.js\r\nangular.module('mgcrea.ngStrap.collapse', [])\r\n\r\n  .provider('$collapse', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-collapse',\r\n      disallowToggle: false,\r\n      activeClass: 'in',\r\n      startCollapsed: false,\r\n      allowMultiple: false\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\r\n          self.$options[key] = false;\r\n        }\r\n      });\r\n\r\n      self.$toggles = [];\r\n      self.$targets = [];\r\n\r\n      self.$viewChangeListeners = [];\r\n\r\n      self.$registerToggle = function (element) {\r\n        self.$toggles.push(element);\r\n        element.attr('aria-expanded', 'false');\r\n      };\r\n      self.$registerTarget = function (element) {\r\n        self.$targets.push(element);\r\n\r\n        var i = 0;\r\n        if (self.$targets) {\r\n          for (i = 0; i < self.$targets.length; i++) {\r\n            self.$targets[i].attr('aria-hidden', 'true');\r\n          }\r\n          for (i = 0; i < self.$targets.$active.length; i++) {\r\n            if (self.$targets[self.$targets.$active[i]]) {\r\n              self.$targets[self.$targets.$active[i]].attr('aria-hidden', 'false');\r\n            }\r\n            if (self.$toggles[self.$targets.$active[i]]) {\r\n              self.$toggles[self.$targets.$active[i]].attr('aria-expanded', 'true');\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      self.$unregisterToggle = function (element) {\r\n        var index = self.$toggles.indexOf(element);\r\n        // remove toggle from $toggles array\r\n        self.$toggles.splice(index, 1);\r\n      };\r\n      self.$unregisterTarget = function (element) {\r\n        var index = self.$targets.indexOf(element);\r\n\r\n        // remove element from $targets array\r\n        self.$targets.splice(index, 1);\r\n\r\n        if (self.$options.allowMultiple) {\r\n          // remove target index from $active array values\r\n          deactivateItem(element);\r\n        }\r\n\r\n        // fix active item indexes\r\n        fixActiveItemIndexes(index);\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      // use array to store all the currently open panels\r\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        if (angular.isArray(value)) {\r\n          self.$targets.$active = value;\r\n        } else if (!self.$options.disallowToggle && isActive(value)) {\r\n          deactivateItem(value);\r\n        } else {\r\n          activateItem(value);\r\n        }\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$activeIndexes = function () {\r\n        if (self.$options.allowMultiple) {\r\n          return self.$targets.$active;\r\n        }\r\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\r\n      };\r\n\r\n      function fixActiveItemIndexes (index) {\r\n        // item with index was removed, so we\r\n        // need to adjust other items index values\r\n        var activeIndexes = self.$targets.$active;\r\n        for (var i = 0; i < activeIndexes.length; i++) {\r\n          if (index < activeIndexes[i]) {\r\n            activeIndexes[i] = activeIndexes[i] - 1;\r\n          }\r\n\r\n          // the last item is active, so we need to\r\n          // adjust its index\r\n          if (activeIndexes[i] === self.$targets.length) {\r\n            activeIndexes[i] = self.$targets.length - 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      function isActive (value) {\r\n        var activeItems = self.$targets.$active;\r\n        return activeItems.indexOf(value) !== -1;\r\n      }\r\n\r\n      function deactivateItem (value) {\r\n        var index = self.$targets.$active.indexOf(value);\r\n        if (index !== -1) {\r\n          self.$targets[self.$targets.$active[index]].attr('aria-hidden', 'true');\r\n          self.$toggles[self.$targets.$active[index]].attr('aria-expanded', 'false');\r\n          self.$targets.$active.splice(index, 1);\r\n        }\r\n      }\r\n\r\n      function activateItem (value) {\r\n        if (!self.$options.allowMultiple) {\r\n          // remove current selected item\r\n          if (self.$targets[self.$targets.$active[0]] !== undefined) {\r\n            self.$targets[self.$targets.$active[0]].attr('aria-hidden', 'true');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[0]]) {\r\n            self.$toggles[self.$targets.$active[0]].attr('aria-expanded', 'false');\r\n          }\r\n          self.$targets.$active.splice(0, 1);\r\n        }\r\n\r\n        if (self.$targets.$active.indexOf(value) === -1) {\r\n          self.$targets.$active.push(value);\r\n\r\n          if (self.$targets[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$targets[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-hidden', 'false');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-expanded', 'true');\r\n          }\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $collapse = {};\r\n      $collapse.defaults = defaults;\r\n      $collapse.controller = controller;\r\n      return $collapse;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsCollapse'],\r\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            if (angular.isArray(modelValue)) {\r\n              // model value is an array, so just replace\r\n              // the active items directly\r\n              bsCollapseCtrl.$setActive(modelValue);\r\n            } else {\r\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\r\n\r\n              if (angular.isArray(activeIndexes)) {\r\n                // we have an array of selected indexes\r\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\r\n                  // item with modelValue index is not active\r\n                  bsCollapseCtrl.$setActive(modelValue * 1);\r\n                }\r\n              } else if (activeIndexes !== modelValue * 1) {\r\n                bsCollapseCtrl.$setActive(modelValue * 1);\r\n              }\r\n            }\r\n            return modelValue;\r\n          });\r\n\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseToggle', function () {\r\n    var KEY_CODES = {\r\n      ENTER: 13,\r\n      SPACE: 32\r\n    };\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base attr\r\n        element.attr('data-toggle', 'collapse');\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerToggle(element);\r\n\r\n        // remove toggle from collapse controller when toggle is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterToggle(element);\r\n        });\r\n\r\n        var actionEventHandler = function () {\r\n          if (!attrs.disabled) {\r\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\r\n            bsCollapseCtrl.$setActive(index * 1);\r\n            scope.$apply();\r\n          }\r\n        };\r\n\r\n        element.on('click', actionEventHandler);\r\n        element.on('keydown keypress', function (e) {\r\n          if (e.which === KEY_CODES.ENTER || e.which === KEY_CODES.SPACE) {\r\n            console.log('key handler handling');\r\n            actionEventHandler();\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseTarget', function ($animate) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      // scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('collapse');\r\n\r\n        // Add animation class\r\n        if (bsCollapseCtrl.$options.animation) {\r\n          element.addClass(bsCollapseCtrl.$options.animation);\r\n        }\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerTarget(element);\r\n\r\n        // remove pane target from collapse controller when target is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterTarget(element);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsCollapseCtrl.$targets.indexOf(element);\r\n          var active = bsCollapseCtrl.$activeIndexes();\r\n          var action = 'removeClass';\r\n          if (angular.isArray(active)) {\r\n            if (active.indexOf(index) !== -1) {\r\n              action = 'addClass';\r\n            }\r\n          } else if (index === active) {\r\n            action = 'addClass';\r\n          }\r\n\r\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: button\\button.js\r\nangular.module('mgcrea.ngStrap.button', [])\r\n\r\n  .provider('$button', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      toggleEvent: 'click'\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckboxGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.attr('bs-checkbox', '');\r\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckbox', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support label > input[type=\"checkbox\"]\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\r\n        if (constantValueRegExp.test(attr.trueValue)) {\r\n          trueValue = scope.$eval(attr.trueValue);\r\n        }\r\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\r\n        if (constantValueRegExp.test(attr.falseValue)) {\r\n          falseValue = scope.$eval(attr.falseValue);\r\n        }\r\n\r\n        // Parse exotic values\r\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\r\n        if (hasExoticValues) {\r\n          controller.$parsers.push(function (viewValue) {\r\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\r\n            return viewValue ? trueValue : falseValue;\r\n          });\r\n          // modelValue -> $formatters -> viewValue\r\n          controller.$formatters.push(function (modelValue) {\r\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            return angular.equals(modelValue, trueValue);\r\n          });\r\n        }\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = !!controller.$viewValue;\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            if (!isInput) {\r\n              controller.$setViewValue(!activeElement.hasClass('active'));\r\n            }\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadioGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\r\n        angular.forEach(children, function (child) {\r\n          angular.element(child).attr('bs-radio', '');\r\n          angular.element(child).attr('ng-model', attr.ngModel);\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadio', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support `label > input[type=\"radio\"]` markup\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var value;\r\n        attr.$observe('value', function (v) {\r\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\r\n            value = scope.$eval(v);\r\n          } else {\r\n            value = v;\r\n          }\r\n          controller.$render();\r\n        });\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = angular.equals(controller.$viewValue, value);\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            controller.$setViewValue(value);\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n\r\n// Source: aside\\aside.js\r\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$aside', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade-and-slide-right',\r\n      prefixClass: 'aside',\r\n      prefixEvent: 'aside',\r\n      placement: 'right',\r\n      templateUrl: 'aside/aside.tpl.html',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true\r\n    };\r\n\r\n    this.$get = function ($modal) {\r\n\r\n      function AsideFactory (config) {\r\n\r\n        var $aside = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $aside = $modal(options);\r\n\r\n        return $aside;\r\n\r\n      }\r\n\r\n      return AsideFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAside', function ($window, $sce, $aside) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAside) {\r\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize aside\r\n        var aside = $aside(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', aside.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (aside) aside.destroy();\r\n          options = null;\r\n          aside = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: alert\\alert.js\r\n// @BUG: following snippet won't compile correctly\r\n\r\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$alert', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'alert',\r\n      prefixEvent: 'alert',\r\n      placement: null,\r\n      templateUrl: 'alert/alert.tpl.html',\r\n      container: false,\r\n      element: null,\r\n      backdrop: false,\r\n      keyboard: true,\r\n      show: true,\r\n      // Specific options\r\n      duration: false,\r\n      type: false,\r\n      dismissable: true,\r\n      focusMeDisabled: false\r\n    };\r\n\r\n    this.$get = function ($modal, $timeout) {\r\n\r\n      function AlertFactory (config) {\r\n\r\n        var $alert = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $alert = $modal(options);\r\n        $alert.returnFocus = function () {\r\n          function findFocusableElements () {\r\n            var containerEl = angular.element($alert.$element).closest('[ng-controller]');\r\n            return containerEl.find('a:not([disabled]),button:not([disabled]),input:not([disabled]),select:not([disabled]),[tabindex]:not([disabled]):not([tabindex=\"-1\"])').filter(function (i, el) {\r\n              return !angular.element(el).parentsUntil(containerEl, '[tabindex=\"-1\"]').length;\r\n            });\r\n          }\r\n\r\n          function findNextFocusableElement () {\r\n            if (document.activeElement) {\r\n              var focusable = findFocusableElements().toArray();\r\n              if (focusable === undefined) return;\r\n              var index = focusable.indexOf(document.activeElement);\r\n              return focusable[index + 1];\r\n            }\r\n          }\r\n          angular.element(findNextFocusableElement()).trigger('focus');\r\n        };\r\n\r\n        // Support scope as string options [/*title, content, */ type, dismissable]\r\n        $alert.$scope.dismissable = !!options.dismissable;\r\n        if (options.type) {\r\n          $alert.$scope.type = options.type;\r\n        }\r\n        if (options.focusMeDisabled) {\r\n          $alert.$scope.focusMeDisabled = options.focusMeDisabled;\r\n        }\r\n\r\n        // Support auto-close duration\r\n        var show = $alert.show;\r\n        if (options.duration) {\r\n          $alert.show = function () {\r\n            show();\r\n            $timeout(function () {\r\n              $alert.hide();\r\n            }, options.duration * 1000);\r\n          };\r\n        }\r\n\r\n        return $alert;\r\n\r\n      }\r\n\r\n      return AlertFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAlert', function ($window, $sce, $alert) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content', 'type'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAlert) {\r\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize alert\r\n        var alert = $alert(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', alert.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (alert) alert.destroy();\r\n          options = null;\r\n          alert = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n\r\n// Source: affix\\affix.js\r\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\r\n\r\n  .provider('$affix', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      offsetTop: 'auto',\r\n      inlineStyles: true,\r\n      setWidth: true\r\n    };\r\n\r\n    this.$get = function ($window, debounce, dimensions) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var windowEl = angular.element($window);\r\n\r\n      function AffixFactory (element, config) {\r\n\r\n        var $affix = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        var targetEl = options.target;\r\n\r\n        // Initial private vars\r\n        var reset = 'affix affix-top affix-bottom';\r\n        var setWidth = false;\r\n        var initialAffixTop = 0;\r\n        var initialOffsetTop = 0;\r\n        var offsetTop = 0;\r\n        var offsetBottom = 0;\r\n        var affixed = null;\r\n        var unpin = null;\r\n\r\n        var parent = element.parent();\r\n        // Options: custom parent\r\n        if (options.offsetParent) {\r\n          if (options.offsetParent.match(/^\\d+$/)) {\r\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\r\n              parent = parent.parent();\r\n            }\r\n          } else {\r\n            parent = angular.element(options.offsetParent);\r\n          }\r\n        }\r\n\r\n        $affix.init = function () {\r\n\r\n          this.$parseOffsets();\r\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\r\n          setWidth = options.setWidth && !element[0].style.width;\r\n\r\n          // Bind events\r\n          targetEl.on('scroll', this.checkPosition);\r\n          targetEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', this.$debouncedOnResize);\r\n\r\n          // Both of these checkPosition() calls are necessary for the case where\r\n          // the user hits refresh after scrolling to the bottom of the page.\r\n          this.checkPosition();\r\n          this.checkPositionWithEventLoop();\r\n\r\n        };\r\n\r\n        $affix.destroy = function () {\r\n\r\n          // Unbind events\r\n          targetEl.off('scroll', this.checkPosition);\r\n          targetEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', this.$debouncedOnResize);\r\n\r\n        };\r\n\r\n        $affix.checkPositionWithEventLoop = function () {\r\n\r\n          // IE 9 throws an error if we use 'this' instead of '$affix'\r\n          // in this setTimeout call\r\n          setTimeout($affix.checkPosition, 1);\r\n\r\n        };\r\n\r\n        $affix.checkPosition = function () {\r\n          // if (!this.$element.is(':visible')) return\r\n\r\n          var scrollTop = getScrollTop();\r\n          var position = dimensions.offset(element[0]);\r\n          var elementHeight = dimensions.height(element[0]);\r\n\r\n          // Get required affix class according to position\r\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\r\n\r\n          // Did affix status changed this last check?\r\n          if (affixed === affix) return;\r\n          affixed = affix;\r\n\r\n          if (affix === 'top') {\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', '');\r\n            }\r\n          } else if (affix === 'bottom') {\r\n            if (options.offsetUnpin) {\r\n              unpin = -(options.offsetUnpin * 1);\r\n            } else {\r\n              // Calculate unpin threshold when affixed to bottom.\r\n              // Hopefully the browser scrolls pixel by pixel.\r\n              unpin = position.top - scrollTop;\r\n            }\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\r\n            }\r\n          } else { // affix === 'middle'\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', element[0].offsetWidth + 'px');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', 'fixed');\r\n              element.css('top', initialAffixTop + 'px');\r\n            }\r\n          }\r\n\r\n          // Add proper affix class\r\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\r\n\r\n        };\r\n\r\n        $affix.$onResize = function () {\r\n          $affix.$parseOffsets();\r\n          $affix.checkPosition();\r\n        };\r\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\r\n\r\n        $affix.$parseOffsets = function () {\r\n          var initialPosition = element[0].style.position;\r\n          var initialTop = element[0].style.top;\r\n          // Reset position to calculate correct offsetTop\r\n          if (options.inlineStyles) {\r\n            element.css('position', (options.offsetParent) ? '' : 'relative');\r\n            element.css('top', '');\r\n          }\r\n\r\n          if (options.offsetTop) {\r\n            if (options.offsetTop === 'auto') {\r\n              options.offsetTop = '+0';\r\n            }\r\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\r\n              initialAffixTop = - options.offsetTop * 1;\r\n              if (options.offsetParent) {\r\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\r\n              } else {\r\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\r\n              }\r\n            } else {\r\n              offsetTop = options.offsetTop * 1;\r\n            }\r\n          }\r\n\r\n          if (options.offsetBottom) {\r\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\r\n              // add 1 pixel due to rounding problems...\r\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\r\n            } else {\r\n              offsetBottom = options.offsetBottom * 1;\r\n            }\r\n          }\r\n\r\n          // Bring back the element's position after calculations\r\n          if (options.inlineStyles) {\r\n            element.css('position', initialPosition);\r\n            element.css('top', initialTop);\r\n          }\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\r\n          var scrollTop = getScrollTop();\r\n          var scrollHeight = getScrollHeight();\r\n\r\n          if (scrollTop <= offsetTop) {\r\n            return 'top';\r\n          } else if (_unpin !== null) {\r\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\r\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\r\n            return 'bottom';\r\n          }\r\n          return 'middle';\r\n        }\r\n\r\n        function getScrollTop () {\r\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\r\n        }\r\n\r\n        function getScrollHeight () {\r\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\r\n        }\r\n\r\n        $affix.init();\r\n        return $affix;\r\n\r\n      }\r\n\r\n      return AffixFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffix', function ($affix, $window, $timeout) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: '^?bsAffixTarget',\r\n      link: function postLink (scope, element, attr, affixTarget) {\r\n\r\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\r\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            var option = attr[key];\r\n            if (/true/i.test(option)) option = true;\r\n            if (/false/i.test(option)) option = false;\r\n            options[key] = option;\r\n          }\r\n        });\r\n\r\n        var affix;\r\n        $timeout(function () { affix = $affix(element, options); });\r\n        scope.$on('$destroy', function () {\r\n          if (affix) affix.destroy();\r\n          options = null;\r\n          affix = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffixTarget', function () {\r\n    return {\r\n      controller: function ($element) {\r\n        this.$element = $element;\r\n      }\r\n    };\r\n  });\r\n\r\n// Source: module.js\r\nangular.module('mgcrea.ngStrap', [\r\n  'mgcrea.ngStrap.modal',\r\n  'mgcrea.ngStrap.aside',\r\n  'mgcrea.ngStrap.alert',\r\n  'mgcrea.ngStrap.button',\r\n  'mgcrea.ngStrap.select',\r\n  'mgcrea.ngStrap.datepicker',\r\n  'mgcrea.ngStrap.timepicker',\r\n  'mgcrea.ngStrap.navbar',\r\n  'mgcrea.ngStrap.tooltip',\r\n  'mgcrea.ngStrap.popover',\r\n  'mgcrea.ngStrap.dropdown',\r\n  'mgcrea.ngStrap.typeahead',\r\n  'mgcrea.ngStrap.scrollspy',\r\n  'mgcrea.ngStrap.affix',\r\n  'mgcrea.ngStrap.tab',\r\n  'mgcrea.ngStrap.collapse'\r\n]);\r\n\r\n})(window, document);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$typeahead', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'typeahead',\r\n      prefixEvent: '$typeahead',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'typeahead/typeahead.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      minLength: 1,\r\n      filter: 'bsAsyncFilter',\r\n      limit: 6,\r\n      autoSelect: false,\r\n      comparator: '',\r\n      trimValue: true,\r\n      translations: null,\r\n      feedbackId: '',\r\n      selectedProperty: ''\r\n    };\r\n\r\n    var KEY_CODES = {\r\n      downArrow: 40,\r\n      enter: 13,\r\n      escape: 27,\r\n      upArrow: 38,\r\n      tab: 9\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\r\n\r\n      function TypeaheadFactory (element, controller, config) {\r\n\r\n        var $typeahead = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $typeahead = $tooltip(element, options);\r\n\r\n        var parentScope = config.scope;\r\n        var scope = $typeahead.$scope;\r\n        scope.id = options.id;\r\n\r\n        scope.$resetMatches = function () {\r\n          scope.$matches = [];\r\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\r\n        };\r\n        scope.$resetMatches();\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $typeahead.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $typeahead.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function isActive (index) {\r\n          return scope.$activeIndex === index ? true : undefined;\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $typeahead.update = function (matches) {\r\n          scope.$matches = matches;\r\n          if (scope.$activeIndex >= matches.length) {\r\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\r\n          }\r\n\r\n          // wrap in a $timeout so the results are updated\r\n          // before repositioning\r\n          safeDigest(scope);\r\n          $$rAF($typeahead.$applyPlacement);\r\n        };\r\n\r\n        $typeahead.activate = function (index) {\r\n          scope.$activeIndex = index;\r\n        };\r\n\r\n        $typeahead.select = function (index) {\r\n          if (index === -1) return;\r\n          var value = scope.$matches[index].value;\r\n          if (typeof value === 'object' && options.selectedProperty !== void 0 && options.selectedProperty.length > 0) {\r\n            controller.$setViewValue(value[options.selectedProperty]);\r\n          } else {\r\n            controller.$setViewValue(value);\r\n          }\r\n          // console.log('$setViewValue', value);\r\n          controller.$render();\r\n          scope.$resetMatches();\r\n          if (parentScope) parentScope.$digest();\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $typeahead);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $typeahead.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return !!scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        scope.$generateResultId = function (index) {\r\n          return scope.id ? scope.id + '_typeahead_result_' + index : undefined;\r\n        };\r\n\r\n        $typeahead.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $typeahead.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        };\r\n\r\n        $typeahead.$$updateScrollTop = function (container, index) {\r\n          if (index > -1 && index < container.children.length) {\r\n            var active = container.children[index];\r\n            var clientTop = active.offsetTop;\r\n            var clientBottom = active.offsetTop + active.clientHeight;\r\n            var highWatermark = container.scrollTop;\r\n            var lowWatermark = container.scrollTop + container.clientHeight;\r\n\r\n            // active entry overlaps top border\r\n            if (clientBottom >= highWatermark && clientTop < highWatermark) {\r\n              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);\r\n            } else if (clientBottom > lowWatermark) {\r\n              // top of active element is invisible because it's below the bottom of the visible container window\r\n              container.scrollTop = clientTop;\r\n            }\r\n          }\r\n        };\r\n\r\n        $typeahead.$onKeyDown = function (evt) {\r\n          // If the key code isn't up arrow, down arrow, or enter return.\r\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\r\n\r\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\r\n          if ($typeahead.$isVisible() && !(evt.keyCode === KEY_CODES.enter && scope.$activeIndex === -1)) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // Select with enter\r\n          if (evt.keyCode === KEY_CODES.enter && scope.$matches.length) {\r\n            $typeahead.select(scope.$activeIndex);\r\n            // Navigate with keyboard\r\n          } else if (evt.keyCode === KEY_CODES.upArrow && scope.$activeIndex > 0) {\r\n            scope.$activeIndex--;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if (evt.keyCode === KEY_CODES.downArrow && scope.$activeIndex < scope.$matches.length - 1) {\r\n            scope.$activeIndex++;\r\n            setAriaActiveDescendant(scope.$activeIndex);\r\n            angular.element(document.getElementById(options.id + '_sr_text')).html(scope.$matches[scope.$activeIndex].label);\r\n          } else if ((evt.keyCode === KEY_CODES.upArrow && scope.$activeIndex === 0) || (evt.keyCode === KEY_CODES.downArrow && scope.$activeIndex === scope.$matches.length - 1)) {\r\n            scope.$activeIndex = -1;\r\n            var ele = '#' + evt.currentTarget.id;\r\n            // position the cursor after the last letter of the selected item inside the control to allow the user to easily delete the selection if desired\r\n            angular.element(ele).val('').val(controller.$viewValue);\r\n            angular.element(ele).focus();\r\n          } else if (angular.isUndefined(scope.$activeIndex)) {\r\n            scope.$activeIndex = 0;\r\n            setAriaActiveDescendant();\r\n          }\r\n\r\n          // update scrollTop property on $typeahead when scope.$activeIndex is not in visible area\r\n          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);\r\n          scope.$digest();\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $typeahead.show;\r\n        $typeahead.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed immediately.\r\n          $timeout(function () {\r\n            if ($typeahead.$element) {\r\n              if (options.id) {\r\n                // Set the id on the \"dropdown\" component of the typeahead. The input should \"control\" this element.\r\n                $typeahead.$element.attr('id', options.id + '_listbox');\r\n                element.attr('aria-controls', options.id + '_listbox');\r\n\r\n                var assertDiv = document.getElementById(options.id + '_sr_text');\r\n                if (!assertDiv) {\r\n                  $typeahead.$element.parent().append('<div id=\"' + options.id + '_sr_text\" aria-live=\"assertive\" style=\"position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0;\"></div>');\r\n                }\r\n              }\r\n\r\n              // If the input was given an aria-labelledby attribute apply it to the \"dropdown\" component.\r\n              $typeahead.$element.attr('aria-labelledby', options.ariaLabelledby);\r\n\r\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\r\n              if (options.keyboard) {\r\n                // event for the element that we attach is added to event queue\r\n                // before pushing the same event more that once for the same element, event need to detach\r\n                // list item jumps happening in search list for this setted keydown off\r\n                if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var hide = $typeahead.hide;\r\n        $typeahead.hide = function () {\r\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\r\n          }\r\n          if (!options.autoSelect) {\r\n            $typeahead.activate(-1);\r\n          }\r\n\r\n          var assertDiv = document.getElementById(options.id + '_sr_text');\r\n          angular.element(assertDiv).remove();\r\n\r\n          setAriaActiveDescendant();\r\n\r\n          hide();\r\n        };\r\n\r\n        var onKeyUp = $typeahead.$onKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape && $typeahead.$isShown) {\r\n            $typeahead.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        var onFocusKeyUp = $typeahead.$onFocusKeyUp; // eslint-disable-line no-unused-vars\r\n        $typeahead.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === KEY_CODES.escape) {\r\n            // Feedback message handling as per SS-25684 and SS-11481\r\n            if (options.feedbackId !== void 0 && options.translations !== void 0) {\r\n              var translations = angular.fromJson(options.translations);\r\n              var element = document.getElementById(options.feedbackId);\r\n              if ($typeahead.$scope.$matches !== void 0 && $typeahead.$scope.$matches.length > 0) {\r\n                angular.element(element).text(translations.selectResultText);\r\n              }\r\n              // $typeahead.hide();\r\n              // evt.stopPropagation();\r\n            }\r\n          }\r\n        };\r\n\r\n        // Helper functions within this closure\r\n\r\n        function setAriaActiveDescendant (index) {\r\n          if (index === undefined || !scope.id) {\r\n            element.removeAttr('aria-activedescendant');\r\n          } else {\r\n            var resultId = scope.$generateResultId(index);\r\n            if (resultId) {\r\n              element.attr('aria-activedescendant', resultId);\r\n            } else {\r\n              element.removeAttr('aria-activedescendant');\r\n            }\r\n          }\r\n        }\r\n\r\n        return $typeahead;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      TypeaheadFactory.defaults = defaults;\r\n      return TypeaheadFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .filter('bsAsyncFilter', function ($filter) {\r\n    return function (array, expression, comparator) {\r\n      if (array && angular.isFunction(array.then)) {\r\n        return array.then(function (results) {\r\n          return $filter('filter')(results, expression, comparator);\r\n        });\r\n      }\r\n      return $filter('filter')(array, expression, comparator);\r\n    };\r\n  })\r\n\r\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\r\n\r\n    var defaults = $typeahead.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Fixes firefox bug when using objects in model with typeahead\r\n        // Yes this breaks any other directive using a 'change' event on this input,\r\n        // but if it is using the 'change' event why is it used with typeahead?\r\n        element.off('change');\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass', 'ariaLabelledby', 'translations', 'feedbackId', 'selectedProperty'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'trimValue', 'filter'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Disable browser autocompletion\r\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\r\n\r\n        // Build proper bsOptions\r\n        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;\r\n        var limit = options.limit || defaults.limit;\r\n        var comparator = options.comparator || defaults.comparator;\r\n\r\n        var bsOptions = attr.bsOptions;\r\n        if (filter) {\r\n          bsOptions += ' | ' + filter + ':$viewValue';\r\n          if (comparator) bsOptions += ':' + comparator;\r\n        }\r\n        if (limit) bsOptions += ' | limitTo:' + limit;\r\n        var parsedOptions = $parseOptions(bsOptions);\r\n\r\n        // Initialize typeahead\r\n        var typeahead = $typeahead(element, controller, options);\r\n\r\n        if (!element.attr('aria-autocomplete') && !bsOptions.templateUrl) {\r\n          // Per draft spec for a combobox element the aria-auto complete should be set to a list.\r\n          element.attr('aria-autocomplete', 'list');\r\n        }\r\n\r\n        // Watch options on demand\r\n        if (options.watchOptions) {\r\n          // Watch bsOptions values before filtering for changes, drop function calls\r\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\r\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\r\n              typeahead.update(values);\r\n              controller.$render();\r\n            });\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('$watch', element.attr('ng-model'), newValue);\r\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\r\n          parsedOptions.valuesFn(scope, controller)\r\n            .then(function (values) {\r\n              // Prevent input with no future prospect if selectMode is truthy\r\n              // @TODO test selectMode\r\n              if (options.selectMode && !values.length && newValue.length > 0) {\r\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\r\n                return;\r\n              }\r\n              if (values.length > limit) values = values.slice(0, limit);\r\n              typeahead.update(values);\r\n              // Queue a new rendering that will leverage collection loading\r\n              controller.$render();\r\n            });\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var displayValue = parsedOptions.displayValue(modelValue);\r\n\r\n          // If we can determine the displayValue, use that\r\n          if (displayValue) {\r\n            return displayValue;\r\n          }\r\n\r\n          // If there's no display value, attempt to use the modelValue.\r\n          // If the model is an object not much we can do\r\n          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {\r\n            return modelValue;\r\n          }\r\n          return '';\r\n        });\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          if (controller.$isEmpty(controller.$viewValue)) {\r\n            // Feedback message handling as per SS-25684 and SS-11481\r\n            setFeedbackMessage('');\r\n            return element.val('');\r\n          }\r\n          var index = typeahead.$getIndex(controller.$modelValue);\r\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\r\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\r\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\r\n          var ss = element[0].selectionStart;\r\n          var sd = element[0].selectionEnd;\r\n          element.val(options.trimValue === false ? value : value.trim());\r\n          element[0].setSelectionRange(ss, sd);\r\n\r\n          // Feedback message handling as per SS-25684 and SS-11481\r\n          if (options.translations !== void 0) {\r\n            // Clear feedback element contents\r\n            setFeedbackMessage('');\r\n\r\n            if (typeahead.$scope.$matches !== void 0) {\r\n              var translations = angular.fromJson(options.translations);\r\n              if (typeahead.$scope.$matches.length > 0) {\r\n                setFeedbackMessage(typeahead.$scope.$matches.length + ' ' + translations.resultsText);\r\n              } else {\r\n                setFeedbackMessage(translations.noResultsText);\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        // Feedback message handling as per SS-25684 and SS-11481\r\n        element.on('keydown', function (evt) {\r\n          if (evt.which === 9) {\r\n            evt.preventDefault();\r\n            if (options.translations !== void 0) {\r\n              var translations = angular.fromJson(options.translations);\r\n              if (typeahead.$scope.$matches.length > 0) {\r\n                setFeedbackMessage(translations.selectResultText);\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          element.off('keydown');\r\n          if (typeahead) typeahead.destroy();\r\n          options = null;\r\n          typeahead = null;\r\n        });\r\n\r\n        function setFeedbackMessage (message) {\r\n          if (options.feedbackId !== void 0) {\r\n            var element = document.getElementById(options.feedbackId);\r\n            angular.element(element).text(message);\r\n          }\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\r\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\r\n\r\nangular.module('mgcrea.ngStrap.core', [])\r\n  .service('$bsCompiler', bsCompilerService);\r\n\r\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\r\n\r\n  /*\r\n   * @ngdoc service\r\n   * @name $bsCompiler\r\n   * @module material.core\r\n   * @description\r\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\r\n   * to easily compile an element with a templateUrl, controller, and locals.\r\n   *\r\n   * @usage\r\n   * <hljs lang=\"js\">\r\n   * $bsCompiler.compile({\r\n   *   templateUrl: 'modal.html',\r\n   *   controller: 'ModalCtrl',\r\n   *   locals: {\r\n   *     modal: myModalInstance;\r\n   *   }\r\n   * }).then(function(compileData) {\r\n   *   compileData.element; // modal.html's template in an element\r\n   *   compileData.link(myScope); //attach controller & scope to element\r\n   * });\r\n   * </hljs>\r\n   */\r\n\r\n   /*\r\n    * @ngdoc method\r\n    * @name $bsCompiler#compile\r\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\r\n    * locals, and scope.\r\n    * @param {object} options An options object, with the following properties:\r\n    *\r\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\r\n    *      newly created scope or the name of a registered controller if passed as a string.\r\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\r\n    *      published to scope under the `controllerAs` name.\r\n    *    - `template` - `{string=}` An html template as a string.\r\n    *    - `templateUrl` - `{string=}` A path to an html template.\r\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\r\n    *      it is loaded. It will be given the template string as a parameter, and should\r\n    *      return a a new string representing the transformed template.\r\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\r\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\r\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\r\n    *      instantiated `compile()` will fail..\r\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\r\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\r\n    *        Otherwise if function, then it is injected and the return value is treated as the\r\n    *        dependency. If the result is a promise, it is resolved before its value is\r\n    *        injected into the controller.\r\n    *\r\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\r\n    * `compileData` has the following properties:\r\n    *\r\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\r\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\r\n    *     the element and instantiate the provided controller (if given).\r\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\r\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\r\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\r\n    */\r\n  this.compile = function (options) {\r\n\r\n    if (options.template && /\\.html$/.test(options.template)) {\r\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\r\n      options.templateUrl = options.template;\r\n      options.template = '';\r\n    }\r\n\r\n    var templateUrl = options.templateUrl;\r\n    var template = options.template || '';\r\n    var controller = options.controller;\r\n    var controllerAs = options.controllerAs;\r\n    var resolve = options.resolve || {};\r\n    var locals = options.locals || {};\r\n    var transformTemplate = options.transformTemplate || angular.identity;\r\n    var bindToController = options.bindToController;\r\n\r\n    // Take resolve values and invoke them.\r\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\r\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\r\n    angular.forEach(resolve, function (value, key) {\r\n      if (angular.isString(value)) {\r\n        resolve[key] = $injector.get(value);\r\n      } else {\r\n        resolve[key] = $injector.invoke(value);\r\n      }\r\n    });\r\n    // Add the locals, which are just straight values to inject\r\n    // eg locals: { three: 3 }, will inject three into the controller\r\n    angular.extend(resolve, locals);\r\n\r\n    if (template) {\r\n      resolve.$template = $q.when(template);\r\n    } else if (templateUrl) {\r\n      resolve.$template = fetchTemplate(templateUrl);\r\n    } else {\r\n      throw new Error('Missing `template` / `templateUrl` option.');\r\n    }\r\n\r\n    if (options.titleTemplate) {\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          findElement('[ng-bind=\"title\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    if (options.contentTemplate) {\r\n      // TODO(mgcrea): deprecate?\r\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\r\n        .then(function (templates) {\r\n          var templateEl = angular.element(templates[0]);\r\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\r\n            .removeAttr('ng-bind')\r\n            .html(templates[1]);\r\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\r\n          if (!options.templateUrl) contentEl.next().remove();\r\n          return templateEl[0].outerHTML;\r\n        });\r\n    }\r\n\r\n    // Wait for all the resolves to finish if they are promises\r\n    return $q.all(resolve).then(function (locals) {\r\n\r\n      var template = transformTemplate(locals.$template);\r\n      if (options.html) {\r\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\r\n      }\r\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\r\n      var element = angular.element('<div>').html(template.trim()).contents();\r\n      var linkFn = $compile(element);\r\n\r\n      // Return a linking function that can be used later when the element is ready\r\n      return {\r\n        locals: locals,\r\n        element: element,\r\n        link: function link (scope) {\r\n          locals.$scope = scope;\r\n\r\n          // Instantiate controller if it exists, because we have scope\r\n          if (controller) {\r\n            var invokeCtrl = $controller(controller, locals, true);\r\n            if (bindToController) {\r\n              angular.extend(invokeCtrl.instance, locals);\r\n            }\r\n            // Support angular@~1.2 invokeCtrl\r\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\r\n            // See angular-route source for this logic\r\n            element.data('$ngControllerController', ctrl);\r\n            element.children().data('$ngControllerController', ctrl);\r\n\r\n            if (controllerAs) {\r\n              scope[controllerAs] = ctrl;\r\n            }\r\n          }\r\n\r\n          return linkFn.apply(null, arguments);\r\n        }\r\n      };\r\n    });\r\n\r\n  };\r\n\r\n  function findElement (query, element) {\r\n    return angular.element((element || document).querySelectorAll(query));\r\n  }\r\n\r\n  var fetchPromises = {};\r\n  function fetchTemplate (template) {\r\n    if (fetchPromises[template]) return fetchPromises[template];\r\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\r\n      .then(function (res) {\r\n        return res.data;\r\n      }));\r\n  }\r\n\r\n}\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$modal', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      backdropAnimation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'modal',\r\n      prefixEvent: 'modal',\r\n      placement: 'top',\r\n      templateUrl: 'modal/modal.tpl.html',\r\n      template: '',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true,\r\n      size: null,\r\n      zIndex: null,\r\n      containerElement: null\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\r\n\r\n      var forEach = angular.forEach;\r\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n      var bodyElement = angular.element($window.document.body);\r\n\r\n      var layoutHideElement = angular.element('#layoutContainer');\r\n\r\n      var backdropCount = 0;\r\n      var dialogBaseZindex = 1050;\r\n      var backdropBaseZindex = 1040;\r\n\r\n      var validSizes = {\r\n        lg: 'modal-lg',\r\n        sm: 'modal-sm'\r\n      };\r\n\r\n      function ModalFactory (config) {\r\n\r\n        var $modal = {};\r\n\r\n        // Common vars\r\n        var options = $modal.$options = angular.extend({}, defaults, config);\r\n\r\n        var promise = $modal.$promise = $bsCompiler.compile(options);\r\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        if (options.containerElement) {\r\n          layoutHideElement = angular.element(options.containerElement);\r\n        }\r\n        if (!options.element && !options.container) {\r\n          options.container = 'body';\r\n        }\r\n\r\n        if (options.zIndex) {\r\n          dialogBaseZindex = parseInt(options.zIndex, 10);\r\n          backdropBaseZindex = dialogBaseZindex - 10;\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\r\n\r\n        $modal.returnFocus = function () {\r\n\r\n        };\r\n\r\n        // Support scope as string options\r\n        forEach(['title', 'content'], function (key) {\r\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\r\n        });\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $modal.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $modal.$isShown = scope.$isShown = false;\r\n\r\n        // Fetch, compile then initialize modal\r\n        var compileData;\r\n        var modalElement;\r\n        var modalScope;\r\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\r\n        backdropElement.css({\r\n          position: 'fixed',\r\n          top: '0px',\r\n          left: '0px',\r\n          bottom: '0px',\r\n          right: '0px'\r\n        });\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $modal.init();\r\n        });\r\n\r\n        $modal.init = function () {\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              $modal.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $modal.destroy = function () {\r\n\r\n          // Remove element\r\n          destroyModalElement();\r\n\r\n          // remove backdrop element\r\n          if (backdropElement) {\r\n            backdropElement.remove();\r\n            backdropElement = null;\r\n          }\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n        };\r\n\r\n        $modal.show = function () {\r\n          if ($modal.$isShown) return;\r\n\r\n          var parent;\r\n          var after;\r\n          if (angular.isElement(options.container)) {\r\n            parent = options.container;\r\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\r\n          } else {\r\n            if (options.container) {\r\n              parent = findElement(options.container);\r\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\r\n            } else {\r\n              parent = null;\r\n              after = options.element;\r\n            }\r\n          }\r\n\r\n          // destroy any existing modal elements\r\n          if (modalElement) destroyModalElement();\r\n\r\n          // create a new scope, so we can destroy it and all child scopes\r\n          // when destroying the modal element\r\n          modalScope = $modal.$scope.$new();\r\n          // Fetch a cloned element linked from template (noop callback is required)\r\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\r\n\r\n          if (options.backdrop) {\r\n            // set z-index\r\n            modalElement.css({\r\n              'z-index': dialogBaseZindex + (backdropCount * 20)\r\n            });\r\n            backdropElement.css({\r\n              'z-index': backdropBaseZindex + (backdropCount * 20)\r\n            });\r\n\r\n            // increment number of backdrops\r\n            backdropCount++;\r\n          }\r\n\r\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($modal);\r\n          }\r\n\r\n          // Set the initial positioning.\r\n          modalElement.css({\r\n            display: 'block'\r\n          }).addClass(options.placement);\r\n\r\n          // Options: customClass\r\n          if (options.customClass) {\r\n            modalElement.addClass(options.customClass);\r\n          }\r\n\r\n          // Options: size\r\n          if (options.size && validSizes[options.size]) {\r\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\r\n          }\r\n\r\n          // Options: animation\r\n          if (options.animation) {\r\n            if (options.backdrop) {\r\n              backdropElement.addClass(options.backdropAnimation);\r\n            }\r\n            modalElement.addClass(options.animation);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            $animate.enter(backdropElement, bodyElement, null);\r\n          }\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n\r\n          $modal.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          // Focus once the enter-animation has started\r\n          // Weird PhantomJS bug hack\r\n          var el = modalElement[0];\r\n          requestAnimationFrame(function () {\r\n            el.focus();\r\n          });\r\n\r\n          bodyElement.addClass(options.prefixClass + '-open');\r\n\r\n          layoutHideElement.attr('aria-hidden', 'true');\r\n\r\n          if (options.animation) {\r\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n\r\n          // Bind events\r\n          bindBackdropEvents();\r\n          bindKeyboardEvents();\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $modal);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'false');\r\n          modalElement.attr('tabindex', '0');\r\n          modalElement.trigger('focus');\r\n          if (!modalElement.length || !angular.element(modalElement[0]).hasClass('modal')) {\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n            unbindKeyboardEvents();\r\n          }\r\n\t\t  if(angular.element(modalElement[0]).hasClass('alert')) {\r\n\t\t\t  modalElement.removeAttr('tabindex');\r\n\t\t  }\r\n        }\r\n\r\n        $modal.hide = function () {\r\n          if (!$modal.$isShown) return;\r\n\r\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\r\n            return;\r\n          }\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($modal);\r\n          }\r\n\r\n          modalElement.attr('aria-hidden', 'true');\r\n\r\n          if ($modal.returnFocus && typeof $modal.returnFocus === 'function') $modal.returnFocus();\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.leave(modalElement, leaveAnimateCallback);\r\n          } else {\r\n            $animate.leave(modalElement).then(leaveAnimateCallback);\r\n          }\r\n\r\n          if (options.backdrop) {\r\n            // decrement number of backdrops\r\n            backdropCount--;\r\n            $animate.leave(backdropElement);\r\n          }\r\n          $modal.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          unbindBackdropEvents();\r\n          unbindKeyboardEvents();\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $modal);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($modal);\r\n          }\r\n          if (findElement('.modal').length <= 0) {\r\n            bodyElement.removeClass(options.prefixClass + '-open');\r\n            layoutHideElement.attr('aria-hidden', 'false');\r\n          }\r\n          if (options.animation) {\r\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\r\n          }\r\n        }\r\n\r\n        function findFocusableElements () {\r\n          // Add all elements we want to include in our selection\r\n          var focusableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), [tabindex]:not([disabled]):not([tabindex=\"-1\"])';\r\n          if (document.activeElement) {\r\n            var focusable = Array.prototype.filter.call(modalElement[0].querySelectorAll(focusableElements),\r\n              function (element) {\r\n                // Check for visibility while always include the current activeElement\r\n                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement;\r\n              });\r\n\r\n            return focusable;\r\n          }\r\n        }\r\n\r\n        function findNextFocusableElement (inReverse) {\r\n          if (document.activeElement) {\r\n            var focusable = findFocusableElements();\r\n            if (focusable === undefined) return;\r\n            if (inReverse) {\r\n              focusable = Array.prototype.reverse.call(focusable);\r\n            }\r\n\r\n            var index = focusable.indexOf(document.activeElement);\r\n            return focusable[index + 1];\r\n          }\r\n        }\r\n\r\n        $modal.toggle = function () {\r\n          if ($modal.$isShown) {\r\n            $modal.hide();\r\n          } else {\r\n            $modal.show();\r\n          }\r\n        };\r\n\r\n        $modal.focus = function () {\r\n          modalElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $modal.$onKeyUp = function (evt) {\r\n\r\n          // Escape was pressed on an open modal. Hide it.  Backspace key, nothing happen.\r\n          if ((evt.which === 8 || evt.which === 27) && $modal.$isShown) {\r\n            if (evt.which === 27) {\r\n              $modal.hide();\r\n            }\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $modal.$onKeyDown = function (evt) {\r\n          if (options.keyboard) {\r\n            if (evt.keyCode === 8 && evt.target.tagName !== 'TEXTAREA' && evt.target.tagName !== 'INPUT') {\r\n              evt.preventDefault();\r\n            }\r\n\r\n            if (evt.keyCode === 9) {\r\n\r\n              var nextFocusable = findNextFocusableElement(evt.shiftKey);\r\n              if (nextFocusable === undefined) {\r\n                if (evt.preventDefault) evt.preventDefault();\r\n                if (evt.stopPropagation) evt.stopPropagation();\r\n\r\n                var focusable = findFocusableElements();\r\n                if (evt.shiftKey) {\r\n                  focusable[focusable.length - 1].focus();\r\n                } else {\r\n                  focusable[0].focus();\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        function bindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('click', hideOnBackdropClick);\r\n            backdropElement.on('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function unbindBackdropEvents () {\r\n          if (options.backdrop) {\r\n            modalElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('click', hideOnBackdropClick);\r\n            backdropElement.off('wheel', preventEventDefault);\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.on('keyup', $modal.$onKeyUp);\r\n            modalElement.on('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.keyboard) {\r\n            modalElement.off('keyup', $modal.$onKeyUp);\r\n            modalElement.off('keydown', $modal.$onKeyDown);\r\n          }\r\n        }\r\n\r\n        // Private helpers\r\n\r\n        function hideOnBackdropClick (evt) {\r\n          if (evt.target !== evt.currentTarget) return;\r\n          if (options.backdrop === 'static') {\r\n            $modal.focus();\r\n          } else {\r\n            $modal.hide();\r\n          }\r\n        }\r\n\r\n        function preventEventDefault (evt) {\r\n          evt.preventDefault();\r\n        }\r\n\r\n        function destroyModalElement () {\r\n          if ($modal.$isShown && modalElement !== null) {\r\n            // un-bind events\r\n            unbindBackdropEvents();\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (modalScope) {\r\n            modalScope.$destroy();\r\n            modalScope = null;\r\n          }\r\n\r\n          if (modalElement) {\r\n            modalElement.remove();\r\n            modalElement = $modal.$element = null;\r\n          }\r\n        }\r\n\r\n        return $modal;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return ModalFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsModal', function ($window, $sce, $parse, $modal) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope,\r\n          element: element,\r\n          show: false\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Options: alias modalClass to customClass\r\n        if (options.modalClass) {\r\n          options.customClass = options.modalClass;\r\n        }\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsModal) {\r\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize modal\r\n        var modal = $modal(options);\r\n\r\n        if (options.keyboard) {\r\n          modal.returnFocus = function () {\r\n            element[0].focus();\r\n          };\r\n        }\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', modal.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (modal) modal.destroy();\r\n          options = null;\r\n          modal = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      titleTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      mouseDownPreventDefault: true,\r\n      mouseDownStopPropagation: true,\r\n      viewport: {\r\n        selector: 'body',\r\n        padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory (element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        // var nodeName = element[0].nodeName.toLowerCase();\r\n        if (options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if (options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function (isEnabled) {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function () {\r\n          scope.$$postDigest(function () {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout;\r\n        var hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData;\r\n        var tipElement;\r\n        var tipContainer;\r\n        var tipScope;\r\n        promise.then(function (data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function () {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if (options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if (angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if (options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if (options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if (options.show) {\r\n            scope.$$postDigest(function () {\r\n              if (options.trigger === 'focus') {\r\n                element[0].focus();\r\n              } else {\r\n                $tooltip.show();\r\n              }\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function () {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function () {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\r\n            options.onBeforeShow($tooltip);\r\n          }\r\n          var parent;\r\n          var after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if (tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if (options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if (options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          if (after) {\r\n            after.after(tipElement);\r\n          } else {\r\n            parent.prepend(tipElement);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if (angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if (tipElement) tipElement.css({visibility: 'visible'});\r\n\r\n            // Bind events\r\n            if (options.keyboard) {\r\n              if (options.trigger !== 'focus') {\r\n                $tooltip.focus();\r\n              }\r\n              bindKeyboardEvents();\r\n            }\r\n          });\r\n\r\n          if (options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\r\n            options.onShow($tooltip);\r\n          }\r\n        }\r\n\r\n        $tooltip.leave = function () {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function (blur) {\r\n\r\n          if (!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\r\n            options.onBeforeHide($tooltip);\r\n          }\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          if (tipElement !== null) {\r\n            // Support v1.2+ $animate\r\n            // https://github.com/angular/angular.js/issues/11713\r\n            if (angular.version.minor <= 2) {\r\n              $animate.leave(tipElement, leaveAnimateCallback);\r\n            } else {\r\n              $animate.leave(tipElement).then(leaveAnimateCallback);\r\n            }\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if (options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if (options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback () {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\r\n            options.onHide($tooltip);\r\n          }\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if (_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function (evt) {\r\n          if (evt) { evt.preventDefault(); }\r\n          if ($tooltip.$isShown) {\r\n            $tooltip.leave();\r\n          } else {\r\n            $tooltip.enter();\r\n          }\r\n        };\r\n\r\n        $tooltip.focus = function () {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function (isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function (viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function () {\r\n          if (!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement;\r\n          var autoToken = /\\s?auto?\\s?/i;\r\n          var autoPlace = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition();\r\n          var tipWidth = tipElement.prop('offsetWidth');\r\n          var tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\r\n              placement = placement.replace('left', 'right');\r\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\r\n              placement = placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function (evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function (evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function (evt) {\r\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\r\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          if ($tooltip.$isShown) {\r\n            element[0].blur();\r\n          } else {\r\n            element[0].focus();\r\n          }\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents () {\r\n\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function (trigger) {\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.on(trigger, $tooltip.toggle);\r\n              // element.on('blur', $tooltip.leave);\r\n            } else if (trigger !== 'manual') {\r\n              // Only bind up hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              } else if (trigger === 'focus') { // but do bind focus events for touch\r\n                element.on('focus', $tooltip.enter);\r\n                element.on('blur', $tooltip.leave);\r\n              }\r\n\r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents () {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if (trigger === 'click' || trigger === 'contextmenu') {\r\n              element.off(trigger, $tooltip.toggle);\r\n            } else if (trigger !== 'manual') {\r\n              // Remove previously defined hover events if we are on a desktop\r\n              if (!isTouch) {\r\n                element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n                element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              } else if (trigger === 'focus') { // Remove previously defined focus events\r\n                element.off('focus', $tooltip.enter);\r\n                element.off('blur', $tooltip.leave);\r\n              }\r\n\r\n              // if (nodeName === 'button' && trigger !== 'hover') {\r\n              //   element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n              // }\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents () {\r\n          if (options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents () {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents () {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation (event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition ($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n          var isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          /* eslint-disable guard-for-in */\r\n          for (var p in elRect) { // eslint-disable-line\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n          /* eslint-enable guard-for-in */\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\r\n          }\r\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\r\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\r\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n            case 'right':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left + position.width\r\n              };\r\n              break;\r\n            case 'bottom':\r\n              offset = {\r\n                top: position.top + position.height,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n            case 'left':\r\n              offset = {\r\n                top: position.top + position.height / 2 - actualHeight / 2,\r\n                left: position.left - actualWidth\r\n              };\r\n              break;\r\n            default:\r\n              offset = {\r\n                top: position.top - actualHeight,\r\n                left: position.left + position.width / 2 - actualWidth / 2\r\n              };\r\n              break;\r\n          }\r\n\r\n          if (!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if (split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n              case 'left':\r\n                offset.left = position.left;\r\n                break;\r\n              case 'right':\r\n                offset.left = position.left + position.width - actualWidth;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          } else if (split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n              case 'top':\r\n                offset.top = position.top - actualHeight + position.height;\r\n                break;\r\n              case 'bottom':\r\n                offset.top = position.top;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement (offset, placement) {\r\n          var tip = tipElement[0];\r\n          var width = tip.offsetWidth;\r\n          var height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\r\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth;\r\n          var actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement);\r\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\r\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow (delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement () {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if ($tooltip.$isShown && tipElement !== null) {\r\n            if (options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if (options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if (tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if (tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest (scope) {\r\n        /* eslint-disable no-unused-expressions */\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n        /* eslint-enable no-unused-expressions */\r\n      }\r\n\r\n      function findElement (query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        var tooltip;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function (newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        attr.$observe('disabled', function (newValue) {\r\n          if (newValue && tooltip.$isShown) {\r\n            tooltip.hide();\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsTooltip) {\r\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.title = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              $$rAF(function () {\r\n                if (tooltip) tooltip.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n            if (newValue === true) {\r\n              tooltip.show();\r\n            } else {\r\n              tooltip.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\r\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n            if (newValue === false) {\r\n              tooltip.setEnabled(false);\r\n            } else {\r\n              tooltip.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!tooltip || !angular.isDefined(newValue)) return;\r\n            tooltip.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$timepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      defaultDate: 'auto',\r\n      // uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'timepicker',\r\n      prefixClass: 'timepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'timepicker/timepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: true,\r\n      timeType: 'date',\r\n      timeFormat: 'shortTime',\r\n      timezone: null,\r\n      modelTimeFormat: null,\r\n      autoclose: false,\r\n      minTime: -Infinity,\r\n      maxTime: +Infinity,\r\n      length: 5,\r\n      hourStep: 1,\r\n      minuteStep: 5,\r\n      secondStep: 5,\r\n      roundDisplay: false,\r\n      iconUp: 'glyphicon glyphicon-chevron-up',\r\n      iconDown: 'glyphicon glyphicon-chevron-down',\r\n      arrowBehavior: 'pager'\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) {\r\n        defaults.lang = $dateFormatter.getDefaultLocale();\r\n      }\r\n\r\n      function timepickerFactory (element, controller, config) {\r\n\r\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $timepicker.$options;\r\n        var scope = $timepicker.$scope;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        function floorMinutes (time) {\r\n          // coeff used to floor current time to nearest minuteStep interval\r\n          var coeff = 1000 * 60 * options.minuteStep;\r\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\r\n        }\r\n\r\n        // View vars\r\n\r\n        var selectedIndex = 0;\r\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\r\n        var startDate = controller.$dateValue || defaultDate;\r\n        var viewDate = {\r\n          hour: startDate.getHours(),\r\n          meridian: startDate.getHours() < 12,\r\n          minute: startDate.getMinutes(),\r\n          second: startDate.getSeconds(),\r\n          millisecond: startDate.getMilliseconds()\r\n        };\r\n\r\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\r\n\r\n        var hoursFormat = $dateFormatter.hoursFormat(format);\r\n        var timeSeparator = $dateFormatter.timeSeparator(format);\r\n        var minutesFormat = $dateFormatter.minutesFormat(format);\r\n        var secondsFormat = $dateFormatter.secondsFormat(format);\r\n        var showSeconds = $dateFormatter.showSeconds(format);\r\n        var showAM = $dateFormatter.showAM(format);\r\n\r\n        scope.$iconUp = options.iconUp;\r\n        scope.$iconDown = options.iconDown;\r\n\r\n        // Scope methods\r\n\r\n        scope.$select = function (date, index) {\r\n          $timepicker.select(date, index);\r\n        };\r\n        scope.$moveIndex = function (value, index) {\r\n          $timepicker.$moveIndex(value, index);\r\n        };\r\n        scope.$switchMeridian = function (date) {\r\n          $timepicker.switchMeridian(date);\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $timepicker.update = function (date) {\r\n          // console.warn('$timepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $timepicker.$date = date;\r\n            angular.extend(viewDate, {\r\n              hour: date.getHours(),\r\n              minute: date.getMinutes(),\r\n              second: date.getSeconds(),\r\n              millisecond: date.getMilliseconds()\r\n            });\r\n            $timepicker.$build();\r\n          } else if (!$timepicker.$isBuilt) {\r\n            $timepicker.$build();\r\n          }\r\n        };\r\n\r\n        $timepicker.select = function (date, index, keep) {\r\n          // console.warn('$timepicker.select', date, scope.$mode);\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\r\n          }\r\n\r\n          if (!angular.isDate(date)) date = new Date(date);\r\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\r\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\r\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n          if (options.autoclose && !keep) {\r\n            $timeout(function () {\r\n              $timepicker.hide(true);\r\n            });\r\n          }\r\n        };\r\n\r\n        $timepicker.switchMeridian = function (date) {\r\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\r\n            return;\r\n          }\r\n          var hours = (date || controller.$dateValue).getHours();\r\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\r\n          controller.$setViewValue(angular.copy(controller.$dateValue));\r\n          controller.$render();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $timepicker.$build = function () {\r\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\r\n          var i;\r\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\r\n          var hours = [];\r\n          var hour;\r\n          for (i = 0; i < options.length; i++) {\r\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\r\n            hours.push({\r\n              date: hour,\r\n              label: formatDate(hour, hoursFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\r\n              disabled: $timepicker.$isDisabled(hour, 0)\r\n            });\r\n          }\r\n          var minutes = [];\r\n          var minute;\r\n          for (i = 0; i < options.length; i++) {\r\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\r\n            minutes.push({\r\n              date: minute,\r\n              label: formatDate(minute, minutesFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\r\n              disabled: $timepicker.$isDisabled(minute, 1)\r\n            });\r\n          }\r\n          var seconds = [];\r\n          var second;\r\n          for (i = 0; i < options.length; i++) {\r\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\r\n            seconds.push({\r\n              date: second,\r\n              label: formatDate(second, secondsFormat),\r\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\r\n              disabled: $timepicker.$isDisabled(second, 2)\r\n            });\r\n          }\r\n\r\n          var rows = [];\r\n          for (i = 0; i < options.length; i++) {\r\n            if (showSeconds) {\r\n              rows.push([hours[i], minutes[i], seconds[i]]);\r\n            } else {\r\n              rows.push([hours[i], minutes[i]]);\r\n            }\r\n          }\r\n          scope.rows = rows;\r\n          scope.showSeconds = showSeconds;\r\n          scope.showAM = showAM;\r\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\r\n          scope.timeSeparator = timeSeparator;\r\n          $timepicker.$isBuilt = true;\r\n        };\r\n\r\n        $timepicker.$isSelected = function (date, index) {\r\n          if (!$timepicker.$date) return false;\r\n          else if (index === 0) {\r\n            return date.getHours() === $timepicker.$date.getHours();\r\n          } else if (index === 1) {\r\n            return date.getMinutes() === $timepicker.$date.getMinutes();\r\n          } else if (index === 2) {\r\n            return date.getSeconds() === $timepicker.$date.getSeconds();\r\n          }\r\n        };\r\n\r\n        $timepicker.$isDisabled = function (date, index) {\r\n          var selectedTime;\r\n          if (index === 0) {\r\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\r\n          } else if (index === 1) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\r\n          } else if (index === 2) {\r\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\r\n          }\r\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\r\n        };\r\n\r\n        scope.$arrowAction = function (value, index) {\r\n          if (options.arrowBehavior === 'picker') {\r\n            $timepicker.$setTimeByStep(value, index);\r\n          } else {\r\n            $timepicker.$moveIndex(value, index);\r\n          }\r\n        };\r\n\r\n        $timepicker.$setTimeByStep = function (value, index) {\r\n          var newDate = new Date($timepicker.$date || startDate);\r\n          var hours = newDate.getHours();\r\n          var minutes = newDate.getMinutes();\r\n          var seconds = newDate.getSeconds();\r\n          if (index === 0) {\r\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\r\n          } else if (index === 1) {\r\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\r\n          } else if (index === 2) {\r\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\r\n          }\r\n          $timepicker.select(newDate, index, true);\r\n        };\r\n\r\n        $timepicker.$moveIndex = function (value, index) {\r\n          var targetDate;\r\n          if (index === 0) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\r\n            angular.extend(viewDate, {\r\n              hour: targetDate.getHours()\r\n            });\r\n          } else if (index === 1) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\r\n            angular.extend(viewDate, {\r\n              minute: targetDate.getMinutes()\r\n            });\r\n          } else if (index === 2) {\r\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\r\n            angular.extend(viewDate, {\r\n              second: targetDate.getSeconds()\r\n            });\r\n          }\r\n          $timepicker.$build();\r\n        };\r\n\r\n        $timepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        $timepicker.$onKeyDown = function (evt) {\r\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          // Close on enter\r\n          if (evt.keyCode === 13) {\r\n            $timepicker.hide(true);\r\n            return;\r\n          }\r\n\r\n          // Navigate with keyboard\r\n          var newDate = new Date($timepicker.$date);\r\n          var hours = newDate.getHours();\r\n          var hoursLength = formatDate(newDate, hoursFormat).length;\r\n          var minutes = newDate.getMinutes();\r\n          var minutesLength = formatDate(newDate, minutesFormat).length;\r\n          var seconds = newDate.getSeconds();\r\n          var secondsLength = formatDate(newDate, secondsFormat).length;\r\n          var sepLength = 1;\r\n          var lateralMove = /(37|39)/.test(evt.keyCode);\r\n          var count = 2 + showSeconds * 1 + showAM * 1;\r\n\r\n          // Navigate indexes (left, right)\r\n          if (lateralMove) {\r\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\r\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\r\n          }\r\n\r\n          // Update values (up, down)\r\n          var selectRange = [0, hoursLength];\r\n          var incr = 0;\r\n          if (evt.keyCode === 38) incr = -1;\r\n          if (evt.keyCode === 40) incr = +1;\r\n          var isSeconds = selectedIndex === 2 && showSeconds;\r\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\r\n          if (selectedIndex === 0) {\r\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\r\n            // re-calculate hours length because we have changed hours value\r\n            hoursLength = formatDate(newDate, hoursFormat).length;\r\n            selectRange = [0, hoursLength];\r\n          } else if (selectedIndex === 1) {\r\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\r\n            // re-calculate minutes length because we have changes minutes value\r\n            minutesLength = formatDate(newDate, minutesFormat).length;\r\n            selectRange = [hoursLength + sepLength, minutesLength];\r\n          } else if (isSeconds) {\r\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\r\n            // re-calculate seconds length because we have changes seconds value\r\n            secondsLength = formatDate(newDate, secondsFormat).length;\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\r\n          } else if (isMeridian) {\r\n            if (!lateralMove) $timepicker.switchMeridian();\r\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\r\n          }\r\n          $timepicker.select(newDate, selectedIndex, true);\r\n          createSelection(selectRange[0], selectRange[1]);\r\n          parentScope.$digest();\r\n        };\r\n\r\n        // Private\r\n\r\n        function createSelection (start, length) {\r\n          var end = start + length;\r\n          if (element[0].createTextRange) {\r\n            var selRange = element[0].createTextRange();\r\n            selRange.collapse(true);\r\n            selRange.moveStart('character', start);\r\n            selRange.moveEnd('character', end);\r\n            selRange.select();\r\n          } else if (element[0].setSelectionRange) {\r\n            element[0].setSelectionRange(start, end);\r\n          } else if (angular.isUndefined(element[0].selectionStart)) {\r\n            element[0].selectionStart = start;\r\n            element[0].selectionEnd = end;\r\n          }\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        var _init = $timepicker.init;\r\n        $timepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'time');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        var _destroy = $timepicker.destroy;\r\n        $timepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        var _show = $timepicker.show;\r\n        $timepicker.show = function () {\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n          _show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n            if (options.keyboard) {\r\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $timepicker.hide;\r\n        $timepicker.hide = function (blur) {\r\n          if (!$timepicker.$isShown) return;\r\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\r\n          if (options.keyboard) {\r\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\r\n          }\r\n          _hide(blur);\r\n        };\r\n\r\n        return $timepicker;\r\n\r\n      }\r\n\r\n      timepickerFactory.defaults = defaults;\r\n      return timepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\r\n\r\n    var defaults = $timepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize timepicker\r\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\r\n        var timepicker = $timepicker(element, controller, options);\r\n        options = timepicker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format, timezone) {\r\n          return $dateFormatter.formatDate(date, format, lang, timezone);\r\n        };\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!timepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\r\n            if (newValue === true) {\r\n              timepicker.show();\r\n            } else {\r\n              timepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Initialize parser\r\n        var dateParser = $dateParser({\r\n          format: options.timeFormat,\r\n          lang: lang\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minTime', 'maxTime'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\r\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\r\n              validateAgainstMinMaxTime(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\r\n          timepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        function validateAgainstMinMaxTime (parsedTime) {\r\n          if (!angular.isDate(parsedTime)) return;\r\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\r\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (!isValid) {\r\n            return;\r\n          }\r\n          controller.$dateValue = parsedTime;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            controller.$setValidity('date', true);\r\n            return null;\r\n          }\r\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // Return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return undefined;\r\n          }\r\n          validateAgainstMinMaxTime(parsedTime);\r\n\r\n          if (options.timeType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\r\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.timeType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.timeType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.timeType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.timeType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\r\n          } else if (options.timeType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\r\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          return getTimeFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getTimeFormattedString());\r\n        };\r\n\r\n        function getTimeFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (timepicker) timepicker.destroy();\r\n          options = null;\r\n          timepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tab', [])\r\n\r\n  .provider('$tab', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      template: 'tab/tab.tpl.html',\r\n      navClass: 'nav-tabs',\r\n      activeClass: 'active',\r\n      isVertical: false\r\n    };\r\n    var _tabsHash = {};\r\n\r\n    var _addTabControl = function (key, control) {\r\n      if (!_tabsHash[key]) _tabsHash[key] = control;\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs, $timeout) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'navClass', 'activeClass', 'id', 'isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['isVertical'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) self.$options[key] = false;\r\n      });\r\n\r\n      // Publish options on scope\r\n      $scope.$navClass = self.$options.navClass;\r\n      $scope.$activeClass = self.$options.activeClass;\r\n\r\n      $scope.$onClick = function $onClick (evt, pane, index) {\r\n        if (!pane.disabled) {\r\n          self.$setActive(pane.name || index);\r\n        }\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      };\r\n\r\n      function navigatePane (index, toLeft) {\r\n        var newIndex = 0;\r\n\r\n        if (toLeft) {\r\n          // Moving to the left\r\n          newIndex = index - 1 < 0 ? (self.$panes.length - 1) : (index - 1);\r\n        } else {\r\n          // Moving to the right\r\n          newIndex = (index + 1) >= self.$panes.length ? 0 : (index + 1);\r\n        }\r\n\r\n        if (self.$panes[newIndex].disabled) {\r\n          navigatePane(newIndex, toLeft);\r\n        } else {\r\n          self.$setActive(self.$panes[newIndex].name || newIndex);\r\n        }\r\n      }\r\n\r\n      self.$panes = $scope.$panes = [];\r\n\r\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\r\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\r\n      // activePaneChangeListeners to make more sense.\r\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\r\n\r\n      self.$push = function (pane) {\r\n        if (angular.isUndefined(self.$panes.$active)) {\r\n          $scope.$setActive(pane.name || 0);\r\n        }\r\n\r\n        self.$panes.push(pane);\r\n\r\n        self.$panes.forEach(function (tabPane, index) {\r\n          // Set an id value for the pane so that it can be used in the template\r\n          tabPane.$describedBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index;\r\n          tabPane.$labeledBy = self.$options.id === undefined ? undefined : self.$options.id + '_$tab_' + index + '_a';\r\n        });\r\n      };\r\n\r\n      self.$remove = function (pane) {\r\n        var index = self.$panes.indexOf(pane);\r\n        var active = self.$panes.$active;\r\n        var activeIndex;\r\n        if (angular.isString(active)) {\r\n          activeIndex = self.$panes.map(function (pane) {\r\n            return pane.name;\r\n          }).indexOf(active);\r\n        } else {\r\n          activeIndex = self.$panes.$active;\r\n        }\r\n\r\n        // remove pane from $panes array\r\n        self.$panes.splice(index, 1);\r\n\r\n        if (index < activeIndex) {\r\n          // we removed a pane before the active pane, so we need to\r\n          // decrement the active pane index\r\n          activeIndex--;\r\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\r\n          // we remove the active pane and it was the one at the end,\r\n          // so select the previous one\r\n          activeIndex--;\r\n        }\r\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\r\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\r\n        } else {\r\n          self.$setActive();\r\n        }\r\n      };\r\n\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        self.$panes.$active = value;\r\n        self.$activePaneChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\r\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\r\n      };\r\n\r\n      self.$onKeyPress = $scope.$onKeyPress = function (e, name, index) {\r\n        if (e.keyCode === 32 || e.charCode === 32 || e.keyCode === 13 || e.charCode === 13) {\r\n          // If space or enter was pressed\r\n          self.$setActive(name);\r\n\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n\r\n        } else if (!self.$options.isVertical && (e.keyCode === 37 || e.charCode === 37 || e.keyCode === 39 || e.charCode === 39)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 37 || e.charCode === 37));\r\n        } else if (self.$options.isVertical && (e.keyCode === 38 || e.charCode === 38 || e.keyCode === 40 || e.charCode === 40)) {\r\n          // If the left of right arrow key was pressed.\r\n          navigatePane(index, (e.keyCode === 38 || e.charCode === 38));\r\n        }\r\n      };\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $tab = {};\r\n      $tab.defaults = defaults;\r\n      $tab.controller = controller;\r\n      $tab.addTabControl = _addTabControl;\r\n      $tab.tabsHash = _tabsHash;\r\n      return $tab;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTabs', function ($window, $animate, $tab, $parse, $timeout) {\r\n\r\n    var defaults = $tab.defaults;\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsTabs'],\r\n      transclude: true,\r\n      scope: true,\r\n      controller: ['$scope', '$element', '$attrs', '$timeout', $tab.controller],\r\n      templateUrl: function (element, attr) {\r\n        return attr.template || defaults.template;\r\n      },\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add a way for developers to access tab scope if needed.  This allows for more fine grained control over what\r\n        // tabs are available in the tab component\r\n        if (attrs.tabKey !== '' && attrs.tabKey !== undefined) {\r\n          $tab.addTabControl(attrs.tabKey, bsTabsCtrl);\r\n        }\r\n\r\n        // 'ngModel' does interfere with form validation\r\n        // and status, use `bsActivePane` instead to avoid it\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            bsTabsCtrl.$setActive(modelValue);\r\n            return modelValue;\r\n          });\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          $timeout(function () {\r\n            // get li elements\r\n            var liElements = element.find('li');\r\n            for (var i = 0; i < liElements.length; i++) {\r\n              var iElement = angular.element(liElements[i]);\r\n              iElement.removeAttr('tabindex');\r\n\r\n              // As per SS-44480\r\n              // if (iElement.hasClass(bsTabsCtrl.$options.activeClass)) {\r\n                // if li is active, set focus to it.\r\n                // iElement.find('a')[0].focus();\r\n              // }\r\n            }\r\n            // delay, for the class (.active) change to reflect in DOM.\r\n          }, 100);\r\n        });\r\n\r\n        if (attrs.bsActivePane) {\r\n          // adapted from angularjs ngModelController bindings\r\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\r\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\r\n\r\n          // Update bsActivePane value with change\r\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\r\n          });\r\n\r\n          // watch bsActivePane for value changes\r\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\r\n            bsTabsCtrl.$setActive(newValue);\r\n          }, true);\r\n        }\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPane', function ($window, $animate, $sce) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsTabs'],\r\n      scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsTabsCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('tab-pane');\r\n\r\n        // Set up the assistive attributes\r\n        element.attr('role', 'tabpanel');\r\n\r\n        // Observe title attribute for change\r\n        attrs.$observe('title', function (newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n        });\r\n\r\n        // Save tab name into scope\r\n        scope.name = attrs.name;\r\n        // Save tab id into scope\r\n        scope.id = attrs.id;\r\n\r\n        scope.name = scope.name || scope.id;\r\n\r\n        // Add animation class\r\n        if (bsTabsCtrl.$options.animation) {\r\n          element.addClass(bsTabsCtrl.$options.animation);\r\n        }\r\n\r\n        attrs.$observe('disabled', function (newValue, oldValue) {\r\n          scope.disabled = scope.$eval(newValue);\r\n        });\r\n\r\n        // Push pane to parent bsTabs controller\r\n        bsTabsCtrl.$push(scope);\r\n\r\n        // Once the push has occured when can then update the element with some properties.\r\n        // Update the aria-labelledby attribute\r\n\t\t// SS-11127 - removed aria-describedby from tab and tab-panel and utilized aria-labeledby on the tab-panel using the ID of the tab and not the ID of the tab link\r\n        if (scope.$describedBy !== undefined) {\r\n          element.attr('aria-labelledby', scope.$describedBy);\r\n        }\r\n\r\n        // remove pane from tab controller when pane is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsTabsCtrl.$remove(scope);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsTabsCtrl.$panes.indexOf(scope);\r\n\r\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('focusOn', function () {\r\n    return {\r\n      restrict: 'A',\r\n      link: function (scope, elem, attr) {\r\n        scope.$watch(attr.focusOn, function (newValue, oldValue) {\r\n          if (newValue !== oldValue && newValue) {\r\n            elem[0].children[0].focus();\r\n          }\r\n        });\r\n      }\r\n    };\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\r\n\r\n  .provider('$select', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'select',\r\n      prefixEvent: '$select',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'select/select.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      multiple: false,\r\n      allNoneButtons: false,\r\n      sort: true,\r\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\r\n      placeholder: 'Choose among the following...',\r\n      allText: 'All',\r\n      noneText: 'None',\r\n      maxLength: 3,\r\n      maxLengthHtml: 'selected',\r\n      iconCheckmark: 'glyphicon glyphicon-ok',\r\n      toggle: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\r\n\r\n      // var bodyEl = angular.element($window.document.body);\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n\r\n      function SelectFactory (element, controller, config) {\r\n\r\n        var $select = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $select = $tooltip(element, options);\r\n        var scope = $select.$scope;\r\n\r\n        scope.$matches = [];\r\n        if (options.multiple) {\r\n          scope.$activeIndex = [];\r\n        } else {\r\n          scope.$activeIndex = -1;\r\n        }\r\n        scope.$isMultiple = options.multiple;\r\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\r\n        scope.$iconCheckmark = options.iconCheckmark;\r\n        scope.$allText = options.allText;\r\n        scope.$noneText = options.noneText;\r\n\r\n        scope.$activate = function (index) {\r\n          scope.$$postDigest(function () {\r\n            $select.activate(index);\r\n          });\r\n        };\r\n\r\n        scope.$select = function (index, evt) {\r\n          scope.$$postDigest(function () {\r\n            $select.select(index);\r\n          });\r\n        };\r\n\r\n        scope.$isVisible = function () {\r\n          return $select.$isVisible();\r\n        };\r\n\r\n        scope.$isActive = function (index) {\r\n          return $select.$isActive(index);\r\n        };\r\n\r\n        scope.$selectAll = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (!scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        scope.$selectNone = function () {\r\n          for (var i = 0; i < scope.$matches.length; i++) {\r\n            if (scope.$isActive(i)) {\r\n              scope.$select(i);\r\n            }\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $select.update = function (matches) {\r\n          scope.$matches = matches;\r\n          $select.$updateActiveIndex();\r\n        };\r\n\r\n        $select.activate = function (index) {\r\n          if (options.multiple) {\r\n            if ($select.$isActive(index)) {\r\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\r\n            } else {\r\n              scope.$activeIndex.push(index);\r\n            }\r\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\r\n          } else {\r\n            scope.$activeIndex = index;\r\n          }\r\n          return scope.$activeIndex;\r\n        };\r\n\r\n        $select.select = function (index) {\r\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\r\n          var value = scope.$matches[index].value;\r\n          scope.$apply(function () {\r\n            $select.activate(index);\r\n            if (options.multiple) {\r\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\r\n                if (angular.isUndefined(scope.$matches[index])) {\r\n                  return null;\r\n                }\r\n                return scope.$matches[index].value;\r\n              }));\r\n            } else {\r\n              if (options.toggle) {\r\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\r\n              } else {\r\n                controller.$setViewValue(value);\r\n              }\r\n              // Hide if single select\r\n              $select.hide();\r\n            }\r\n          });\r\n          // Emit event\r\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\r\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\r\n            options.onSelect(value, index, $select);\r\n          }\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $select.$updateActiveIndex = function () {\r\n          if (options.multiple) {\r\n            if (angular.isArray(controller.$modelValue)) {\r\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\r\n                return $select.$getIndex(value);\r\n              });\r\n            } else {\r\n              scope.$activeIndex = [];\r\n            }\r\n          } else {\r\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\r\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\r\n            } else {\r\n              scope.$activeIndex = -1;\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$isVisible = function () {\r\n          if (!options.minLength || !controller) {\r\n            return scope.$matches.length;\r\n          }\r\n          // minLength support\r\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\r\n        };\r\n\r\n        $select.$isActive = function (index) {\r\n          if (options.multiple) {\r\n            return scope.$activeIndex.indexOf(index) !== -1;\r\n          }\r\n          return scope.$activeIndex === index;\r\n        };\r\n\r\n        $select.$getIndex = function (value) {\r\n          var index;\r\n          for (index = scope.$matches.length; index--;) {\r\n            if (angular.equals(scope.$matches[index].value, value)) break;\r\n          }\r\n          return index;\r\n        };\r\n\r\n        $select.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            var anchor;\r\n\r\n            if (evt.target.nodeName !== 'A') {\r\n              var anchorCandidate = targetEl.parent();\r\n              while (!anchor && anchorCandidate.length > 0) {\r\n                if (anchorCandidate[0].nodeName === 'A') {\r\n                  anchor = anchorCandidate;\r\n                }\r\n                anchorCandidate = anchorCandidate.parent();\r\n              }\r\n            }\r\n\r\n            if (anchor) {\r\n              angular.element(anchor).triggerHandler('click');\r\n            } else {\r\n              targetEl.triggerHandler('click');\r\n            }\r\n          }\r\n        };\r\n\r\n        $select.$onKeyDown = function (evt) {\r\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\r\n          // Let tab propagate\r\n          if (evt.keyCode !== 9) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n\r\n          // release focus on tab\r\n          if (options.multiple && evt.keyCode === 9) {\r\n            return $select.hide();\r\n          }\r\n\r\n          // Select with enter\r\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\r\n            return $select.select(scope.$activeIndex);\r\n          }\r\n\r\n          if (!options.multiple) {\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\r\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\r\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\r\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\r\n            scope.$digest();\r\n          }\r\n        };\r\n\r\n        $select.$isIE = function () {\r\n          var ua = $window.navigator.userAgent;\r\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\r\n        };\r\n\r\n        $select.$selectScrollFix = function (e) {\r\n          if ($document[0].activeElement.tagName === 'UL') {\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n            e.target.focus();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var _show = $select.show;\r\n        $select.show = function () {\r\n          _show();\r\n          if (options.multiple) {\r\n            $select.$element.addClass('select-multiple');\r\n          }\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n            if (options.keyboard) {\r\n              element.on('keydown', $select.$onKeyDown);\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        var _hide = $select.hide;\r\n        $select.hide = function () {\r\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\r\n            scope.$activeIndex = -1;\r\n          }\r\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\r\n          if (options.keyboard) {\r\n            element.off('keydown', $select.$onKeyDown);\r\n          }\r\n          _hide(true);\r\n        };\r\n\r\n        return $select;\r\n\r\n      }\r\n\r\n      SelectFactory.defaults = defaults;\r\n      return SelectFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\r\n\r\n    var defaults = $select.defaults;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, placeholder: defaults.placeholder};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show, hide and select events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\r\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\r\n        var dataMultiple = element.attr('data-multiple');\r\n        if (angular.isDefined(dataMultiple)) {\r\n          if (falseValueRegExp.test(dataMultiple)) {\r\n            options.multiple = false;\r\n          } else {\r\n            options.multiple = dataMultiple;\r\n          }\r\n        }\r\n\r\n        // Add support for select markup\r\n        if (element[0].nodeName.toLowerCase() === 'select') {\r\n          var inputEl = element;\r\n          inputEl.css('display', 'none');\r\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\" aria-haspopup=\"true\"></button>');\r\n          inputEl.after(element);\r\n        }\r\n\r\n        // Build proper bsOptions\r\n        var parsedOptions = $parseOptions(attr.bsOptions);\r\n\r\n        // Initialize select\r\n        var select = $select(element, controller, options);\r\n\r\n        if (select.$isIE()) {\r\n          element[0].addEventListener('blur', select.$selectScrollFix);\r\n        }\r\n\r\n        // Watch bsOptions values before filtering for changes\r\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\r\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\r\n          parsedOptions.valuesFn(scope, controller)\r\n          .then(function (values) {\r\n            select.update(values);\r\n            controller.$render();\r\n          });\r\n        }, true);\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\r\n          select.$updateActiveIndex();\r\n          controller.$render();\r\n        }, true);\r\n\r\n        // Model rendering in view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var selected;\r\n          var index;\r\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\r\n            selected = controller.$modelValue.map(function (value) {\r\n              index = select.$getIndex(value);\r\n              return index !== -1 ? select.$scope.$matches[index].label : false;\r\n            }).filter(angular.isDefined);\r\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\r\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\r\n            } else {\r\n              selected = selected.join(', ');\r\n            }\r\n          } else {\r\n            index = select.$getIndex(controller.$modelValue);\r\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\r\n          }\r\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\r\n        };\r\n\r\n        if (options.multiple) {\r\n          controller.$isEmpty = function (value) {\r\n            return !value || value.length === 0;\r\n          };\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (select) select.destroy();\r\n          options = null;\r\n          select = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$popover', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      // uncommenting the next two lines will break backwards compatability\r\n      // prefixClass: 'popover',\r\n      // prefixEvent: 'popover',\r\n      container: false,\r\n      target: false,\r\n      placement: 'right',\r\n      templateUrl: 'popover/popover.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'click',\r\n      keyboard: true,\r\n      html: false,\r\n      title: '',\r\n      content: '',\r\n      delay: 0,\r\n      autoClose: false\r\n    };\r\n\r\n    this.$get = function ($tooltip) {\r\n\r\n      function PopoverFactory (element, config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        var $popover = $tooltip(element, options);\r\n\r\n        // Support scope as string options [/*title, */content]\r\n        if (options.content) {\r\n          $popover.$scope.content = options.content;\r\n        }\r\n\r\n        return $popover;\r\n\r\n      }\r\n\r\n      return PopoverFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsPopover', function ($window, $sce, $popover) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var popover;\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if (angular.isDefined(dataTarget)) {\r\n          if (falseValueRegExp.test(dataTarget)) {\r\n            options.target = false;\r\n          } else {\r\n            options.target = dataTarget;\r\n          }\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n              if (angular.isDefined(oldValue)) {\r\n                requestAnimationFrame(function () {\r\n                  if (popover) popover.$applyPlacement();\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsPopover) {\r\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n            if (angular.isDefined(oldValue)) {\r\n              requestAnimationFrame(function () {\r\n                if (popover) popover.$applyPlacement();\r\n              });\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\r\n            if (newValue === true) {\r\n              popover.show();\r\n            } else {\r\n              popover.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Enabled binding support\r\n        if (attr.bsEnabled) {\r\n          scope.$watch(attr.bsEnabled, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\r\n            if (newValue === false) {\r\n              popover.setEnabled(false);\r\n            } else {\r\n              popover.setEnabled(true);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Viewport support\r\n        if (attr.viewport) {\r\n          scope.$watch(attr.viewport, function (newValue) {\r\n            if (!popover || !angular.isDefined(newValue)) return;\r\n            popover.setViewport(newValue);\r\n          });\r\n        }\r\n\r\n        // Initialize popover\r\n        popover = $popover(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (popover) popover.destroy();\r\n          options = null;\r\n          popover = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$scrollspy', function () {\r\n\r\n    // Pool of registered spies\r\n    var spies = this.$$spies = {};\r\n\r\n    var defaults = this.defaults = {\r\n      debounce: 150,\r\n      throttle: 100,\r\n      offset: 100\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\r\n\r\n      var windowEl = angular.element($window);\r\n      var docEl = angular.element($document.prop('documentElement'));\r\n      var bodyEl = angular.element($window.document.body);\r\n\r\n      // Helper functions\r\n\r\n      function nodeName (element, name) {\r\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\r\n      }\r\n\r\n      function ScrollSpyFactory (config) {\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        if (!options.element) options.element = bodyEl;\r\n        var isWindowSpy = nodeName(options.element, 'body');\r\n        var scrollEl = isWindowSpy ? windowEl : options.element;\r\n        var scrollId = isWindowSpy ? 'window' : options.id;\r\n\r\n        // Use existing spy\r\n        if (spies[scrollId]) {\r\n          spies[scrollId].$$count++;\r\n          return spies[scrollId];\r\n        }\r\n\r\n        var $scrollspy = {};\r\n\r\n        // Private vars\r\n        var unbindViewContentLoaded;\r\n        var unbindIncludeContentLoaded;\r\n        var trackedElements = $scrollspy.$trackedElements = [];\r\n        var sortedElements = [];\r\n        var activeTarget;\r\n        var debouncedCheckPosition;\r\n        var throttledCheckPosition;\r\n        var debouncedCheckOffsets;\r\n        /* eslint-disable no-unused-vars */\r\n        var viewportHeight;\r\n        /* eslint-enable no-unused-vars */\r\n        var scrollTop;\r\n\r\n        $scrollspy.init = function () {\r\n\r\n          // Setup internal ref counter\r\n          this.$$count = 1;\r\n\r\n          // Bind events\r\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\r\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\r\n          scrollEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', debouncedCheckPosition);\r\n          scrollEl.on('scroll', throttledCheckPosition);\r\n\r\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\r\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\r\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\r\n          debouncedCheckOffsets();\r\n\r\n          // Register spy for reuse\r\n          if (scrollId) {\r\n            spies[scrollId] = $scrollspy;\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.destroy = function () {\r\n\r\n          // Check internal ref counter\r\n          this.$$count--;\r\n          if (this.$$count > 0) {\r\n            return;\r\n          }\r\n\r\n          // Unbind events\r\n          scrollEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', debouncedCheckPosition);\r\n          scrollEl.off('scroll', throttledCheckPosition);\r\n          unbindViewContentLoaded();\r\n          unbindIncludeContentLoaded();\r\n          if (scrollId) {\r\n            delete spies[scrollId];\r\n          }\r\n        };\r\n\r\n        $scrollspy.checkPosition = function () {\r\n\r\n          // Not ready yet\r\n          if (!sortedElements.length) return;\r\n\r\n          // Calculate the scroll position\r\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\r\n\r\n          // Calculate the viewport height for use by the components\r\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\r\n\r\n          // Activate first element if scroll is smaller\r\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\r\n            return $scrollspy.$activateElement(sortedElements[0]);\r\n          }\r\n\r\n          // Activate proper element\r\n          for (var i = sortedElements.length; i--;) {\r\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\r\n            if (activeTarget === sortedElements[i].target) continue;\r\n            if (scrollTop < sortedElements[i].offsetTop) continue;\r\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\r\n            return $scrollspy.$activateElement(sortedElements[i]);\r\n          }\r\n\r\n        };\r\n\r\n        $scrollspy.checkPositionWithEventLoop = function () {\r\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\r\n          // in this setTimeout call\r\n          setTimeout($scrollspy.checkPosition, 1);\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $scrollspy.$activateElement = function (element) {\r\n          if (activeTarget) {\r\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\r\n            if (activeElement) {\r\n              activeElement.source.removeClass('active');\r\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\r\n                activeElement.source.parent().parent().removeClass('active');\r\n              }\r\n            }\r\n          }\r\n          activeTarget = element.target;\r\n          element.source.addClass('active');\r\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\r\n            element.source.parent().parent().addClass('active');\r\n          }\r\n        };\r\n\r\n        $scrollspy.$getTrackedElement = function (target) {\r\n          return trackedElements.filter(function (obj) {\r\n            return obj.target === target;\r\n          })[0];\r\n        };\r\n\r\n        // Track offsets behavior\r\n\r\n        $scrollspy.checkOffsets = function () {\r\n\r\n          angular.forEach(trackedElements, function (trackedElement) {\r\n            var targetElement = document.querySelector(trackedElement.target);\r\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\r\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\r\n          });\r\n\r\n          sortedElements = trackedElements\r\n          .filter(function (el) {\r\n            return el.offsetTop !== null;\r\n          })\r\n          .sort(function (a, b) {\r\n            return a.offsetTop - b.offsetTop;\r\n          });\r\n\r\n          debouncedCheckPosition();\r\n\r\n        };\r\n\r\n        $scrollspy.trackElement = function (target, source) {\r\n          trackedElements.push({target: target, source: source});\r\n        };\r\n\r\n        $scrollspy.untrackElement = function (target, source) {\r\n          var toDelete;\r\n          for (var i = trackedElements.length; i--;) {\r\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\r\n              toDelete = i;\r\n              break;\r\n            }\r\n          }\r\n          trackedElements.splice(toDelete, 1);\r\n        };\r\n\r\n        $scrollspy.activate = function (i) {\r\n          trackedElements[i].addClass('active');\r\n        };\r\n\r\n        // Initialize plugin\r\n\r\n        $scrollspy.init();\r\n        return $scrollspy;\r\n\r\n      }\r\n\r\n      return ScrollSpyFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      link: function postLink (scope, element, attr) {\r\n\r\n        var options = {scope: scope};\r\n        angular.forEach(['offset', 'target'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        var scrollspy = $scrollspy(options);\r\n        scrollspy.trackElement(options.target, element);\r\n\r\n        scope.$on('$destroy', function () {\r\n          if (scrollspy) {\r\n            scrollspy.untrackElement(options.target, element);\r\n            scrollspy.destroy();\r\n          }\r\n          options = null;\r\n          scrollspy = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n\r\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      compile: function postLink (element, attr) {\r\n        var children = element[0].querySelectorAll('li > a[href]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.navbar', [])\r\n\r\n  .provider('$navbar', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      routeAttr: 'data-match-route',\r\n      strict: false\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsNavbar', function ($window, $location, $navbar) {\r\n\r\n    var defaults = $navbar.defaults;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = angular.copy(defaults);\r\n        angular.forEach(Object.keys(defaults), function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Watch for the $location\r\n        scope.$watch(function () {\r\n\r\n          return $location.path();\r\n\r\n        }, function (newValue, oldValue) {\r\n\r\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\r\n\r\n          angular.forEach(liElements, function (li) {\r\n\r\n            var liElement = angular.element(li);\r\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\r\n            if (options.strict) {\r\n              pattern = '^' + pattern + '$';\r\n            }\r\n            var regexp = new RegExp(pattern, 'i');\r\n\r\n            if (regexp.test(newValue)) {\r\n              liElement.addClass(options.activeClass);\r\n            } else {\r\n              liElement.removeClass(options.activeClass);\r\n            }\r\n\r\n          });\r\n\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nif (angular.version.minor < 3 && angular.version.dot < 14) {\r\n  angular.module('ng')\r\n\r\n  .factory('$$rAF', function ($window, $timeout) {\r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame ||\r\n                                $window.webkitRequestAnimationFrame ||\r\n                                $window.mozRequestAnimationFrame;\r\n\r\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\r\n                               $window.webkitCancelAnimationFrame ||\r\n                               $window.mozCancelAnimationFrame ||\r\n                               $window.webkitCancelRequestAnimationFrame;\r\n\r\n    var rafSupported = !!requestAnimationFrame;\r\n    var raf = rafSupported ?\r\n      function (fn) {\r\n        var id = requestAnimationFrame(fn);\r\n        return function () {\r\n          cancelAnimationFrame(id);\r\n        };\r\n      } :\r\n      function (fn) {\r\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\r\n        return function () {\r\n          $timeout.cancel(timer);\r\n        };\r\n      };\r\n\r\n    raf.supported = rafSupported;\r\n\r\n    return raf;\r\n\r\n  });\r\n}\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\r\n\r\n  .provider('$parseOptions', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\r\n    };\r\n\r\n    this.$get = function ($parse, $q) {\r\n\r\n      function ParseOptionsFactory (attr, config) {\r\n\r\n        var $parseOptions = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        $parseOptions.$values = [];\r\n\r\n        // Private vars\r\n        var match;\r\n        var displayFn;\r\n        var valueName;\r\n        /* eslint-disable no-unused-vars */\r\n        var keyName;\r\n        var groupByFn;\r\n        /* eslint-enable no-unused-vars */\r\n        var valueFn;\r\n        var valuesFn;\r\n\r\n        $parseOptions.init = function () {\r\n          $parseOptions.$match = match = attr.match(options.regexp);\r\n          displayFn = $parse(match[2] || match[1]);\r\n          valueName = match[4] || match[6];\r\n          keyName = match[5];\r\n          groupByFn = $parse(match[3] || '');\r\n          valueFn = $parse(match[2] ? match[1] : valueName);\r\n          valuesFn = $parse(match[7]);\r\n        };\r\n\r\n        $parseOptions.valuesFn = function (scope, controller) {\r\n          return $q.when(valuesFn(scope, controller))\r\n          .then(function (values) {\r\n            if (!angular.isArray(values)) {\r\n              values = [];\r\n            }\r\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\r\n            return $parseOptions.$values;\r\n          });\r\n        };\r\n\r\n        $parseOptions.displayValue = function (modelValue) {\r\n          var scope = {};\r\n          scope[valueName] = modelValue;\r\n          return displayFn(scope);\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function parseValues (values, scope) {\r\n          return values.map(function (match, index) {\r\n            var locals = {};\r\n            var label;\r\n            var value;\r\n            locals[valueName] = match;\r\n            label = displayFn(scope, locals);\r\n            value = valueFn(scope, locals);\r\n            return {label: label, value: value, index: index};\r\n          });\r\n        }\r\n\r\n        $parseOptions.init();\r\n        return $parseOptions;\r\n\r\n      }\r\n\r\n      return ParseOptionsFactory;\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.ngFocusOut', [])\r\n  .directive('ngFocusOut', ['$parse', '$rootScope', function ($parse, $rootScope) {\r\n    return {\r\n      restrict: 'A',\r\n      compile: function ($element, attr) {\r\n        // NOTE:\r\n        // We expose the powerful `$event` object on the scope that provides access to the Window,\r\n        // etc. This is OK, because expressions are not sandboxed any more (and the expression\r\n        // sandbox was never meant to be a security feature anyway).\r\n        var fn = $parse(attr.ngFocusOut);\r\n\r\n        return function link (scope, element) {\r\n          function ngEventHandler (event) {\r\n            var callback = function () {\r\n              fn(scope, {\r\n                $event: event\r\n              });\r\n            };\r\n            if ($rootScope.$$phase) {\r\n              scope.$evalAsync(callback);\r\n            } else {\r\n              scope.$apply(callback);\r\n            }\r\n          }\r\n\r\n          // setup the handler\r\n          element.on('focusout', ngEventHandler);\r\n\r\n          scope.$on('$destroy', function () {\r\n            // tear down the handler\r\n            element.off('focusout', ngEventHandler);\r\n          });\r\n        };\r\n      }\r\n    };\r\n  }]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.focusElement', [])\r\n  .directive('focusElement', ['$timeout', '$parse', function ($timeout, $parse) {\r\n    return {\r\n      link: function (scope, element, attrs) {\r\n        scope.$watch(attrs.focusElement, function (value) {\r\n          if (value === true) {\r\n            $timeout(function(){\r\n              $(element[0]).animate(\r\n                {left:0}, \r\n                100, \r\n                function(){\r\n                  element[0].focus();\r\n                }\r\n              );\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\r\n\r\n  .factory('dimensions', function () {\r\n\r\n    var fn = {};\r\n\r\n    /**\r\n     * Test the element nodeName\r\n     * @param element\r\n     * @param name\r\n     */\r\n    var nodeName = fn.nodeName = function (element, name) {\r\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\r\n    };\r\n\r\n    /**\r\n     * Returns the element computed style\r\n     * @param element\r\n     * @param prop\r\n     * @param extra\r\n     */\r\n    fn.css = function (element, prop, extra) {\r\n      var value;\r\n      if (element.currentStyle) { // IE\r\n        value = element.currentStyle[prop];\r\n      } else if (window.getComputedStyle) {\r\n        value = window.getComputedStyle(element)[prop];\r\n      } else {\r\n        value = element.style[prop];\r\n      }\r\n      return extra === true ? parseFloat(value) || 0 : value;\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.offset = function (element) {\r\n      var boxRect = element.getBoundingClientRect();\r\n      var docElement = element.ownerDocument;\r\n      return {\r\n        width: boxRect.width || element.offsetWidth,\r\n        height: boxRect.height || element.offsetHeight,\r\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\r\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Provides set equivalent of jQuery's offset function:\r\n     * @required-by bootstrap-tooltip\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     * @param options\r\n     * @param i\r\n     */\r\n    fn.setOffset = function (element, options, i) {\r\n      var curPosition;\r\n      var curLeft;\r\n      var curCSSTop;\r\n      var curTop;\r\n      var curOffset;\r\n      var curCSSLeft;\r\n      var calculatePosition;\r\n      var position = fn.css(element, 'position');\r\n      var curElem = angular.element(element);\r\n      var props = {};\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        element.style.position = 'relative';\r\n      }\r\n\r\n      curOffset = fn.offset(element);\r\n      curCSSTop = fn.css(element, 'top');\r\n      curCSSLeft = fn.css(element, 'left');\r\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\r\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = fn.position(element);\r\n        curTop = curPosition.top;\r\n        curLeft = curPosition.left;\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0;\r\n        curLeft = parseFloat(curCSSLeft) || 0;\r\n      }\r\n\r\n      if (angular.isFunction(options)) {\r\n        options = options.call(element, i, curOffset);\r\n      }\r\n\r\n      if (options.top !== null) {\r\n        props.top = (options.top - curOffset.top) + curTop;\r\n      }\r\n      if (options.left !== null) {\r\n        props.left = (options.left - curOffset.left) + curLeft;\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(curElem, props);\r\n      } else {\r\n        curElem.css({\r\n          top: props.top + 'px',\r\n          left: props.left + 'px'\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Provides read-only equivalent of jQuery's position function\r\n     * @required-by bootstrap-tooltip, bootstrap-affix\r\n     * @url http://api.jquery.com/offset/\r\n     * @param element\r\n     */\r\n    fn.position = function (element) {\r\n\r\n      var offsetParentRect = {top: 0, left: 0};\r\n      var offsetParentEl;\r\n      var offset;\r\n\r\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n      if (fn.css(element, 'position') === 'fixed') {\r\n\r\n        // We assume that getBoundingClientRect is available when computed position is fixed\r\n        offset = element.getBoundingClientRect();\r\n\r\n      } else {\r\n\r\n        // Get *real* offsetParentEl\r\n        offsetParentEl = offsetParentElement(element);\r\n\r\n        // Get correct offsets\r\n        offset = fn.offset(element);\r\n        if (!nodeName(offsetParentEl, 'html')) {\r\n          offsetParentRect = fn.offset(offsetParentEl);\r\n        }\r\n\r\n        // Add offsetParent borders\r\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\r\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        width: element.offsetWidth,\r\n        height: element.offsetHeight,\r\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\r\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\r\n      };\r\n\r\n    };\r\n\r\n    /**\r\n     * Returns the closest, non-statically positioned offsetParent of a given element\r\n     * @required-by fn.position\r\n     * @param element\r\n     */\r\n    function offsetParentElement (element) {\r\n      var docElement = element.ownerDocument;\r\n      var offsetParent = element.offsetParent || docElement;\r\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\r\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\r\n        offsetParent = offsetParent.offsetParent;\r\n      }\r\n      return offsetParent || docElement.documentElement;\r\n    }\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's height function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/height/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.height = function (element, outer) {\r\n      var value = element.offsetHeight;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    /**\r\n     * Provides equivalent of jQuery's width function\r\n     * @required-by bootstrap-affix\r\n     * @url http://api.jquery.com/width/\r\n     * @param element\r\n     * @param outer\r\n     */\r\n    fn.width = function (element, outer) {\r\n      var value = element.offsetWidth;\r\n      if (outer) {\r\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\r\n      } else {\r\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    return fn;\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\r\n.factory('debounce', function ($timeout) {\r\n  return function (func, wait, immediate) {\r\n    var timeout = null;\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      var callNow = immediate && !timeout;\r\n      if (timeout) {\r\n        $timeout.cancel(timeout);\r\n      }\r\n      timeout = $timeout(function later () {\r\n        timeout = null;\r\n        if (!immediate) {\r\n          func.apply(context, args);\r\n        }\r\n      }, wait, false);\r\n      if (callNow) {\r\n        func.apply(context, args);\r\n      }\r\n      return timeout;\r\n    };\r\n  };\r\n})\r\n\r\n\r\n// @source jashkenas/underscore\r\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\r\n.factory('throttle', function ($timeout) {\r\n  return function (func, wait, options) {\r\n    var timeout = null;\r\n    if (!options) options = {};\r\n    return function () {\r\n      var context = this;\r\n      var args = arguments;\r\n      if (!timeout) {\r\n        if (options.leading !== false) {\r\n          func.apply(context, args);\r\n        }\r\n        timeout = $timeout(function later () {\r\n          timeout = null;\r\n          if (options.trailing !== false) {\r\n            func.apply(context, args);\r\n          }\r\n        }, wait, false);\r\n      }\r\n    };\r\n  };\r\n});\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function ($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate () {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function () { return this.hours; };\r\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function (value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function () {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop () {\r\n  }\r\n\r\n  function isNumeric (n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive (array, value) {\r\n    var len = array.length;\r\n    var str = value.toString().toLowerCase();\r\n    for (var i = 0; i < len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function ($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function (config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      /* eslint-disable key-spacing, quote-props */\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\r\n      };\r\n      /* eslint-enable key-spacing, quote-props */\r\n\r\n      var regex;\r\n      var setMap;\r\n\r\n      $dateParser.init = function () {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function (date) {\r\n        if (angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function (value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if (!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for (var i = 0; i < matches.length - 1; i++) {\r\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function (key, value) {\r\n        var date;\r\n\r\n        if (value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          if (value.match(/Z/)) {\r\n            date = new Date(value.substr(1, value.length - 3));\r\n          } else {\r\n            date = new Date(value.substr(1, value.length - 2));\r\n          }\r\n        } else if (isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function (key, value) {\r\n        var time;\r\n\r\n        if (value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if (isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function (date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function regExpForFormat (format) {\r\n        // `format` string can contain literal values.\r\n        // These need to be escaped by surrounding with\r\n        // single quotes (e.g. `\"h 'in the morning'\"`).\r\n        // In order to output a single quote, escape it - i.e.,\r\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\r\n\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseRegex(re);\r\n      }\r\n\r\n      function buildDateAbstractRegex (format) {\r\n        var escapedFormat = escapeReservedSymbols(format);\r\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\r\n        var literalRegex = /('(?:\\\\'|.)*?')/;\r\n        var formatParts = escapedLiteralFormat.split(literalRegex);\r\n        var dateElements = Object.keys(regExpMap);\r\n        var dateRegexParts = [];\r\n\r\n        angular.forEach(formatParts, function (part) {\r\n          if (isFormatStringLiteral(part)) {\r\n            part = trimLiteralEscapeChars(part);\r\n          } else {\r\n            // Abstract replaces to avoid collisions\r\n            for (var i = 0; i < dateElements.length; i++) {\r\n              part = part.split(dateElements[i]).join('${' + i + '}');\r\n            }\r\n          }\r\n          dateRegexParts.push(part);\r\n        });\r\n\r\n        return dateRegexParts.join('');\r\n      }\r\n\r\n      function escapeReservedSymbols (text) {\r\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\r\n                   .replace(/-/g, '[-]')\r\n                   .replace(/\\./g, '[.]')\r\n                   .replace(/\\*/g, '[*]')\r\n                   .replace(/\\+/g, '[+]')\r\n                   .replace(/\\?/g, '[?]')\r\n                   .replace(/\\$/g, '[$]')\r\n                   .replace(/\\^/g, '[^]')\r\n                   .replace(/\\//g, '[/]')\r\n                   .replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function isFormatStringLiteral (text) {\r\n        return /^'.*'$/.test(text);\r\n      }\r\n\r\n      function trimLiteralEscapeChars (text) {\r\n        return text.replace(/^'(.*)'$/, '$1');\r\n      }\r\n\r\n      function buildDateParseRegex (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var re = abstractRegex;\r\n\r\n        // Replace abstracted values\r\n        for (var i = 0; i < dateElements.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\r\n        }\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      function setMapForFormat (format) {\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseValuesMap(re);\r\n      }\r\n\r\n      function buildDateParseValuesMap (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\r\n        var valuesMatch;\r\n        var keyIndex;\r\n        var valueKey;\r\n        var valueFunction;\r\n        var valuesFunctionMap = [];\r\n\r\n        /* eslint-disable no-cond-assign */\r\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\r\n          keyIndex = valuesMatch[1];\r\n          valueKey = dateElements[keyIndex];\r\n          valueFunction = setFnMap[valueKey];\r\n\r\n          valuesFunctionMap.push(valueFunction);\r\n        }\r\n\r\n        return valuesFunctionMap;\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\r\n\r\n  .service('$dateFormatter', function ($locale, dateFilter) {\r\n\r\n    // The unused `lang` arguments are on purpose. The default implementation does not\r\n    // use them and it always uses the locale loaded into the `$locale` service.\r\n    // Custom implementations might use it, thus allowing different directives to\r\n    // have different languages.\r\n\r\n    this.getDefaultLocale = function () {\r\n      return $locale.id;\r\n    };\r\n\r\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\r\n    // Return either the corresponding date format or the given date format.\r\n    this.getDatetimeFormat = function (format, lang) {\r\n      return $locale.DATETIME_FORMATS[format] || format;\r\n    };\r\n\r\n    this.weekdaysShort = function (lang) {\r\n      return $locale.DATETIME_FORMATS.SHORTDAY;\r\n    };\r\n\r\n    this.weekdays = function (lang) {\r\n      return $locale.DATETIME_FORMATS.DAY;\r\n    };\r\n\r\n    function splitTimeFormat (format) {\r\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\r\n    }\r\n\r\n    // h:mm a => h\r\n    this.hoursFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[0];\r\n    };\r\n\r\n    // h:mm a => mm\r\n    this.minutesFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[2];\r\n    };\r\n\r\n    // h:mm:ss a => ss\r\n    this.secondsFormat = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => :\r\n    this.timeSeparator = function (timeFormat) {\r\n      return splitTimeFormat(timeFormat)[1];\r\n    };\r\n\r\n    // h:mm:ss a => true, h:mm a => false\r\n    this.showSeconds = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[4];\r\n    };\r\n\r\n    // h:mm a => true, H.mm => false\r\n    this.showAM = function (timeFormat) {\r\n      return !!splitTimeFormat(timeFormat)[5];\r\n    };\r\n\r\n    this.formatDate = function (date, format, lang, timezone) {\r\n      return dateFilter(date, format, timezone);\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.datepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.helpers.focusElement', 'mgcrea.ngStrap.helpers.ngFocusOut', 'mgcrea.ngStrap.tooltip'])\r\n  .provider('$datepicker', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      // Uncommenting the following line will break backwards compatability\r\n      // prefixEvent: 'datepicker',\r\n      prefixClass: 'datepicker',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'datepicker/datepicker.tpl.html',\r\n      trigger: 'focus',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0,\r\n      // lang: $locale.id,\r\n      useNative: false,\r\n      dateType: 'date',\r\n      dateFormat: 'shortDate',\r\n      timezone: null,\r\n      modelDateFormat: null,\r\n      dayFormat: 'dd',\r\n      monthFormat: 'MMM',\r\n      yearFormat: 'yyyy',\r\n      monthTitleFormat: 'MMMM yyyy',\r\n      yearTitleFormat: 'yyyy',\r\n      strictFormat: false,\r\n      autoclose: false,\r\n      minDate: -Infinity,\r\n      maxDate: +Infinity,\r\n      startView: 0,\r\n      minView: 0,\r\n      startWeek: 0,\r\n      daysOfWeekDisabled: '',\r\n      hasToday: false,\r\n      hasClear: false,\r\n      iconLeft: 'glyphicon glyphicon-chevron-left',\r\n      iconRight: 'glyphicon glyphicon-chevron-right',\r\n      // The format that will be given to the screen reader values placed in the DOM.\r\n      screenReaderDateFormat: 'fullDate',\r\n      // Focuses the table element in the dropdown upon display of the picker.\r\n      // Used mainly in 508 situations when a button is pressed via a keyboard to show the calendar.\r\n      focusOnOpen: false\r\n    };\r\n\r\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\r\n\r\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n      var isTouch = ('createTouch' in $window.document) && isNative;\r\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\r\n\r\n      function DatepickerFactory (element, controller, config) {\r\n\r\n        // The datepicker is based on the tooltip control. Build a basic tooltip from the\r\n        // defaults and the configuration passed.\r\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\r\n        var parentScope = config.scope;\r\n        var options = $datepicker.$options;\r\n        var scope = $datepicker.$scope;\r\n        if (options.startView) options.startView -= options.minView;\r\n\r\n        // Add assistive technology helper attributes.\r\n        element.attr('aria-expanded', 'false').attr('aria-haspopup', 'true');\r\n\r\n        // View vars\r\n\r\n        // Initialize the datepicker view collection by passing a reference to the base object.\r\n        var pickerViews = datepickerViews($datepicker);\r\n        $datepicker.$views = pickerViews.views;\r\n        var viewDate = pickerViews.viewDate;\r\n        /*\r\n         * View mode for the date picker.\r\n         * 0: days\r\n         * 1: months\r\n         * 2: years\r\n         */\r\n        scope.$mode = options.startView;\r\n        // icon class override\r\n        scope.$iconLeft = options.iconLeft;\r\n        scope.$iconRight = options.iconRight;\r\n        // Show buttons at the bottom of the picker.\r\n        scope.$hasToday = options.hasToday;\r\n        scope.$hasClear = options.hasClear;\r\n        /*\r\n         * An id on the element is necessary when working with assistive technologies. The view will use the id to build out the\r\n         * aria attributes which are linked via ids.\r\n         */\r\n        scope.id = options.id !== null && options.id !== undefined ? options.id : undefined;\r\n        scope.dropdownId = options.id !== null && options.id !== undefined ? (options.id + '_dropdown') : undefined;\r\n        scope.keyboard = options.keyboard;\r\n        scope.focusOnOpen = options.focusOnOpen;\r\n\r\n        // labels\r\n        scope.$nextLabel = options.labelNext;\r\n        scope.$previousLabel = options.labelPrevious;\r\n\r\n        // This is the actual current picker view.\r\n        var $picker = $datepicker.$views[scope.$mode];\r\n\r\n        // Internal handlers\r\n\r\n        function handleOnKeyDown (evt, apply) {\r\n          if (!/(33|34|38|37|39|40|13)/.test(evt.keyCode) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.shiftKey) &&\r\n            !(/(33|34|38|37|39|40|13)/.test(evt.keyCode) && evt.altKey)) {\r\n            return false;\r\n          }\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n\r\n          if (evt.keyCode === 13) {\r\n            if (!scope.$mode) {\r\n              $datepicker.hide(true);\r\n              if (options.focusOnOpen) return true;\r\n            } else {\r\n              if (apply === undefined || apply) {\r\n                scope.$apply(function () {\r\n                  $datepicker.setMode(scope.$mode - 1);\r\n                });\r\n              } else {\r\n                $datepicker.setMode(scope.$mode - 1);\r\n              }\r\n            }\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        // Scope methods\r\n\r\n        /**\r\n         * Pass through from the scope to the provider for the selection of a date.\r\n         */\r\n        scope.$select = function (date, disabled) {\r\n          if (disabled) return;\r\n          $datepicker.select(date);\r\n        };\r\n        scope.$selectPane = function (value) {\r\n          $datepicker.$selectPane(value);\r\n        };\r\n        scope.$toggleMode = function () {\r\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\r\n        };\r\n        scope.$setToday = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(new Date());\r\n          } else {\r\n            $datepicker.select(new Date(), true);\r\n          }\r\n        };\r\n        scope.$clear = function () {\r\n          if (options.autoclose) {\r\n            $datepicker.setMode(0);\r\n            $datepicker.select(null);\r\n          } else {\r\n            $datepicker.select(null, true);\r\n          }\r\n        };\r\n        scope.$focused = function (dayInfo) {\r\n          scope.selectedDayId = dayInfo.id;\r\n          if (dayInfo.isNext && !scope.selected) {\r\n            if (scope.$mode) {\r\n              $datepicker.update(dayInfo.date);\r\n            } else {\r\n              scope.$select(dayInfo.date);\r\n            }\r\n          }\r\n        };\r\n        scope.$onKeyDown = function (evt, day) {\r\n          var continueHandling = handleOnKeyDown(evt, false);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n          }\r\n        };\r\n        scope.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inTable = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n              inTable = true;\r\n              break;\r\n            } else {\r\n              inTable = false;\r\n            }\r\n          }\r\n\r\n          // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n          //\r\n\r\n          if (!inTable && !evt.relatedTarget) {\r\n            // hmm\r\n          } else if (!inTable) {\r\n            $datepicker.hide();\r\n          } else {\r\n            evt.stopPropagation();\r\n            evt.preventDefault();\r\n          }\r\n        };\r\n\r\n        // Public methods\r\n\r\n        $datepicker.update = function (date) {\r\n          // console.warn('$datepicker.update() newValue=%o', date);\r\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\r\n            $datepicker.$date = date;\r\n            $picker.update.call($picker, date);\r\n          }\r\n          // Build only if pristine\r\n          $datepicker.$build(true);\r\n        };\r\n\r\n        $datepicker.updateDisabledDates = function (dateRanges) {\r\n          options.disabledDateRanges = dateRanges;\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\r\n          }\r\n        };\r\n\r\n        $datepicker.select = function (date, keep) {\r\n          // console.warn('$datepicker.select', date, scope.$mode);\r\n          if (angular.isDate(date)) {\r\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\r\n              controller.$dateValue = new Date(date);\r\n            }\r\n          } else {\r\n            controller.$dateValue = null;\r\n          }\r\n          if (!scope.$mode || keep) {\r\n            controller.$setViewValue(angular.copy(date));\r\n            controller.$render();\r\n            if (options.autoclose && !keep) {\r\n              $timeout(function () {\r\n                $datepicker.hide(true);\r\n              });\r\n            }\r\n          } else {\r\n            angular.extend(viewDate, {\r\n              year: date.getFullYear(),\r\n              month: date.getMonth(),\r\n              date: date.getDate()\r\n            });\r\n            $datepicker.setMode(scope.$mode - 1);\r\n            $datepicker.$build();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * This changes the mode of the picker. By setting the mode the view for the picker will be\r\n         * rebuilt. The views are days, months, and years.\r\n         * @param {int} mode View mode for the datepicker. 0: day view, 1: month view, 2: year view.\r\n         */\r\n        $datepicker.setMode = function setMode (mode) {\r\n          scope.$mode = mode;\r\n          $picker = $datepicker.$views[scope.$mode];\r\n          // The picker has been changed so the view needs to be built.\r\n          $datepicker.$build();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        /**\r\n         * Builds the datepicker's view based on the picker that is currently set.\r\n         */\r\n        $datepicker.$build = function $build (pristine) {\r\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\r\n          if (pristine === true && $picker.built) return;\r\n          if (pristine === false && !$picker.built) return;\r\n          $picker.build.call($picker);\r\n        };\r\n\r\n        $datepicker.$updateSelected = function () {\r\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\r\n            angular.forEach(scope.rows[i], function (day) {\r\n              updateSelected(day);\r\n              if (day.selected) scope.selected = day;\r\n            });\r\n          }\r\n        };\r\n\r\n        $datepicker.$isSelected = function (date) {\r\n          return $picker.isSelected(date);\r\n        };\r\n\r\n        $datepicker.$setDisabledEl = function (el) {\r\n          el.disabled = $picker.isDisabled(el.date);\r\n        };\r\n\r\n        $datepicker.$selectPane = function (value) {\r\n          var steps = $picker.steps;\r\n          // set targetDate to first day of month to avoid problems with\r\n          // date values rollover. This assumes the viewDate does not\r\n          // depend on the day of the month\r\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\r\n          angular.extend(viewDate, {\r\n            year: targetDate.getUTCFullYear(),\r\n            month: targetDate.getUTCMonth(),\r\n            date: targetDate.getUTCDate()\r\n          });\r\n          $datepicker.$build();\r\n        };\r\n\r\n        $datepicker.$onMouseDown = function (evt) {\r\n          // Prevent blur on mousedown on .dropdown-menu\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Emulate click for mobile devices\r\n          if (isTouch) {\r\n            var targetEl = angular.element(evt.target);\r\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\r\n              targetEl = targetEl.parent();\r\n            }\r\n            targetEl.triggerHandler('click');\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Handles the onKeyDown event from the element that this datepicker is bound.\r\n         * In the standard case this will be an input element. If the trigger is set\r\n         * to click and is bound to a button then it is likely we're servicing a 508\r\n         * type situation where the implementation will no longer uses. Focus will be\r\n         * given to the table.\r\n         */\r\n        $datepicker.$onKeyDown = function (evt) {\r\n          var continueHandling = handleOnKeyDown(evt);\r\n\r\n          if (continueHandling) {\r\n            // Navigate with keyboard\r\n            $picker.onKeyDown(evt);\r\n            parentScope.$digest();\r\n          }\r\n        };\r\n\r\n        // $datepicker.$onFocusOut = function (evt) {\r\n        //   // find out if the related target's parents contain the datepicker's $element\r\n        //   var inTable = false;\r\n        //   var parent = angular.element(evt.relatedTarget);\r\n        //   while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n        //     parent = parent.parent();\r\n        //     if (parent !== undefined && parent[0] === $datepicker.$element[0]) {\r\n        //       inTable = true;\r\n        //       break;\r\n        //     } else {\r\n        //       inTable = false;\r\n        //     }\r\n        //   }\r\n\r\n        //   // In Chrome there is an issue when moving from month to month, year to year, etc.\r\n        //   //\r\n\r\n        //   if (!inTable && !evt.relatedTarget) {\r\n        //     // hmm\r\n        //   } else if (!inTable) {\r\n        //     $datepicker.hide();\r\n        //   } else {\r\n        //     evt.stopPropagation();\r\n        //     evt.preventDefault();\r\n        //   }\r\n        // };\r\n\r\n        // Private\r\n\r\n        function updateSelected (el) {\r\n          el.selected = $datepicker.$isSelected(el.date);\r\n          el.focused = el.selected;\r\n        }\r\n\r\n        function focusElement () {\r\n          element[0].focus();\r\n        }\r\n\r\n        // Overrides\r\n\r\n        // The datepicker will override the init functionality of the tool\r\n        var _init = $datepicker.init;\r\n        /**\r\n         * Initialize the datepicker.\r\n         */\r\n        $datepicker.init = function () {\r\n          if (isNative && options.useNative) {\r\n            element.prop('type', 'date');\r\n            element.css('-webkit-appearance', 'textfield');\r\n            return;\r\n          } else if (isTouch) {\r\n            element.prop('type', 'text');\r\n            element.attr('readonly', 'true');\r\n            element.on('click', focusElement);\r\n          }\r\n          _init();\r\n        };\r\n\r\n        // The datepicker will override the destroy functionalty of the tooltip. Storing a ref to the\r\n        // tooltip's destroy function so that it can be invoked when the datepicker needs to be destroyed.\r\n        var _destroy = $datepicker.destroy;\r\n\r\n        /**\r\n         * Destroys the datepicker by removing bound events. Calls the destroy function on the tooltip.\r\n         */\r\n        $datepicker.destroy = function () {\r\n          if (isNative && options.useNative) {\r\n            element.off('click', focusElement);\r\n          }\r\n          _destroy();\r\n        };\r\n\r\n        // The datepicker will override the show functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be shown.\r\n        var _show = $datepicker.show;\r\n\r\n        /**\r\n         * Override for the tooltip's show function.\r\n         *\r\n         * Checks the element for readonly or disabled before showing the \"tooltip\".\r\n         * Once shown it sets up the appropriate events.\r\n         */\r\n        $datepicker.show = function show () {\r\n          // If the input the directive is bound to is readonly or disabled then do not show a picker.\r\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\r\n\r\n          // Call the \"overriden base\" function on the tooltip.\r\n          _show();\r\n\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // if $datepicker is no longer showing, don't setup events\r\n            if (!$datepicker.$isShown) return;\r\n\r\n            // Update assistive technologies for view changes:\r\n            $datepicker.$element.attr('aria-hidden', 'false');\r\n            element.attr('aria-expanded', 'true');\r\n\r\n            // Setup the event mouse click event. TODO: Can this be wired up in the view?\r\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n            // If keyboard navigation is enabled (true by default).\r\n            if (options.keyboard) {\r\n              // $datepicker.$element.on('keydown', $datepicker.$onKeyDown);\r\n              // Check to see if the table element should receive the focus when the picker is shown.\r\n              if (options.focusOnOpen) {\r\n                // Focus the table element.\r\n                // $datepicker.$element.find('table')[0].focus();\r\n                // $datepicker.$element.on('focusout', $datepicker.$onFocusOut);\r\n              } else {\r\n                element.on('keydown', $datepicker.$onKeyDown);\r\n              }\r\n            }\r\n          }, 0, false);\r\n        };\r\n\r\n        // The datepicker will override the hide functionality of the tooltip. Store a ref to the\r\n        // tooltip's show function so that it can be invoked at the appropriate time when the picker\r\n        // is to be hidden.\r\n        var _hide = $datepicker.hide;\r\n\r\n        /**\r\n         * Overrid efor the tooltip's hide function.\r\n         *\r\n         * Updates attributes for assistive technologies and unbinds events.\r\n         */\r\n        $datepicker.hide = function (blur) {\r\n          // If the picker is already hidden don't do anything.\r\n          if (!$datepicker.$isShown) return;\r\n\r\n          // Update the attributes used by assisteive technologies\r\n          $datepicker.$element.attr('aria-hidden', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          // Unbind the mouse and touch events\r\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\r\n\r\n          // If keyboard events were bound then unbind them.\r\n          if (options.keyboard) {\r\n            element.off('keydown', $datepicker.$onKeyDown);\r\n            $datepicker.$element.off('keydown', $datepicker.$onKeyDown);\r\n          }\r\n          if (options.focusOnOpen) {\r\n            // $datepicker.$element.off('focusout', $datepicker.$onFocusOut);\r\n            element[0].focus();\r\n          }\r\n          // Call the tooltip's hide function.\r\n          _hide(blur);\r\n        };\r\n\r\n        return $datepicker;\r\n      }\r\n\r\n      DatepickerFactory.defaults = defaults;\r\n      return DatepickerFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\r\n\r\n    // var defaults = $datepicker.defaults;\r\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear', 'focusOnOpen', 'labelNext', 'labelPrevious', 'labelMonth', 'labelYear', 'labelDays'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear', 'focusOnOpen'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\r\n            options[key] = false;\r\n          }\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Initialize datepicker\r\n        var datepicker = $datepicker(element, controller, options);\r\n        options = datepicker.$options;\r\n        // Set expected iOS format\r\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Visibility binding support\r\n        if (attr.bsShow) {\r\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n            if (!datepicker || !angular.isDefined(newValue)) return;\r\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\r\n            if (newValue === true) {\r\n              datepicker.show();\r\n            } else {\r\n              datepicker.hide();\r\n            }\r\n          });\r\n        }\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          // console.warn('attr.$observe(%s)', key, attr[key]);\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\r\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              // Build only if dirty\r\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            datepicker.$options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        // Watch model for changes\r\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\r\n          datepicker.update(controller.$dateValue);\r\n        }, true);\r\n\r\n        // Normalize undefined/null/empty array,\r\n        // so that we don't treat changing from undefined->null as a change.\r\n        function normalizeDateRanges (ranges) {\r\n          if (!ranges || !ranges.length) return null;\r\n          return ranges;\r\n        }\r\n\r\n        if (angular.isDefined(attr.disabledDates)) {\r\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\r\n            disabledRanges = normalizeDateRanges(disabledRanges);\r\n            previousValue = normalizeDateRanges(previousValue);\r\n\r\n            if (disabledRanges) {\r\n              datepicker.updateDisabledDates(disabledRanges);\r\n            }\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\r\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n          return new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        // viewValue -> element\r\n        controller.$render = function () {\r\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\r\n          element.val(getDateFormattedString());\r\n        };\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (datepicker) datepicker.destroy();\r\n          options = null;\r\n          datepicker = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDatepickerDisplay', function ($datepicker, $dateParser, $dateFormatter) {\r\n    return {\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n        // Directive options\r\n        var options = {\r\n          scope: scope\r\n        };\r\n        angular.forEach(['dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'lang'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        options = angular.extend({}, $datepicker.defaults, options);\r\n\r\n        var lang = options.lang;\r\n\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        // Observe attributes for changes\r\n        angular.forEach(['minDate', 'maxDate'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            attr.$observe(key, function (newValue) {\r\n              options[key] = dateParser.getDateForAttribute(key, newValue);\r\n              validateAgainstMinMaxDate(controller.$dateValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Observe date format\r\n        if (angular.isDefined(attr.dateFormat)) {\r\n          attr.$observe('dateFormat', function (newValue) {\r\n            options.dateFormat = newValue;\r\n          });\r\n        }\r\n\r\n        function validateAgainstMinMaxDate (parsedDate) {\r\n          if (!angular.isDate(parsedDate)) return;\r\n          var isMinValid = isNaN(options.minDate) || parsedDate.getTime() >= options.minDate;\r\n          var isMaxValid = isNaN(options.maxDate) || parsedDate.getTime() <= options.maxDate;\r\n          var isValid = isMinValid && isMaxValid;\r\n          controller.$setValidity('date', isValid);\r\n          controller.$setValidity('min', isMinValid);\r\n          controller.$setValidity('max', isMaxValid);\r\n          // Only update the model when we have a valid date\r\n          if (isValid) controller.$dateValue = parsedDate;\r\n        }\r\n\r\n        // viewValue -> $parsers -> modelValue\r\n        controller.$parsers.unshift(function (viewValue) {\r\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\r\n          var date;\r\n          // Null values should correctly reset the model value & validity\r\n          if (!viewValue) {\r\n            controller.$setValidity('date', true);\r\n            // BREAKING CHANGE:\r\n            // return null (not undefined) when input value is empty, so angularjs 1.3\r\n            // ngModelController can go ahead and run validators, like ngRequired\r\n            return null;\r\n          }\r\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\r\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\r\n            controller.$setValidity('date', false);\r\n            // return undefined, causes ngModelController to\r\n            // invalidate model value\r\n            return;\r\n          }\r\n          validateAgainstMinMaxDate(parsedDate);\r\n\r\n          if (options.dateType === 'string') {\r\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\r\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\r\n          }\r\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\r\n          if (options.dateType === 'number') {\r\n            return date.getTime();\r\n          } else if (options.dateType === 'unix') {\r\n            return date.getTime() / 1000;\r\n          } else if (options.dateType === 'iso') {\r\n            return date.toISOString();\r\n          }\r\n\r\n          return date === null ? null : new Date(date);\r\n        });\r\n\r\n        // modelValue -> $formatters -> viewValue\r\n        controller.$formatters.push(function (modelValue) {\r\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n          var date;\r\n          if (angular.isUndefined(modelValue) || modelValue === null) {\r\n            date = NaN;\r\n          } else if (angular.isDate(modelValue)) {\r\n            date = modelValue;\r\n          } else if (options.dateType === 'string') {\r\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\r\n          } else if (options.dateType === 'unix') {\r\n            date = new Date(modelValue * 1000);\r\n          } else {\r\n            date = new Date(modelValue);\r\n          }\r\n          // Setup default value?\r\n          // if (isNaN(date.getTime())) {\r\n          //   var today = new Date();\r\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\r\n          // }\r\n          // do not adjust date if timezone is UTC\r\n          if (options.timezone === 'UTC') {\r\n            controller.$dateValue = date;\r\n          } else {\r\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\r\n          }\r\n\r\n          return getDateFormattedString();\r\n        });\r\n\r\n        function getDateFormattedString () {\r\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\r\n        }\r\n      }\r\n    };\r\n  })\r\n\r\n  .provider('datepickerViews', function () {\r\n\r\n    // var defaults = this.defaults = {\r\n    //   dayFormat: 'dd',\r\n    //   daySplit: 7\r\n    // };\r\n\r\n    // Split array into smaller arrays\r\n    function split (arr, size) {\r\n      var arrays = [];\r\n      while (arr.length > 0) {\r\n        arrays.push(arr.splice(0, size));\r\n      }\r\n      return arrays;\r\n    }\r\n\r\n    // Modulus operator\r\n    function mod (n, m) {\r\n      return ((n % m) + m) % m;\r\n    }\r\n\r\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\r\n\r\n      return function (picker) {\r\n\r\n        var scope = picker.$scope;\r\n        var options = picker.$options;\r\n\r\n        var lang = options.lang;\r\n        var formatDate = function (date, format) {\r\n          return $dateFormatter.formatDate(date, format, lang);\r\n        };\r\n        var dateParser = $dateParser({\r\n          format: options.dateFormat,\r\n          lang: lang,\r\n          strict: options.strictFormat\r\n        });\r\n\r\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\r\n        var weekDaysLong = $dateFormatter.weekdays(lang);\r\n        var weekDaysShortLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n        var weekDaysLongLabels = weekDaysLong.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\r\n\r\n        var weekDaysLabelsHtml = '';\r\n        for (var i = 0; i < weekDaysShortLabels.length; i++) {\r\n          var weekDayShortLabel = weekDaysShortLabels[i];\r\n          var weekDayLabel = weekDaysLongLabels[i];\r\n          weekDaysLabelsHtml += '<th scope=\"col\" role=\"columnheader\" class=\"dow text-center\" aria-label=\"' + weekDayLabel + '\"><abbr title=\"' + weekDayLabel + '\">' + weekDayShortLabel + '</abbr></th>';\r\n        }\r\n        weekDaysLabelsHtml = $sce.trustAsHtml(weekDaysLabelsHtml);\r\n\r\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\r\n        var viewDate = {\r\n          year: startDate.getFullYear(),\r\n          month: startDate.getMonth(),\r\n          date: startDate.getDate()\r\n        };\r\n\r\n        var views = [{\r\n          format: options.dayFormat,\r\n          split: 7,\r\n          steps: {\r\n            month: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\r\n              // chaging picker current month will cause viewDate.date to be set to first day of the month,\r\n              // in $datepicker.$selectPane, so picker would not update selected day display if\r\n              // user picks first day of the new month.\r\n              // As a workaround, we are always forcing update when picked date is first day of month.\r\n              viewDate.date = picker.$date.getDate();\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\r\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\r\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\r\n            var firstDateOffset = firstDate.getTimezoneOffset();\r\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\r\n            // Handle daylight time switch\r\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\r\n            var days = [];\r\n            var day;\r\n            var selectedDay;\r\n            var todayDay;\r\n            for (var i = 0; i < 42; i++) { // < 7 * 6\r\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\r\n              // push the day information onto the collection\r\n              var dayItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: day,\r\n                value: day.getDate(),\r\n                isToday: day.toDateString() === today,\r\n                label: formatDate(day, this.format),\r\n                screenReaderLabel: formatDate(day, $dateFormatter.getDatetimeFormat(options.screenReaderDateFormat)),\r\n                selected: picker.$date && this.isSelected(day),\r\n                muted: day.getMonth() !== viewDate.month,\r\n                disabled: this.isDisabled(day)\r\n              };\r\n\r\n              if (dayItem.selected) selectedDay = dayItem;\r\n              if (dayItem.isToday) todayDay = dayItem;\r\n\r\n              days.push(dayItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedDay) {\r\n                scope.selectedDayId = selectedDay.id;\r\n                if (todayDay) todayDay.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedDay.focused = true;\r\n                scope.selected = selectedDay;\r\n              } else if (todayDay) {\r\n                todayDay.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\r\n            scope.showLabels = true;\r\n            scope.labels = weekDaysLabelsHtml;\r\n            scope.rows = split(days, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.isTodayDisabled = this.isDisabled(new Date());\r\n            scope.hasSelectedDate = picker.$date != null;\r\n            scope.$modeLabel = options.labelMonth;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() &&\r\n              date.getMonth() === picker.$date.getMonth() &&\r\n              date.getDate() === picker.$date.getDate();\r\n          },\r\n          isDisabled: function (date) {\r\n            var time = date.getTime();\r\n\r\n            // Disabled because of min/max date.\r\n            if (time < options.minDate || time > options.maxDate) return true;\r\n\r\n            // Disabled due to being a disabled day of the week\r\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\r\n\r\n            // Disabled because of disabled date range.\r\n            if (options.disabledDateRanges) {\r\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\r\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n\r\n            return false;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            var actualTime;\r\n\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date) {\r\n              if (angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n                picker.$date = new Date();\r\n              } else {\r\n                picker.$date = dateParser.parse(angular.element(evt.target).attr('aria-label'), null, options.screenReaderDateFormat);\r\n              }\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return false;\r\n            }\r\n\r\n            actualTime = picker.$date.getTime();\r\n\r\n            var newDate;\r\n\r\n            switch (evt.keyCode) {\r\n              // enter\r\n              case 13:\r\n                if (options.focusOnOpen) {\r\n                  picker.select(new Date(actualTime), true);\r\n                  return false;\r\n                }\r\n                break;\r\n                // pageup\r\n              case 33:\r\n                if (evt.altKey) { // move back a year\r\n                  newDate = new Date(picker.$date.getFullYear() - 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move back a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() - 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() - 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth(), 0);\r\n                  }\r\n                }\r\n                break;\r\n\r\n                // pagedown\r\n              case 34:\r\n                if (evt.altKey) { // move forward a year\r\n                  newDate = new Date(picker.$date.getFullYear() + 1, picker.$date.getMonth(), picker.$date.getDate());\r\n                } else { // move forward a month\r\n                  newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, picker.$date.getDate());\r\n                  if (newDate.getMonth() > (picker.$date.getMonth() + 1)) {\r\n                    newDate = new Date(picker.$date.getFullYear(), picker.$date.getMonth() + 1, 1);\r\n                  }\r\n                }\r\n\r\n                break;\r\n\r\n                // left arrow\r\n              case 37:\r\n                newDate = new Date(actualTime - 1 * 864e5);\r\n                break;\r\n\r\n                // up arrow\r\n              case 38:\r\n                newDate = new Date(actualTime - 7 * 864e5);\r\n                break;\r\n\r\n                // right arrow\r\n              case 39:\r\n                newDate = new Date(actualTime + 1 * 864e5);\r\n                break;\r\n\r\n                // down arrow\r\n              case 40:\r\n                newDate = new Date(actualTime + 7 * 864e5);\r\n                break;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n\r\n            if (evt && evt.stopPropagation) evt.stopPropagation();\r\n\r\n            return false;\r\n          }\r\n        }, {\r\n          name: 'month',\r\n          format: options.monthFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 1\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getMonth() !== viewDate.month) {\r\n              angular.extend(viewDate, {\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            // var firstMonth = new Date(viewDate.year, 0, 1);\r\n            var months = [];\r\n            var month;\r\n            var thisMonthDate = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            var selectedMonth;\r\n            var thisMonth;\r\n            for (var i = 0; i < 12; i++) {\r\n              month = new Date(viewDate.year, i, 1);\r\n\r\n              var monthItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: month,\r\n                label: formatDate(month, this.format),\r\n                selected: picker.$isSelected(month),\r\n                isToday: month.getFullYear() === thisMonthDate.getFullYear() && month.getMonth() === thisMonthDate.getMonth(),\r\n                disabled: this.isDisabled(month)\r\n              };\r\n\r\n              if (monthItem.selected) selectedMonth = monthItem;\r\n              if (monthItem.isToday) thisMonth = monthItem;\r\n\r\n              months.push(monthItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedMonth) {\r\n                scope.selectedDayId = selectedMonth.id;\r\n                if (thisMonth) thisMonth.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedMonth.focused = true;\r\n                scope.selected = selectedMonth;\r\n              } else if (thisMonth) {\r\n                thisMonth.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = formatDate(month, options.yearTitleFormat);\r\n            scope.showLabels = false;\r\n            scope.rows = split(months, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modeLabel = options.labelYear;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), (new Date()).getMonth(), 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualMonth = picker.$date.getMonth();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\r\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\r\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\r\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\r\n\r\n            if (options.focusOnOpen && evt.keyCode === 13) picker.select(new Date(picker.$date));\r\n            else if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }, {\r\n          name: 'year',\r\n          format: options.yearFormat,\r\n          split: 4,\r\n          steps: {\r\n            year: 12\r\n          },\r\n          update: function (date, force) {\r\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$build();\r\n            } else if (date.getFullYear() !== viewDate.year) {\r\n              angular.extend(viewDate, {\r\n                year: picker.$date.getFullYear(),\r\n                month: picker.$date.getMonth(),\r\n                date: picker.$date.getDate()\r\n              });\r\n              picker.$updateSelected();\r\n            }\r\n          },\r\n          build: function () {\r\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\r\n            var years = [];\r\n            var year;\r\n            var selectedYear;\r\n            var thisYear;\r\n            for (var i = 0; i < 12; i++) {\r\n              year = new Date(firstYear + i, 0, 1);\r\n\r\n              var yearItem = {\r\n                id: options.id !== null && options.id !== undefined ? (options.id + '_cell_' + i) : undefined,\r\n                date: year,\r\n                label: formatDate(year, this.format),\r\n                selected: picker.$isSelected(year),\r\n                isToday: year.getFullYear() === (new Date()).getFullYear(),\r\n                disabled: this.isDisabled(year)\r\n              };\r\n\r\n              if (yearItem.selected) selectedYear = yearItem;\r\n              if (yearItem.isToday) thisYear = yearItem;\r\n\r\n              years.push(yearItem);\r\n            }\r\n\r\n            scope.selected = null;\r\n\r\n            var defaultFirstDayTabIndex = false;\r\n            // Setup the focusing\r\n            if (options.focusOnOpen) {\r\n              if (selectedYear) {\r\n                scope.selectedDayId = selectedYear.id;\r\n                if (thisYear) thisYear.focused = false;\r\n                // Needs to fire after the today focusing is unset in case the selected day is today.\r\n                selectedYear.focused = true;\r\n                scope.selected = selectedYear;\r\n              } else if (thisYear) {\r\n                thisYear.focused = true;\r\n              } else {\r\n                defaultFirstDayTabIndex = true;\r\n              }\r\n            }\r\n\r\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\r\n            scope.startYear = years[0].label;\r\n            scope.endYear = years[years.length - 1].label;\r\n            scope.showLabels = false;\r\n            scope.rows = split(years, this.split);\r\n            if (defaultFirstDayTabIndex) {\r\n              scope.rows[0][0].isNext = true;\r\n            }\r\n            scope.$modelLabel = options.labelDays;\r\n            this.built = true;\r\n          },\r\n          isSelected: function (date) {\r\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\r\n          },\r\n          isDisabled: function (date) {\r\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\r\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\r\n          },\r\n          onKeyDown: function (evt) {\r\n            // If the picker doesn't have a date selected and the event comes from the today TD\r\n            // then set the picker's $date to today and set the actual time to its value.\r\n            if (options.keyboard &&\r\n              options.focusOnOpen &&\r\n              !picker.$date &&\r\n              angular.element(evt.target).find('span').hasClass('btn-today')) {\r\n              picker.$date = new Date((new Date()).getFullYear(), 0, 1);\r\n            }\r\n\r\n            if (!picker.$date) {\r\n              return;\r\n            }\r\n            var actualYear = picker.$date.getFullYear();\r\n            var newDate = new Date(picker.$date);\r\n\r\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\r\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\r\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\r\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\r\n\r\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\r\n          }\r\n        }];\r\n\r\n        return {\r\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\r\n          viewDate: viewDate\r\n        };\r\n\r\n      };\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\r\n\r\n  .provider('$dropdown', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'dropdown',\r\n      prefixEvent: 'dropdown',\r\n      placement: 'bottom-left',\r\n      templateUrl: 'dropdown/dropdown.tpl.html',\r\n      trigger: 'click',\r\n      container: false,\r\n      keyboard: true,\r\n      html: false,\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\r\n\r\n      function DropdownFactory (element, config) {\r\n\r\n        var $dropdown = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        /* var scope = */\r\n        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        $dropdown = $tooltip(element, options);\r\n        var parentEl = element.parent();\r\n\r\n        if (element && element[0] && element[0].tagName.toUpperCase() === 'BUTTON') {\r\n          element.attr('aria-haspopup', 'true');\r\n          element.attr('aria-expanded', 'false');\r\n        }\r\n\r\n        // Protected methods\r\n\r\n        $dropdown.$onKeyDown = function (evt) {\r\n          if (evt.keyCode === 9 || evt.keyCode === 27) {\r\n            $dropdown.hide(/27/.test(evt.keyCode));\r\n            return;\r\n          } else if ($dropdown.$element && (evt.keyCode === 38 || evt.keyCode === 40 || evt.keyCode === 32 || evt.keyCode === 13)) {\r\n            //$dropdown.$element.focus();\r\n\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n\r\n            // Retrieve active index\r\n            var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n            if (!items.length) return;\r\n            var index;\r\n            angular.forEach(items, function (el, i) {\r\n              if (matchesSelector && matchesSelector.call(el, '.active')) {\r\n                index = i;\r\n                angular.element(el).removeClass('active');\r\n              }\r\n            });\r\n\r\n            // Navigate with keyboard\r\n            if (evt.keyCode === 32 || evt.keyCode === 13) {\r\n              items.eq(index).click();\r\n            } else if (evt.keyCode === 38 && index > 0) index--;\r\n            else if (evt.keyCode === 38 && (angular.isUndefined(index) || index === 0)) index = items.length - 1;\r\n            else if (evt.keyCode === 40 && index < items.length - 1) index++;\r\n            else if (evt.keyCode === 40 && index === items.length - 1) index = 0;\r\n            else if (angular.isUndefined(index)) index = 0;\r\n            items.eq(index).addClass('active');\r\n            $dropdown.$element.attr('aria-activedescendant', items.eq(index).attr('id'));\r\n\t\t\titems.eq(index)[0].focus();\r\n          }\r\n        };\r\n\r\n        $dropdown.$onFocusOut = function (evt) {\r\n          // find out if the related target's parents contain the datepicker's $element\r\n          var inMenu = false;\r\n          var parent = angular.element(evt.relatedTarget);\r\n          while (parent !== undefined && parent.length && parent[0] !== $window.document.body) {\r\n            parent = parent.parent();\r\n            if (parent !== undefined && parent[0] === $dropdown.$element[0]) {\r\n              inMenu = true;\r\n              break;\r\n            } else {\r\n              inMenu = false;\r\n            }\r\n          }\r\n\r\n          if (!inMenu) {\r\n            $dropdown.hide();\r\n          } else {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        // Overrides\r\n\r\n        var show = $dropdown.show;\r\n        $dropdown.show = function () {\r\n          show();\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function () {\r\n            // Set assistive technology properties\r\n            element.attr('aria-expanded', 'true');\r\n            if ($dropdown.$element) {\r\n              $dropdown.$element.attr('aria-activedescendant', '');\r\n              $dropdown.$element.attr('role', 'menu');\r\n              $dropdown.$element.attr('tabindex', '-1');\r\n            }\r\n            if (options.keyboard && $dropdown.$element) {\r\n              $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\r\n              $dropdown.$element.on('focusout', $dropdown.$onFocusOut);\r\n            }\r\n\r\n            bodyEl.on('click', onBodyClick);\r\n\r\n            if ($dropdown.$element) {\r\n              var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider)'));\r\n              // <li> should have role=\"none\" as per SS-9603\r\n              items.attr('role', 'none');\r\n\r\n              angular.element($dropdown.$element[0].querySelectorAll('li.divider')).attr('role', 'seperator');\r\n\r\n              items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\r\n              items.attr('role', 'menuitem');\r\n              if (items.length && options.keyboard) {\r\n                // Dropdown menu items that are natively focusable need to have a tabindex of -1 per SS-9603\r\n                // Menu item ID's should be unique for aria-activedescendant\r\n                angular.forEach(items, function (value, key) {\r\n                  angular.element(value).attr('id', $dropdown.$scope.$id + '_menuitem_' + key);\r\n                  angular.element(value).attr('tabindex', '-1');\r\n                });\r\n              }\r\n            }\r\n          }, 0, false);\r\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\r\n        };\r\n\r\n        var hide = $dropdown.hide;\r\n        $dropdown.hide = function (returnFocus) {\r\n          if (!$dropdown.$isShown) return;\r\n\r\n          element.attr('aria-expanded', 'false');\r\n\r\n          if (options.keyboard && $dropdown.$element) {\r\n            $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\r\n            $dropdown.$element.off('focusout', $dropdown.$onFocusOut);\r\n          }\r\n\r\n          bodyEl.off('click', onBodyClick);\r\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\r\n          $timeout(function () {\r\n            hide();\r\n            if (returnFocus) {\r\n              $timeout(function () {\r\n                if (element && element[0]) {\r\n                  element[0].focus();\r\n                }\r\n              }, 0, false);\r\n            }\r\n          }, 200);\r\n        };\r\n\r\n        var destroy = $dropdown.destroy;\r\n        $dropdown.destroy = function () {\r\n          bodyEl.off('click', onBodyClick);\r\n          destroy();\r\n        };\r\n\r\n        // Private functions\r\n\r\n        function onBodyClick (evt) {\r\n          if (evt.target === element[0]) return undefined;\r\n          return evt.target !== element[0] && $dropdown.hide();\r\n        }\r\n\r\n        return $dropdown;\r\n\r\n      }\r\n\r\n      return DropdownFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      compile: function (tElement, tAttrs) {\r\n\r\n        // Support for inlined template (next sibling)\r\n        // It must be fetched before compilation\r\n        if (!tAttrs.bsDropdown) {\r\n          var nextSibling = tElement[0].nextSibling;\r\n          while (nextSibling && nextSibling.nodeType !== 1) {\r\n            nextSibling = nextSibling.nextSibling;\r\n          }\r\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\r\n            tAttrs.template = nextSibling.outerHTML;\r\n            tAttrs.templateUrl = undefined;\r\n            nextSibling.parentNode.removeChild(nextSibling);\r\n          }\r\n        }\r\n\r\n        return function postLink (scope, element, attr) {\r\n\r\n          // Directive options\r\n          var options = {\r\n            scope: scope\r\n          };\r\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\r\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\r\n          });\r\n\r\n          // use string regex match boolean attr falsy values, leave truthy values be\r\n          var falseValueRegExp = /^(false|0|)$/i;\r\n          angular.forEach(['html', 'container'], function (key) {\r\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n          });\r\n\r\n          // bind functions from the attrs to the show and hide events\r\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n            if (angular.isDefined(attr[bsKey])) {\r\n              options[key] = scope.$eval(attr[bsKey]);\r\n            }\r\n          });\r\n\r\n          // Support scope as an object\r\n          if (attr.bsDropdown) {\r\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\r\n              scope.content = newValue;\r\n            }, true);\r\n          }\r\n\r\n          // Initialize dropdown\r\n          var dropdown = $dropdown(element, options);\r\n\r\n          // Pickup key press on the dropdown button\r\n          element.on('keydown',function (evt) {\r\n            if (evt.keyCode === 38 || evt.keyCode === 40 || evt.keyCode === 27 || evt.keyCode === 9) {\r\n              dropdown.$onKeyDown(evt);\r\n            }\r\n          });\r\n\r\n          // Visibility binding support\r\n          if (attr.bsShow) {\r\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\r\n              if (!dropdown || !angular.isDefined(newValue)) return;\r\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\r\n              if (newValue === true) {\r\n                dropdown.show();\r\n              } else {\r\n                dropdown.hide();\r\n              }\r\n            });\r\n          }\r\n\r\n          // Garbage collection\r\n          scope.$on('$destroy', function () {\r\n            if (dropdown) dropdown.destroy();\r\n            options = null;\r\n            dropdown = null;\r\n          });\r\n\r\n        };\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.collapse', [])\r\n\r\n  .provider('$collapse', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-collapse',\r\n      disallowToggle: false,\r\n      activeClass: 'in',\r\n      startCollapsed: false,\r\n      allowMultiple: false\r\n    };\r\n\r\n    var controller = this.controller = function ($scope, $element, $attrs) {\r\n      var self = this;\r\n\r\n      // Attributes options\r\n      self.$options = angular.copy(defaults);\r\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\r\n      });\r\n\r\n      // use string regex match boolean attr falsy values, leave truthy values be\r\n      var falseValueRegExp = /^(false|0|)$/i;\r\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\r\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\r\n          self.$options[key] = false;\r\n        }\r\n      });\r\n\r\n      self.$toggles = [];\r\n      self.$targets = [];\r\n\r\n      self.$viewChangeListeners = [];\r\n\r\n      self.$registerToggle = function (element) {\r\n        self.$toggles.push(element);\r\n        element.attr('aria-expanded', 'false');\r\n      };\r\n      self.$registerTarget = function (element) {\r\n        self.$targets.push(element);\r\n\r\n        var i = 0;\r\n        if (self.$targets) {\r\n          for (i = 0; i < self.$targets.length; i++) {\r\n            self.$targets[i].attr('aria-hidden', 'true');\r\n          }\r\n          for (i = 0; i < self.$targets.$active.length; i++) {\r\n            if (self.$targets[self.$targets.$active[i]]) {\r\n              self.$targets[self.$targets.$active[i]].attr('aria-hidden', 'false');\r\n            }\r\n            if (self.$toggles[self.$targets.$active[i]]) {\r\n              self.$toggles[self.$targets.$active[i]].attr('aria-expanded', 'true');\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      self.$unregisterToggle = function (element) {\r\n        var index = self.$toggles.indexOf(element);\r\n        // remove toggle from $toggles array\r\n        self.$toggles.splice(index, 1);\r\n      };\r\n      self.$unregisterTarget = function (element) {\r\n        var index = self.$targets.indexOf(element);\r\n\r\n        // remove element from $targets array\r\n        self.$targets.splice(index, 1);\r\n\r\n        if (self.$options.allowMultiple) {\r\n          // remove target index from $active array values\r\n          deactivateItem(element);\r\n        }\r\n\r\n        // fix active item indexes\r\n        fixActiveItemIndexes(index);\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      // use array to store all the currently open panels\r\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\r\n      self.$setActive = $scope.$setActive = function (value) {\r\n        if (angular.isArray(value)) {\r\n          self.$targets.$active = value;\r\n        } else if (!self.$options.disallowToggle && isActive(value)) {\r\n          deactivateItem(value);\r\n        } else {\r\n          activateItem(value);\r\n        }\r\n\r\n        self.$viewChangeListeners.forEach(function (fn) {\r\n          fn();\r\n        });\r\n      };\r\n\r\n      self.$activeIndexes = function () {\r\n        if (self.$options.allowMultiple) {\r\n          return self.$targets.$active;\r\n        }\r\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\r\n      };\r\n\r\n      function fixActiveItemIndexes (index) {\r\n        // item with index was removed, so we\r\n        // need to adjust other items index values\r\n        var activeIndexes = self.$targets.$active;\r\n        for (var i = 0; i < activeIndexes.length; i++) {\r\n          if (index < activeIndexes[i]) {\r\n            activeIndexes[i] = activeIndexes[i] - 1;\r\n          }\r\n\r\n          // the last item is active, so we need to\r\n          // adjust its index\r\n          if (activeIndexes[i] === self.$targets.length) {\r\n            activeIndexes[i] = self.$targets.length - 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      function isActive (value) {\r\n        var activeItems = self.$targets.$active;\r\n        return activeItems.indexOf(value) !== -1;\r\n      }\r\n\r\n      function deactivateItem (value) {\r\n        var index = self.$targets.$active.indexOf(value);\r\n        if (index !== -1) {\r\n          self.$targets[self.$targets.$active[index]].attr('aria-hidden', 'true');\r\n          self.$toggles[self.$targets.$active[index]].attr('aria-expanded', 'false');\r\n          self.$targets.$active.splice(index, 1);\r\n        }\r\n      }\r\n\r\n      function activateItem (value) {\r\n        if (!self.$options.allowMultiple) {\r\n          // remove current selected item\r\n          if (self.$targets[self.$targets.$active[0]] !== undefined) {\r\n            self.$targets[self.$targets.$active[0]].attr('aria-hidden', 'true');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[0]]) {\r\n            self.$toggles[self.$targets.$active[0]].attr('aria-expanded', 'false');\r\n          }\r\n          self.$targets.$active.splice(0, 1);\r\n        }\r\n\r\n        if (self.$targets.$active.indexOf(value) === -1) {\r\n          self.$targets.$active.push(value);\r\n\r\n          if (self.$targets[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$targets[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-hidden', 'false');\r\n          }\r\n          if (self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]] !== undefined) {\r\n            self.$toggles[self.$targets.$active[self.$targets.$active.length - 1]].attr('aria-expanded', 'true');\r\n          }\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    this.$get = function () {\r\n      var $collapse = {};\r\n      $collapse.defaults = defaults;\r\n      $collapse.controller = controller;\r\n      return $collapse;\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\r\n\r\n    return {\r\n      require: ['?ngModel', 'bsCollapse'],\r\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        if (ngModelCtrl) {\r\n\r\n          // Update the modelValue following\r\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\r\n          });\r\n\r\n          // modelValue -> $formatters -> viewValue\r\n          ngModelCtrl.$formatters.push(function (modelValue) {\r\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            if (angular.isArray(modelValue)) {\r\n              // model value is an array, so just replace\r\n              // the active items directly\r\n              bsCollapseCtrl.$setActive(modelValue);\r\n            } else {\r\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\r\n\r\n              if (angular.isArray(activeIndexes)) {\r\n                // we have an array of selected indexes\r\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\r\n                  // item with modelValue index is not active\r\n                  bsCollapseCtrl.$setActive(modelValue * 1);\r\n                }\r\n              } else if (activeIndexes !== modelValue * 1) {\r\n                bsCollapseCtrl.$setActive(modelValue * 1);\r\n              }\r\n            }\r\n            return modelValue;\r\n          });\r\n\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseToggle', function () {\r\n    var KEY_CODES = {\r\n      ENTER: 13,\r\n      SPACE: 32\r\n    };\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base attr\r\n        element.attr('data-toggle', 'collapse');\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerToggle(element);\r\n\r\n        // remove toggle from collapse controller when toggle is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterToggle(element);\r\n        });\r\n\r\n        var actionEventHandler = function () {\r\n          if (!attrs.disabled) {\r\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\r\n            bsCollapseCtrl.$setActive(index * 1);\r\n            scope.$apply();\r\n          }\r\n        };\r\n\r\n        element.on('click', actionEventHandler);\r\n        element.on('keydown keypress', function (e) {\r\n          if (e.which === KEY_CODES.ENTER || e.which === KEY_CODES.SPACE) {\r\n            console.log('key handler handling');\r\n            actionEventHandler();\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCollapseTarget', function ($animate) {\r\n\r\n    return {\r\n      require: ['^?ngModel', '^bsCollapse'],\r\n      // scope: true,\r\n      link: function postLink (scope, element, attrs, controllers) {\r\n\r\n        // var ngModelCtrl = controllers[0];\r\n        var bsCollapseCtrl = controllers[1];\r\n\r\n        // Add base class\r\n        element.addClass('collapse');\r\n\r\n        // Add animation class\r\n        if (bsCollapseCtrl.$options.animation) {\r\n          element.addClass(bsCollapseCtrl.$options.animation);\r\n        }\r\n\r\n        // Push pane to parent bsCollapse controller\r\n        bsCollapseCtrl.$registerTarget(element);\r\n\r\n        // remove pane target from collapse controller when target is destroyed\r\n        scope.$on('$destroy', function () {\r\n          bsCollapseCtrl.$unregisterTarget(element);\r\n        });\r\n\r\n        function render () {\r\n          var index = bsCollapseCtrl.$targets.indexOf(element);\r\n          var active = bsCollapseCtrl.$activeIndexes();\r\n          var action = 'removeClass';\r\n          if (angular.isArray(active)) {\r\n            if (active.indexOf(index) !== -1) {\r\n              action = 'addClass';\r\n            }\r\n          } else if (index === active) {\r\n            action = 'addClass';\r\n          }\r\n\r\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\r\n        }\r\n\r\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\r\n          render();\r\n        });\r\n        render();\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.button', [])\r\n\r\n  .provider('$button', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      activeClass: 'active',\r\n      toggleEvent: 'click'\r\n    };\r\n\r\n    this.$get = function () {\r\n      return {defaults: defaults};\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckboxGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\r\n        angular.forEach(children, function (child) {\r\n          var childEl = angular.element(child);\r\n          childEl.attr('bs-checkbox', '');\r\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsCheckbox', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support label > input[type=\"checkbox\"]\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\r\n        if (constantValueRegExp.test(attr.trueValue)) {\r\n          trueValue = scope.$eval(attr.trueValue);\r\n        }\r\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\r\n        if (constantValueRegExp.test(attr.falseValue)) {\r\n          falseValue = scope.$eval(attr.falseValue);\r\n        }\r\n\r\n        // Parse exotic values\r\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\r\n        if (hasExoticValues) {\r\n          controller.$parsers.push(function (viewValue) {\r\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\r\n            return viewValue ? trueValue : falseValue;\r\n          });\r\n          // modelValue -> $formatters -> viewValue\r\n          controller.$formatters.push(function (modelValue) {\r\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\r\n            return angular.equals(modelValue, trueValue);\r\n          });\r\n        }\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = !!controller.$viewValue;\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            if (!isInput) {\r\n              controller.$setViewValue(!activeElement.hasClass('active'));\r\n            }\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadioGroup', function () {\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      compile: function postLink (element, attr) {\r\n        element.attr('data-toggle', 'buttons');\r\n        element.removeAttr('ng-model');\r\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\r\n        angular.forEach(children, function (child) {\r\n          angular.element(child).attr('bs-radio', '');\r\n          angular.element(child).attr('ng-model', attr.ngModel);\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsRadio', function ($button, $$rAF) {\r\n\r\n    var defaults = $button.defaults;\r\n    var constantValueRegExp = /^(true|false|\\d+)$/;\r\n\r\n    return {\r\n      restrict: 'A',\r\n      require: 'ngModel',\r\n      link: function postLink (scope, element, attr, controller) {\r\n\r\n        var options = defaults;\r\n\r\n        // Support `label > input[type=\"radio\"]` markup\r\n        var isInput = element[0].nodeName === 'INPUT';\r\n        var activeElement = isInput ? element.parent() : element;\r\n\r\n        var value;\r\n        attr.$observe('value', function (v) {\r\n          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {\r\n            value = scope.$eval(v);\r\n          } else {\r\n            value = v;\r\n          }\r\n          controller.$render();\r\n        });\r\n\r\n        // model -> view\r\n        controller.$render = function () {\r\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\r\n          var isActive = angular.equals(controller.$viewValue, value);\r\n          $$rAF(function () {\r\n            if (isInput) element[0].checked = isActive;\r\n            activeElement.toggleClass(options.activeClass, isActive);\r\n          });\r\n        };\r\n\r\n        // view -> model\r\n        element.bind(options.toggleEvent, function () {\r\n          scope.$apply(function () {\r\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\r\n            controller.$setViewValue(value);\r\n            controller.$render();\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$aside', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade-and-slide-right',\r\n      prefixClass: 'aside',\r\n      prefixEvent: 'aside',\r\n      placement: 'right',\r\n      templateUrl: 'aside/aside.tpl.html',\r\n      contentTemplate: false,\r\n      container: false,\r\n      element: null,\r\n      backdrop: true,\r\n      keyboard: true,\r\n      html: false,\r\n      show: true\r\n    };\r\n\r\n    this.$get = function ($modal) {\r\n\r\n      function AsideFactory (config) {\r\n\r\n        var $aside = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $aside = $modal(options);\r\n\r\n        return $aside;\r\n\r\n      }\r\n\r\n      return AsideFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAside', function ($window, $sce, $aside) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAside) {\r\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize aside\r\n        var aside = $aside(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', aside.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (aside) aside.destroy();\r\n          options = null;\r\n          aside = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\n// @BUG: following snippet won't compile correctly\r\n\r\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\r\n\r\n  .provider('$alert', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      prefixClass: 'alert',\r\n      prefixEvent: 'alert',\r\n      placement: null,\r\n      templateUrl: 'alert/alert.tpl.html',\r\n      container: false,\r\n      element: null,\r\n      backdrop: false,\r\n      keyboard: true,\r\n      show: true,\r\n      // Specific options\r\n      duration: false,\r\n      type: false,\r\n      dismissable: true,\r\n      focusMeDisabled: false\r\n    };\r\n\r\n    this.$get = function ($modal, $timeout) {\r\n\r\n      function AlertFactory (config) {\r\n\r\n        var $alert = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n\r\n        $alert = $modal(options);\r\n        $alert.returnFocus = function () {\r\n          function findFocusableElements () {\r\n            var containerEl = angular.element($alert.$element).closest('[ng-controller]');\r\n            return containerEl.find('a:not([disabled]),button:not([disabled]),input:not([disabled]),select:not([disabled]),[tabindex]:not([disabled]):not([tabindex=\"-1\"])').filter(function (i, el) {\r\n              return !angular.element(el).parentsUntil(containerEl, '[tabindex=\"-1\"]').length;\r\n            });\r\n          }\r\n\r\n          function findNextFocusableElement () {\r\n            if (document.activeElement) {\r\n              var focusable = findFocusableElements().toArray();\r\n              if (focusable === undefined) return;\r\n              var index = focusable.indexOf(document.activeElement);\r\n              return focusable[index + 1];\r\n            }\r\n          }\r\n          angular.element(findNextFocusableElement()).trigger('focus');\r\n        };\r\n\r\n        // Support scope as string options [/*title, content, */ type, dismissable]\r\n        $alert.$scope.dismissable = !!options.dismissable;\r\n        if (options.type) {\r\n          $alert.$scope.type = options.type;\r\n        }\r\n        if (options.focusMeDisabled) {\r\n          $alert.$scope.focusMeDisabled = options.focusMeDisabled;\r\n        }\r\n\r\n        // Support auto-close duration\r\n        var show = $alert.show;\r\n        if (options.duration) {\r\n          $alert.show = function () {\r\n            show();\r\n            $timeout(function () {\r\n              $alert.hide();\r\n            }, options.duration * 1000);\r\n          };\r\n        }\r\n\r\n        return $alert;\r\n\r\n      }\r\n\r\n      return AlertFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAlert', function ($window, $sce, $alert) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink (scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope, element: element, show: false};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\r\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\r\n        });\r\n\r\n        // bind functions from the attrs to the show and hide events\r\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\r\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\r\n          if (angular.isDefined(attr[bsKey])) {\r\n            options[key] = scope.$eval(attr[bsKey]);\r\n          }\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')) {\r\n          scope.title = '';\r\n        }\r\n\r\n        // Support scope as data-attrs\r\n        angular.forEach(['title', 'content', 'type'], function (key) {\r\n          if (attr[key]) {\r\n            attr.$observe(key, function (newValue, oldValue) {\r\n              scope[key] = $sce.trustAsHtml(newValue);\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        if (attr.bsAlert) {\r\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\r\n            if (angular.isObject(newValue)) {\r\n              angular.extend(scope, newValue);\r\n            } else {\r\n              scope.content = newValue;\r\n            }\r\n          }, true);\r\n        }\r\n\r\n        // Initialize alert\r\n        var alert = $alert(options);\r\n\r\n        // Trigger\r\n        element.on(attr.trigger || 'click', alert.toggle);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function () {\r\n          if (alert) alert.destroy();\r\n          options = null;\r\n          alert = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\r\n\r\n  .provider('$affix', function () {\r\n\r\n    var defaults = this.defaults = {\r\n      offsetTop: 'auto',\r\n      inlineStyles: true,\r\n      setWidth: true\r\n    };\r\n\r\n    this.$get = function ($window, debounce, dimensions) {\r\n\r\n      var bodyEl = angular.element($window.document.body);\r\n      var windowEl = angular.element($window);\r\n\r\n      function AffixFactory (element, config) {\r\n\r\n        var $affix = {};\r\n\r\n        // Common vars\r\n        var options = angular.extend({}, defaults, config);\r\n        var targetEl = options.target;\r\n\r\n        // Initial private vars\r\n        var reset = 'affix affix-top affix-bottom';\r\n        var setWidth = false;\r\n        var initialAffixTop = 0;\r\n        var initialOffsetTop = 0;\r\n        var offsetTop = 0;\r\n        var offsetBottom = 0;\r\n        var affixed = null;\r\n        var unpin = null;\r\n\r\n        var parent = element.parent();\r\n        // Options: custom parent\r\n        if (options.offsetParent) {\r\n          if (options.offsetParent.match(/^\\d+$/)) {\r\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\r\n              parent = parent.parent();\r\n            }\r\n          } else {\r\n            parent = angular.element(options.offsetParent);\r\n          }\r\n        }\r\n\r\n        $affix.init = function () {\r\n\r\n          this.$parseOffsets();\r\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\r\n          setWidth = options.setWidth && !element[0].style.width;\r\n\r\n          // Bind events\r\n          targetEl.on('scroll', this.checkPosition);\r\n          targetEl.on('click', this.checkPositionWithEventLoop);\r\n          windowEl.on('resize', this.$debouncedOnResize);\r\n\r\n          // Both of these checkPosition() calls are necessary for the case where\r\n          // the user hits refresh after scrolling to the bottom of the page.\r\n          this.checkPosition();\r\n          this.checkPositionWithEventLoop();\r\n\r\n        };\r\n\r\n        $affix.destroy = function () {\r\n\r\n          // Unbind events\r\n          targetEl.off('scroll', this.checkPosition);\r\n          targetEl.off('click', this.checkPositionWithEventLoop);\r\n          windowEl.off('resize', this.$debouncedOnResize);\r\n\r\n        };\r\n\r\n        $affix.checkPositionWithEventLoop = function () {\r\n\r\n          // IE 9 throws an error if we use 'this' instead of '$affix'\r\n          // in this setTimeout call\r\n          setTimeout($affix.checkPosition, 1);\r\n\r\n        };\r\n\r\n        $affix.checkPosition = function () {\r\n          // if (!this.$element.is(':visible')) return\r\n\r\n          var scrollTop = getScrollTop();\r\n          var position = dimensions.offset(element[0]);\r\n          var elementHeight = dimensions.height(element[0]);\r\n\r\n          // Get required affix class according to position\r\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\r\n\r\n          // Did affix status changed this last check?\r\n          if (affixed === affix) return;\r\n          affixed = affix;\r\n\r\n          if (affix === 'top') {\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', '');\r\n            }\r\n          } else if (affix === 'bottom') {\r\n            if (options.offsetUnpin) {\r\n              unpin = -(options.offsetUnpin * 1);\r\n            } else {\r\n              // Calculate unpin threshold when affixed to bottom.\r\n              // Hopefully the browser scrolls pixel by pixel.\r\n              unpin = position.top - scrollTop;\r\n            }\r\n            if (setWidth) {\r\n              element.css('width', '');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', (options.offsetParent) ? '' : 'relative');\r\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\r\n            }\r\n          } else { // affix === 'middle'\r\n            unpin = null;\r\n            if (setWidth) {\r\n              element.css('width', element[0].offsetWidth + 'px');\r\n            }\r\n            if (options.inlineStyles) {\r\n              element.css('position', 'fixed');\r\n              element.css('top', initialAffixTop + 'px');\r\n            }\r\n          }\r\n\r\n          // Add proper affix class\r\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\r\n\r\n        };\r\n\r\n        $affix.$onResize = function () {\r\n          $affix.$parseOffsets();\r\n          $affix.checkPosition();\r\n        };\r\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\r\n\r\n        $affix.$parseOffsets = function () {\r\n          var initialPosition = element[0].style.position;\r\n          var initialTop = element[0].style.top;\r\n          // Reset position to calculate correct offsetTop\r\n          if (options.inlineStyles) {\r\n            element.css('position', (options.offsetParent) ? '' : 'relative');\r\n            element.css('top', '');\r\n          }\r\n\r\n          if (options.offsetTop) {\r\n            if (options.offsetTop === 'auto') {\r\n              options.offsetTop = '+0';\r\n            }\r\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\r\n              initialAffixTop = - options.offsetTop * 1;\r\n              if (options.offsetParent) {\r\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\r\n              } else {\r\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\r\n              }\r\n            } else {\r\n              offsetTop = options.offsetTop * 1;\r\n            }\r\n          }\r\n\r\n          if (options.offsetBottom) {\r\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\r\n              // add 1 pixel due to rounding problems...\r\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\r\n            } else {\r\n              offsetBottom = options.offsetBottom * 1;\r\n            }\r\n          }\r\n\r\n          // Bring back the element's position after calculations\r\n          if (options.inlineStyles) {\r\n            element.css('position', initialPosition);\r\n            element.css('top', initialTop);\r\n          }\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\r\n          var scrollTop = getScrollTop();\r\n          var scrollHeight = getScrollHeight();\r\n\r\n          if (scrollTop <= offsetTop) {\r\n            return 'top';\r\n          } else if (_unpin !== null) {\r\n            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';\r\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\r\n            return 'bottom';\r\n          }\r\n          return 'middle';\r\n        }\r\n\r\n        function getScrollTop () {\r\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\r\n        }\r\n\r\n        function getScrollHeight () {\r\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\r\n        }\r\n\r\n        $affix.init();\r\n        return $affix;\r\n\r\n      }\r\n\r\n      return AffixFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffix', function ($affix, $window, $timeout) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      require: '^?bsAffixTarget',\r\n      link: function postLink (scope, element, attr, affixTarget) {\r\n\r\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\r\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth'], function (key) {\r\n          if (angular.isDefined(attr[key])) {\r\n            var option = attr[key];\r\n            if (/true/i.test(option)) option = true;\r\n            if (/false/i.test(option)) option = false;\r\n            options[key] = option;\r\n          }\r\n        });\r\n\r\n        var affix;\r\n        $timeout(function () { affix = $affix(element, options); });\r\n        scope.$on('$destroy', function () {\r\n          if (affix) affix.destroy();\r\n          options = null;\r\n          affix = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsAffixTarget', function () {\r\n    return {\r\n      controller: function ($element) {\r\n        this.$element = $element;\r\n      }\r\n    };\r\n  });\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap', [\r\n  'mgcrea.ngStrap.modal',\r\n  'mgcrea.ngStrap.aside',\r\n  'mgcrea.ngStrap.alert',\r\n  'mgcrea.ngStrap.button',\r\n  'mgcrea.ngStrap.select',\r\n  'mgcrea.ngStrap.datepicker',\r\n  'mgcrea.ngStrap.timepicker',\r\n  'mgcrea.ngStrap.navbar',\r\n  'mgcrea.ngStrap.tooltip',\r\n  'mgcrea.ngStrap.popover',\r\n  'mgcrea.ngStrap.dropdown',\r\n  'mgcrea.ngStrap.typeahead',\r\n  'mgcrea.ngStrap.scrollspy',\r\n  'mgcrea.ngStrap.affix',\r\n  'mgcrea.ngStrap.tab',\r\n  'mgcrea.ngStrap.collapse'\r\n]);\r\n"]}