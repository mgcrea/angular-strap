{"version":3,"file":"affix.min.js","sources":["affix/affix.js"],"names":["angular","module","provider","defaults","this","offsetTop","$get","$window","debounce","dimensions","AffixFactory","element","config","getRequiredAffixClass","unpin","position","elementHeight","scrollTop","getScrollTop","scrollHeight","getScrollHeight","top","offsetBottom","initialAffixTop","targetEl","pageYOffset","document","body","$affix","options","extend","target","reset","initialOffsetTop","affixed","parent","offsetParent","match","i","init","$parseOffsets","offset","on","checkPosition","checkPositionWithEventLoop","windowEl","$debouncedOnResize","destroy","off","setTimeout","height","affix","removeClass","addClass","css","offsetUnpin","bodyEl","offsetHeight","$onResize","directive","restrict","require","link","scope","attr","affixTarget","$element","forEach","key","isDefined","$on","controller"],"mappings":"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","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto'\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          $affix.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n\n          // Bind events\n          targetEl.on('scroll', $affix.checkPosition);\n          targetEl.on('click', $affix.checkPositionWithEventLoop);\n          windowEl.on('resize', $affix.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          $affix.checkPosition();\n          $affix.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', $affix.checkPosition);\n          targetEl.off('click', $affix.checkPositionWithEventLoop);\n          windowEl.off('resize', $affix.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n          if(affix === 'top') {\n            unpin = null;\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n            element.css('top', '');\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n            element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n          } else { // affix === 'middle'\n            unpin = null;\n            element.css('position', 'fixed');\n            element.css('top', initialAffixTop + 'px');\n          }\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n\n          // Reset position to calculate correct offsetTop\n          element.css('position', (options.offsetParent) ? '' : 'relative');\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0] === $window;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, offsetTop: 'auto', target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n"],"sourceRoot":"/source/"}