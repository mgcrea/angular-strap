{"version":3,"sources":["modules/affix.js"],"names":["angular","windowEl","$window","defaults","AffixFactory","offsetTop","$affix","inlineStyles","options","this","$get","reset","debounce","dimensions","initialOffsetTop","config","getRequiredAffixClass","_unpin","position","top","scrollTop","getScrollTop","scrollHeight","getScrollHeight","targetEl","offsetBottom","elementHeight","initialAffixTop","pageYOffset","directive","document","extend","affixed","target","unpin","parent","element","offsetParent","i","match","init","$parseOffsets","on","checkPosition","require","checkPositionWithEventLoop","offset","destroy","style","width","off","affix","setTimeout","setWidth","height","css","offsetUnpin","bodyEl","offsetHeight","removeClass","addClass","offsetWidth","$onResize","$debouncedOnResize","initialPosition","restrict","body","affixTarget","$element","forEach","link","key","scope","option","$on","attr","test","controller"],"mappings":"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","file":"modules/affix.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function () {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function ($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory (element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom';\n        var setWidth = false;\n        var initialAffixTop = 0;\n        var initialOffsetTop = 0;\n        var offsetTop = 0;\n        var offsetBottom = 0;\n        var affixed = null;\n        var unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          } else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function () {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function () {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function () {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function () {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if (affixed === affix) return;\n          affixed = affix;\n\n          if (affix === 'top') {\n            unpin = null;\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if (affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            } else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if (setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function () {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function () {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles) {\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if (options.offsetTop) {\n            if (options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if (options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              } else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            } else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if (options.offsetBottom) {\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            } else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles) {\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass (_unpin, position, elementHeight) {\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if (scrollTop <= offsetTop) {\n            return 'top';\n          } else if (_unpin !== null && (scrollTop + _unpin <= position.top)) {\n            return 'middle';\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          }\n          return 'middle';\n        }\n\n        function getScrollTop () {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight () {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function ($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink (scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function (key) {\n          if (angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function () {\n          if (affix) affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function () {\n    return {\n      controller: function ($element) {\n        this.$element = $element;\n      }\n    };\n  });\n"],"sourceRoot":"/source/"}