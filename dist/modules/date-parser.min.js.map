{"version":3,"sources":["modules/date-parser.js"],"names":["angular","this","seconds","provider","$localeProvider","milliseconds","year","ParseDate","prototype","hours","value","array","isNumeric","i","isNaN","parseFloat","n","isFinite","indexOfCaseInsensitive","defaults","len","length","str","toString","toLowerCase","format","strict","DateParserFactory","minutes","day","month","getFullYear","getHours","getMilliseconds","getMonth","Date","getMinutes","proto","noop","toDate","$dateParser","regExpMap","sss","$get","options","$locale","dateFilter","mm","config","split","keys","setFnMap","map","index","clonedFormat","forEach","search","v","sortedMap","push","regExpForFormat","re","join","text","replace","Object","escapeReservedSymbols","RegExp","regex","m","extend","HH","H","hh","h","a","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","setSeconds","s","setMinutes","setHours","setDate","setMonth","match","setFullYear","setMap","init","setMapForFormat","$format","test","baseDate","formatRegex","formatSetMap","matches","date","getTime","timezone","newDate","parseInt","exec","fromDate","call","getDate","today","getDateForAttribute","key","isString","substr","getTimeForAttribute","time","daylightSavingAdjust","Infinity","parse","timezoneOffsetAdjust","undo"],"mappings":"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","file":"modules/date-parser.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function(value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format, timezone) {\n        // check for date format special names\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function(date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n"],"sourceRoot":"/source/"}