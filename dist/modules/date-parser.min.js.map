{"version":3,"sources":["helpers/date-parser.js"],"names":[],"mappings":"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","file":"date-parser.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date \n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.    \n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : proto.setFullYear\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format) {\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        return date.toDate();\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else { \n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n"],"sourceRoot":"/source/"}