{"version":3,"file":"date-parser.min.js","sources":["helpers/date-parser.js"],"names":[],"mappings":"qBASE,OAAA,iDAEA,eAAA,kBAAA,WAIA,QAAA,MAFA,GAAA,GAAA,KAAA,UASE,EAAA,KAAA,qCAEE,sDAKE,GAAA,SAAA,WAkFI,GAAA,MACA,GAAA,EAAA,OAAA,KAAA,GACA,KAAA,KAEA,EAAA,MACF,EAAA,EAAA,EAAA,EAAA,OAAA,IACF,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,EAAA,CACA,GAAA,GAAA,EAAA,OAAA,EAAA,GACA,GAAA,EAAA,MAAA,EAAA,IAAA,KAAA,IACE,EAAA,EAAA,MACA,EAAA,GAAA,EAAA,EAAA,KAUJ,qCAFA,GAAA,EAAA,KAAA,KAEA,UAGE,GAAA,GACA,MAAA,GAAA,QAAA,MAAA,SAAA,QAAA,OAAA,OAAA,QAAA,MAAA,OAAA,QAAA,OAAA,iBAGA,GAAA,GACA,GAAA,GAAA,EAAA,OAAA,KAAA,GAEE,EAAA,CAEF,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,4DAKF,EAAA,EAAA,MAAA,KAAA,EAAA,KAAA,KAAA,IAAA,EAAA,EAAA,IAAA,uDArHE,EAAA,QAAA,UAAA,EAAA,GAEA,KAEA,GACA,IAAA,WACA,GAAA,aACA,EAAA,EAAA,OAAA,cAAA,mBACA,GAAA,aACA,EAAA,EAAA,OAAA,cAAA,mBACA,GAAA,mBACA,EAAA,EAAA,OAAA,iBAAA,oBACA,GAAA,oBACA,EAAA,EAAA,OAAA,eAAA,iBACA,EAAA,QACA,KAAA,EAAA,iBAAA,IAAA,KAAA,KACA,IAAA,EAAA,iBAAA,SAAA,KAAA,KACA,GAAA,yBACA,EAAA,EAAA,OAAA,yBAAA,2BACF,KAAA,EAAA,iBAAA,MAAA,KAAA,iDAEA,GAAA,gBACE,EAAA,EAAA,OAAA,eAAA,iBACA,KAAA,gCACA,GAAA,WACA,EAAA,EAAA,OAAA,wBAAA,kBAGA,GACA,IAAA,EAAA,gBACA,GAAA,EAAA,WACA,EAAA,EAAA,WACA,GAAA,EAAA,WACA,EAAA,EAAA,WACA,GAAA,EAAA,SACA,EAAA,EAAA,SACA,GAAA,EAAA,SACA,EAAA,EAAA,SACA,KAAA,EACA,IAAA,EACA,GAAA,EAAA,QACA,EAAA,EAAA,QACA,EAAA,SAAA,GAAA,GAAA,GAAA,KAAA,UAAA,OAAA,MAAA,SAAA,EAAA,MAAA,OAAA,EAAA,GAAA,IACF,KAAA,SAAA,GAAA,MAAA,MAAA,SAAA,EAAA,iBAAA,MAAA,QAAA,qFAEA,GAAA,SAAA,GAAA,MAAA,MAAA,SAAA,EAAA,EAAA,+CAEA,KAAA,EAAA,YACE,GAAA,SAAA,GAAA,MAAA,MAAA,YAAA,IAAA,EAAA,IACA,EAAA,EAAA,sBAKA,KAAA,WACA,EAAA,QAAA,EAAA,iBAAA,EAAA,SAAA,EAAA,OACF,EAAA,EAAA,EAAA,2BAIE,QAAA,SAAA,GACA,MAAA,SAAA,OAAA,IAAA,MAAA,EAAA,WACA,EAAA,KAAA,MAGA,MAAA,SAAA,EAAA,EAAA,GACE,QAAA,OAAA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,SACF,IAAA,GAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EACF,EAAA,EAAA,KAAA,yBAEA,GAAA,GAAA,GAAA,MAAA,EAAA,EAAA,wBAEA,EAAA,IAAA,EAAA,GAAA,KAAA,EAAA,EAAA,EAAA,GAEE,OAAA,IAiDL,EAAA","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  var proto = Date.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours(); return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth($locale.DATETIME_FORMATS.MONTH.indexOf(value)); },\n        'MMM'   : function(value) { return this.setMonth($locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : proto.setFullYear\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format) {\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        var date = baseDate || new Date(0, 0, 1);\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n"],"sourceRoot":"/source/"}