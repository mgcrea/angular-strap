{"version":3,"sources":["helpers/dimensions.js"],"names":[],"mappings":"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","file":"dimensions.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n  \n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = fn.css(element, 'position'),\n          curElem = angular.element(element),\n          props = {};\n      \n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n      \n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && \n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n      \n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      \n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n      \n      if (options.top !== null ) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if ( options.left !== null ) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n"],"sourceRoot":"/source/"}