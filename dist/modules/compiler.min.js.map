{"version":3,"sources":["modules/compiler.js"],"names":["templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","$http","get","bsCompilerService","data","this","compile","controller","console","controllerAs","resolve","copy","locals","bindToController","angular","forEach","value","isString","$injector","key","invoke","transformTemplate","identity","extend","$template","when","$q","contentEl","findElement","outerHTML","contentTemplate","all","templateEl","removeAttr","html","templates","replace","next","remove","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","service","$inject"],"mappings":"AAOA,YAIA,SAmEQA,mBAAcC,EAAQD,EAAAA,EAAAA,EAAAA,EAAAA,GAF5B,QA4FyDE,GAAOC,EAAAA,GA3F9D,MA4FGC,SAAKC,SAASC,GAAAA,UAAAA,iBAAAA,IAzFnB,QAASC,GAAcC,GACrB,MAAIC,GAAcD,GAAkBC,EAAcD,GAC3CC,EAAcD,GAAYE,EAAMC,IAAIH,GA6F/CI,MAAAA,IA3FOR,KAAK,SAASE,GACf,MAAOA,GAAIO,OAzEfC,KAmEEC,QAAIP,SAAWP,GACXe,EAAAA,UAAaf,UAAQe,KAAAA,EAAAA,YACzBC,QAAIC,KAAAA,oGACJjB,EAAIkB,YAAkBC,EAAKnB,SAC3BA,EAAIoB,SAAiBD,GAErB,IAAIE,GAAAA,EAAmBrB,YAKvBsB,EAAQC,EAAQL,UAAkBM,GAChCT,EAAYU,EAASD,WACnBN,EAAeQ,EAAAA,aAtEfR,EAuEKI,QAAAH,KAAAnB,EAAAkB,aACLA,EAAQS,QAAOD,KAAAA,EAAUE,YAtEzBC,EAAoB7B,EAAQ6B,mBAAqBP,QAAQQ,SACzDT,EAAmBrB,EAAQqB,gBAsB/B,OAoDAC,SAAQS,QAAOb,EAASE,SAAAA,EAAAA,GAEpBrB,QAAAA,SAAayB,GACfN,EAAQc,GAAAA,EAAY1B,IAAAA,GAEpBY,EAAQc,GAAAA,EAAeC,OAAK1B,KAvE9Be,QA4EEJ,OAAQc,EAAYE,GAEhBnC,EA5EJmB,EA6EQiB,UAAYC,EAAYrC,GA3EhCmB,EA8EIc,UAAkBE,EAAGG,KAAAA,GA5EvBrC,EAAQsC,kBAiFZpB,EAAUqB,UAAIrB,EAASf,KAAKe,EAASE,UAAAA,EAAAA,EAAAA,mBAAAA,KAAAA,SAAAA,GAEnC,GAAIb,GAAWsB,QAAAA,QAAkBT,EAAOY,IACpChC,EAAcoC,EAAA,sBAAAI,EAAA,IAAAC,WAAA,WAAAC,KAAAC,EAAA,GA/EhB,OAgFApC,GAAWA,aAASqC,EAAQC,OAAeC,SAhFpCN,EAAW,GAAGH,aAuFvBH,EAAAK,IAAArB,GAAAf,KAAA,SAAAiB,GAnFA,GAoFEA,GAAQA,EAAAA,EAAAA,UACRhB,GAASA,OACT2C,EAAMxC,EAAcyC,QAAAA,cAAAA,kBAlFtB,IAsFI5C,GAAIW,QAAYX,QAAA,SAAAsC,KAAAnC,EAAA0C,QAAAC,WArFhBC,EAsFMC,EAAAA,EArFV,QACEhC,OAsFME,EArFNlB,QAASA,EACT2C,KAuFI,SAAWzB,GArFb,GADAF,EAwFEhB,OAAa4C,EACb5C,EAAQiD,CAER,GAAIpC,GAAAA,EAAcF,EAAAK,GAAA,EAChB4B,IAxFA1B,QAAQS,OAAOqB,EAAWE,SAAUlC,EA4FxC,IAAAmC,GAAOJ,QAAaK,SAAMC,GAAAA,EAAAA,GAzFxBrD,GAAQQ,KAAK,0BAA2B2C,GACxCnD,EAAQiD,WAAWzC,KAAK,0BAA2B2C,GAC/CtC,IACF+B,EAAM/B,GAAgBsC,GAG1B,MAAOJ,GAAOO,MAAM,KAAMD,eAQlC,IAAIjD,MAtENc,QAkEMtB,OAAQO,0BAAWoD,QAAA,cAAAhD,mBAezBA,kBAAkBiD,SAAY,KAAM,QAAS,YAAa,WAAY,cAAe","file":"modules/compiler.min.js","sourcesContent":["'use strict';\n\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n  /* jshint validthis: true */\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function(options) {\n\n    if(options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function(value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      resolve.$template = $q.when(template);\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function(templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]).removeAttr('ng-bind').html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if(!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function(locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement(query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate(template) {\n    if(fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function(res) {\n        return res.data;\n      }));\n  }\n\n}\n"],"sourceRoot":"/source/"}