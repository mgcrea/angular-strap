{"version":3,"sources":["tooltip/tooltip.js"],"names":[],"mappings":"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","file":"tooltip.min.js","sourcesContent":["'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function() {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      template: 'tooltip/tooltip.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true\r\n    };\r\n\r\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var trim = String.prototype.trim;\r\n      var isTouch = 'createTouch' in $window.document;\r\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory(element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var nodeName = element[0].nodeName.toLowerCase();\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        $tooltip.$promise = fetchTemplate(options.template);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n        if(options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Support scope as string options\r\n        if(options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function(isEnabled) {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout, hoverState;\r\n\r\n        // Support contentTemplate option\r\n        if(options.contentTemplate) {\r\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\r\n            var templateEl = angular.element(template);\r\n            return fetchTemplate(options.contentTemplate)\r\n            .then(function(contentTemplate) {\r\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\r\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\r\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\r\n              return templateEl[0].outerHTML;\r\n            });\r\n          });\r\n        }\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\r\n        $tooltip.$promise.then(function(template) {\r\n          if(angular.isObject(template)) template = template.data;\r\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\r\n          template = trim.apply(template);\r\n          tipTemplate = template;\r\n          tipLinker = $compile(template);\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function() {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if(options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if(angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if(options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if(options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if(options.show) {\r\n            scope.$$postDigest(function() {\r\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function() {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function() {\r\n            if (hoverState ==='in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function() {\r\n          if (!options.bsEnabled) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          var parent, after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if(tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if(options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if(options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          if(promise && promise.then) promise.then(enterAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          $$rAF(function () {\r\n            $tooltip.$applyPlacement();\r\n\r\n            // Once placed, make the tooltip visible\r\n            if(tipElement) tipElement.css({visibility: 'visible'});\r\n          }); // var a = bodyEl.offsetWidth + 1; ?\r\n\r\n          // Bind events\r\n          if(options.keyboard) {\r\n            if(options.trigger !== 'focus') {\r\n              $tooltip.focus();\r\n            }\r\n            bindKeyboardEvents();\r\n          }\r\n\r\n          if(options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n        }\r\n\r\n        $tooltip.leave = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        $tooltip.hide = function(blur) {\r\n\r\n          if(!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\r\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if(options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if(options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          // Allow to blur the input when hidden, like when pressing enter key\r\n          if(_blur && options.trigger === 'focus') {\r\n            return element[0].blur();\r\n          }\r\n\r\n          // clean up child scopes\r\n          destroyTipElement();\r\n        }\r\n\r\n        $tooltip.toggle = function() {\r\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\r\n        };\r\n\r\n        $tooltip.focus = function() {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function(isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function() {\r\n          if(!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement,\r\n              autoToken = /\\s?auto?\\s?/i,\r\n              autoPlace  = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition(),\r\n              tipWidth = tipElement.prop('offsetWidth'),\r\n              tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var container = options.container ? angular.element(document.querySelector(options.container)) : element.parent();\r\n            var containerPosition = getPosition(container);\r\n\r\n            // Determine if the vertical placement\r\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            // Determine the horizontal placement\r\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\r\n            // and flow in the opposite direction of their placement.\r\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\r\n                elementPosition.right + tipWidth > containerPosition.width) {\r\n\r\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\r\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\r\n                elementPosition.left - tipWidth < containerPosition.left) {\r\n\r\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacementCss(tipPosition.top, tipPosition.left);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function(evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function(evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function(evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents() {\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function(trigger) {\r\n            if(trigger === 'click') {\r\n              element.on('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents() {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if(trigger === 'click') {\r\n              element.off('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents() {\r\n          if(options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents() {\r\n          if(options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents() {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function() {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents() {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation(event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          if (elRect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            elRect = angular.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\r\n          }\r\n\r\n          var elPos;\r\n          if (options.container === 'body') {\r\n            elPos = dimensions.offset(el);\r\n          } else {\r\n            elPos = dimensions.position(el);\r\n          }\r\n\r\n          return angular.extend({}, elRect, elPos);\r\n        }\r\n\r\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n          case 'right':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left + position.width\r\n            };\r\n            break;\r\n          case 'bottom':\r\n            offset = {\r\n              top: position.top + position.height,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          case 'left':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left - actualWidth\r\n            };\r\n            break;\r\n          default:\r\n            offset = {\r\n              top: position.top - actualHeight,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          }\r\n\r\n          if(!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if(split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n            case 'left':\r\n              offset.left = position.left;\r\n              break;\r\n            case 'right':\r\n              offset.left =  position.left + position.width - actualWidth;\r\n            }\r\n          } else if(split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n            case 'top':\r\n              offset.top = position.top - actualHeight;\r\n              break;\r\n            case 'bottom':\r\n              offset.top = position.top + position.height;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacementCss(top, left) {\r\n          tipElement.css({ top: top + 'px', left: left + 'px' });\r\n        }\r\n\r\n        function destroyTipElement() {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if($tooltip.$isShown && tipElement !== null) {\r\n            if(options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if(options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if(tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if(tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest(scope) {\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n      }\r\n\r\n      function findElement(query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      var fetchPromises = {};\r\n      function fetchTemplate(template) {\r\n        if(fetchPromises[template]) return fetchPromises[template];\r\n        return (fetchPromises[template] = $q.when($templateCache.get(template) || $http.get(template))\r\n        .then(function(res) {\r\n          if(angular.isObject(res)) {\r\n            $templateCache.put(template, res.data);\r\n            return res.data;\r\n          }\r\n          return res;\r\n        }));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink(scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass'], function(key) {\r\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.title){\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function(newValue) {\r\n          if (angular.isDefined(newValue) || !scope.title) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            angular.isDefined(oldValue) && $$rAF(function() {\r\n              tooltip && tooltip.$applyPlacement();\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\r\n          if(angular.isObject(newValue)) {\r\n            angular.extend(scope, newValue);\r\n          } else {\r\n            scope.title = newValue;\r\n          }\r\n          angular.isDefined(oldValue) && $$rAF(function() {\r\n            tooltip && tooltip.$applyPlacement();\r\n          });\r\n        }, true);\r\n\r\n        // Visibility binding support\r\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n          newValue === true ? tooltip.show() : tooltip.hide();\r\n        });\r\n\r\n        // Enabled binding support\r\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\r\n        });\r\n\r\n        // Initialize popover\r\n        var tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function() {\r\n          if(tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n"],"sourceRoot":"/source/"}