{"version":3,"sources":["tooltip/tooltip.js"],"names":[],"mappings":"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","file":"tooltip.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px'\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // should not parse target attribute, only data-target\n        if(element.attr('data-target')) {\n          options.target = element.attr('data-target');\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}